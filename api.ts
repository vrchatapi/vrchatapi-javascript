/* tslint:disable */
/* eslint-disable */
/**
 * VRChat API Documentation
 *
 * The version of the OpenAPI document: 1.20.0
 * Contact: vrchatapi.lpv0t@aries.fyi
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';
import axiosCookieJarSupport from "axios-cookiejar-support";axiosCookieJarSupport(globalAxios);import { CookieJar } from "tough-cookie";globalAxios.defaults.jar = new CookieJar();globalAxios.defaults.withCredentials = true;

/**
 * 
 * @export
 * @interface APIConfig
 */
export interface APIConfig {
    /**
     * Unknown, probably voice optimization testing
     * @type {boolean}
     * @memberof APIConfig
     */
    'VoiceEnableDegradation': boolean;
    /**
     * Unknown, probably voice optimization testing
     * @type {boolean}
     * @memberof APIConfig
     */
    'VoiceEnableReceiverLimiting': boolean;
    /**
     * 
     * @type {APIConfigAccessLogsUrls}
     * @memberof APIConfig
     */
    'accessLogsUrls': APIConfigAccessLogsUrls;
    /**
     * VRChat\'s office address
     * @type {string}
     * @memberof APIConfig
     */
    'address': string;
    /**
     * 
     * @type {boolean}
     * @memberof APIConfig
     */
    'ageVerificationInviteVisible': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof APIConfig
     */
    'ageVerificationP': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof APIConfig
     */
    'ageVerificationStatusVisible': boolean;
    /**
     * Max retries for avatar analysis requests
     * @type {number}
     * @memberof APIConfig
     */
    'analysisMaxRetries': number;
    /**
     * Interval between retries for avatar analysis requests
     * @type {number}
     * @memberof APIConfig
     */
    'analysisRetryInterval': number;
    /**
     * Public Announcements
     * @type {Set<APIConfigAnnouncement>}
     * @memberof APIConfig
     */
    'announcements': Set<APIConfigAnnouncement>;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'analyticsSegment_NewUI_PctOfUsers': number;
    /**
     * Unknown
     * @type {string}
     * @memberof APIConfig
     */
    'analyticsSegment_NewUI_Salt': string;
    /**
     * List of supported Languages
     * @type {Array<string>}
     * @memberof APIConfig
     */
    'availableLanguageCodes': Array<string>;
    /**
     * List of supported Languages
     * @type {Array<string>}
     * @memberof APIConfig
     */
    'availableLanguages': Array<string>;
    /**
     * 
     * @type {APIConfigAvatarPerfLimiter}
     * @memberof APIConfig
     */
    'avatarPerfLimiter': APIConfigAvatarPerfLimiter;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'chatboxLogBufferSeconds': number;
    /**
     * apiKey to be used for all other requests
     * @type {string}
     * @memberof APIConfig
     */
    'clientApiKey': string;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'clientBPSCeiling': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'clientDisconnectTimeout': number;
    /**
     * Unknown
     * @type {boolean}
     * @memberof APIConfig
     */
    'clientNetDispatchThread'?: boolean;
    /**
     * Unknown
     * @type {boolean}
     * @memberof APIConfig
     */
    'clientNetDispatchThreadMobile': boolean;
    /**
     * Unknown
     * @type {boolean}
     * @memberof APIConfig
     */
    'clientNetInThread'?: boolean;
    /**
     * Unknown
     * @type {boolean}
     * @memberof APIConfig
     */
    'clientNetInThread2'?: boolean;
    /**
     * Unknown
     * @type {boolean}
     * @memberof APIConfig
     */
    'clientNetInThreadMobile'?: boolean;
    /**
     * Unknown
     * @type {boolean}
     * @memberof APIConfig
     */
    'clientNetInThreadMobile2'?: boolean;
    /**
     * Unknown
     * @type {boolean}
     * @memberof APIConfig
     */
    'clientNetOutThread'?: boolean;
    /**
     * Unknown
     * @type {boolean}
     * @memberof APIConfig
     */
    'clientNetOutThread2'?: boolean;
    /**
     * Unknown
     * @type {boolean}
     * @memberof APIConfig
     */
    'clientNetOutThreadMobile'?: boolean;
    /**
     * Unknown
     * @type {boolean}
     * @memberof APIConfig
     */
    'clientNetOutThreadMobile2'?: boolean;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'clientQR'?: number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'clientReservedPlayerBPS': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'clientSentCountAllowance': number;
    /**
     * 
     * @type {APIConfigConstants}
     * @memberof APIConfig
     */
    'constants': APIConfigConstants;
    /**
     * VRChat\'s contact email
     * @type {string}
     * @memberof APIConfig
     */
    'contactEmail': string;
    /**
     * VRChat\'s copyright-issues-related email
     * @type {string}
     * @memberof APIConfig
     */
    'copyrightEmail': string;
    /**
     * Current version number of the Privacy Agreement
     * @type {number}
     * @memberof APIConfig
     */
    'currentPrivacyVersion'?: number;
    /**
     * Current version number of the Terms of Service
     * @type {number}
     * @memberof APIConfig
     */
    'currentTOSVersion': number;
    /**
     * 
     * @type {string}
     * @memberof APIConfig
     */
    'defaultAvatar': string;
    /**
     * 
     * @type {string}
     * @memberof APIConfig
     */
    'defaultStickerSet': string;
    /**
     * Unknown
     * @type {Array<string>}
     * @memberof APIConfig
     */
    'devLanguageCodes'?: Array<string>;
    /**
     * Link to download the development SDK, use downloadUrls instead
     * @type {string}
     * @memberof APIConfig
     * @deprecated
     */
    'devSdkUrl': string;
    /**
     * Version of the development SDK
     * @type {string}
     * @memberof APIConfig
     * @deprecated
     */
    'devSdkVersion': string;
    /**
     * Unknown, \"dis\" maybe for disconnect?
     * @type {string}
     * @memberof APIConfig
     */
    'dis-countdown': string;
    /**
     * Unknown
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableAVProInProton'?: boolean;
    /**
     * Toggles if copying avatars should be disabled
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableAvatarCopying': boolean;
    /**
     * Toggles if avatar gating should be disabled. Avatar gating restricts uploading of avatars to people with the `system_avatar_access` Tag or `admin_avatar_access` Tag
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableAvatarGating': boolean;
    /**
     * Toggles if the Community Labs should be disabled
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableCommunityLabs': boolean;
    /**
     * Toggles if promotion out of Community Labs should be disabled
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableCommunityLabsPromotion': boolean;
    /**
     * Unknown
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableEmail': boolean;
    /**
     * Unknown
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableCaptcha'?: boolean;
    /**
     * Toggles if Analytics should be disabled.
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableEventStream': boolean;
    /**
     * Toggles if feedback gating should be disabled. Feedback gating restricts submission of feedback (reporting a World or User) to people with the `system_feedback_access` Tag.
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableFeedbackGating': boolean;
    /**
     * Unknown, probably toggles compilation of frontend web builds? So internal flag?
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableFrontendBuilds': boolean;
    /**
     * Toggles if gift drops should be disabled
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableGiftDrops': boolean;
    /**
     * Unknown
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableHello': boolean;
    /**
     * Toggles if signing up for Subscriptions in Oculus is disabled or not.
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableOculusSubs': boolean;
    /**
     * Toggles if new user account registration should be disabled.
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableRegistration': boolean;
    /**
     * Toggles if Steam Networking should be disabled. VRChat these days uses Photon Unity Networking (PUN) instead.
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableSteamNetworking': boolean;
    /**
     * Toggles if 2FA should be disabled.
     * @type {boolean}
     * @memberof APIConfig
     * @deprecated
     */
    'disableTwoFactorAuth': boolean;
    /**
     * Toggles if Udon should be universally disabled in-game.
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableUdon': boolean;
    /**
     * Toggles if account upgrading \"linking with Steam/Oculus\" should be disabled.
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableUpgradeAccount': boolean;
    /**
     * Download link for game on the Oculus Rift website.
     * @type {string}
     * @memberof APIConfig
     */
    'downloadLinkWindows': string;
    /**
     * 
     * @type {APIConfigDownloadURLList}
     * @memberof APIConfig
     */
    'downloadUrls': APIConfigDownloadURLList;
    /**
     * Array of DynamicWorldRow objects, used by the game to display the list of world rows
     * @type {Set<DynamicContentRow>}
     * @memberof APIConfig
     */
    'dynamicWorldRows': Set<DynamicContentRow>;
    /**
     * Unknown
     * @type {string}
     * @memberof APIConfig
     */
    'economyPauseEnd'?: string;
    /**
     * Unknown
     * @type {string}
     * @memberof APIConfig
     */
    'economyPauseStart'?: string;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'economyState'?: number;
    /**
     * 
     * @type {APIConfigEvents}
     * @memberof APIConfig
     */
    'events': APIConfigEvents;
    /**
     * Unknown
     * @type {boolean}
     * @memberof APIConfig
     */
    'forceUseLatestWorld': boolean;
    /**
     * Display type of gifts
     * @type {string}
     * @memberof APIConfig
     */
    'giftDisplayType': string;
    /**
     * Unknown
     * @type {string}
     * @memberof APIConfig
     */
    'googleApiClientId': string;
    /**
     * WorldID be \"offline\" on User profiles if you are not friends with that user.
     * @type {string}
     * @memberof APIConfig
     */
    'homeWorldId': string;
    /**
     * Redirect target if you try to open the base API domain in your browser
     * @type {string}
     * @memberof APIConfig
     */
    'homepageRedirectTarget': string;
    /**
     * WorldID be \"offline\" on User profiles if you are not friends with that user.
     * @type {string}
     * @memberof APIConfig
     */
    'hubWorldId': string;
    /**
     * A list of explicitly allowed origins that worlds can request images from via the Udon\'s [VRCImageDownloader#DownloadImage](https://creators.vrchat.com/worlds/udon/image-loading/#downloadimage).
     * @type {Array<string>}
     * @memberof APIConfig
     */
    'imageHostUrlList': Array<string>;
    /**
     * VRChat\'s job application email
     * @type {string}
     * @memberof APIConfig
     */
    'jobsEmail': string;
    /**
     * 
     * @type {APIConfigMinSupportedClientBuildNumber}
     * @memberof APIConfig
     */
    'minSupportedClientBuildNumber': APIConfigMinSupportedClientBuildNumber;
    /**
     * Minimum Unity version required for uploading assets
     * @type {string}
     * @memberof APIConfig
     */
    'minimumUnityVersionForUploads': string;
    /**
     * VRChat\'s moderation related email
     * @type {string}
     * @memberof APIConfig
     */
    'moderationEmail': string;
    /**
     * Used in-game to notify a user they aren\'t allowed to select avatars in private worlds
     * @type {string}
     * @memberof APIConfig
     */
    'notAllowedToSelectAvatarInPrivateWorldMessage': string;
    /**
     * 
     * @type {APIConfigOfflineAnalysis}
     * @memberof APIConfig
     */
    'offlineAnalysis': APIConfigOfflineAnalysis;
    /**
     * Unknown
     * @type {Array<string>}
     * @memberof APIConfig
     */
    'photonNameserverOverrides': Array<string>;
    /**
     * Unknown
     * @type {Array<string>}
     * @memberof APIConfig
     */
    'photonPublicKeys': Array<string>;
    /**
     * 
     * @type {APIConfigReportCategories}
     * @memberof APIConfig
     */
    'reportCategories': APIConfigReportCategories;
    /**
     * URL to the report form
     * @type {string}
     * @memberof APIConfig
     */
    'reportFormUrl': string;
    /**
     * 
     * @type {APIConfigReportOptions}
     * @memberof APIConfig
     */
    'reportOptions': APIConfigReportOptions;
    /**
     * 
     * @type {APIConfigReportReasons}
     * @memberof APIConfig
     */
    'reportReasons': APIConfigReportReasons;
    /**
     * 
     * @type {boolean}
     * @memberof APIConfig
     */
    'requireAgeVerificationBetaTag': boolean;
    /**
     * Link to the developer FAQ
     * @type {string}
     * @memberof APIConfig
     */
    'sdkDeveloperFaqUrl': string;
    /**
     * Link to the official VRChat Discord
     * @type {string}
     * @memberof APIConfig
     */
    'sdkDiscordUrl': string;
    /**
     * Used in the SDK to notify a user they aren\'t allowed to upload avatars/worlds yet
     * @type {string}
     * @memberof APIConfig
     */
    'sdkNotAllowedToPublishMessage': string;
    /**
     * Unity version supported by the SDK
     * @type {string}
     * @memberof APIConfig
     */
    'sdkUnityVersion': string;
    /**
     * A list of explicitly allowed origins that worlds can request strings from via the Udon\'s [VRCStringDownloader.LoadUrl](https://creators.vrchat.com/worlds/udon/string-loading/#ivrcstringdownload).
     * @type {Array<string>}
     * @memberof APIConfig
     */
    'stringHostUrlList': Array<string>;
    /**
     * VRChat\'s support email
     * @type {string}
     * @memberof APIConfig
     */
    'supportEmail': string;
    /**
     * VRChat\'s support form
     * @type {string}
     * @memberof APIConfig
     */
    'supportFormUrl': string;
    /**
     * Unknown
     * @type {boolean}
     * @memberof APIConfig
     */
    'timekeeping': boolean;
    /**
     * WorldID be \"offline\" on User profiles if you are not friends with that user.
     * @type {string}
     * @memberof APIConfig
     */
    'timeOutWorldId': string;
    /**
     * WorldID be \"offline\" on User profiles if you are not friends with that user.
     * @type {string}
     * @memberof APIConfig
     */
    'tutorialWorldId': string;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'updateRateMsMaximum': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'updateRateMsMinimum': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'updateRateMsNormal': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'updateRateMsUdonManual': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'uploadAnalysisPercent': number;
    /**
     * List of allowed URLs that bypass the \"Allow untrusted URL\'s\" setting in-game
     * @type {Array<string>}
     * @memberof APIConfig
     */
    'urlList': Array<string>;
    /**
     * Unknown
     * @type {boolean}
     * @memberof APIConfig
     */
    'useReliableUdpForVoice': boolean;
    /**
     * Download link for game on the Steam website.
     * @type {string}
     * @memberof APIConfig
     */
    'viveWindowsUrl': string;
    /**
     * List of allowed URLs that are allowed to host avatar assets
     * @type {Array<string>}
     * @memberof APIConfig
     */
    'whiteListedAssetUrls': Array<string>;
    /**
     * Currently used youtube-dl.exe version
     * @type {string}
     * @memberof APIConfig
     */
    'player-url-resolver-version': string;
    /**
     * Currently used youtube-dl.exe hash in SHA1-delimited format
     * @type {string}
     * @memberof APIConfig
     */
    'player-url-resolver-sha1': string;
    /**
     * Public key, hex encoded
     * @type {string}
     * @memberof APIConfig
     */
    'publicKey': string;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'websocketMaxFriendsRefreshDelay': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'websocketQuickReconnectTime': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'websocketReconnectMaxDelay': number;
}
/**
 * 
 * @export
 * @interface APIConfigAccessLogsUrls
 */
export interface APIConfigAccessLogsUrls {
    /**
     * 
     * @type {string}
     * @memberof APIConfigAccessLogsUrls
     */
    'Default'?: string;
    /**
     * 
     * @type {string}
     * @memberof APIConfigAccessLogsUrls
     */
    'Pico'?: string;
    /**
     * 
     * @type {string}
     * @memberof APIConfigAccessLogsUrls
     */
    'Quest'?: string;
    /**
     * 
     * @type {string}
     * @memberof APIConfigAccessLogsUrls
     */
    'XRElite'?: string;
}
/**
 * Public Announcement
 * @export
 * @interface APIConfigAnnouncement
 */
export interface APIConfigAnnouncement {
    /**
     * Announcement name
     * @type {string}
     * @memberof APIConfigAnnouncement
     */
    'name': string;
    /**
     * Announcement text
     * @type {string}
     * @memberof APIConfigAnnouncement
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface APIConfigAvatarPerfLimiter
 */
export interface APIConfigAvatarPerfLimiter {
    /**
     * 
     * @type {PerformanceLimiterInfo}
     * @memberof APIConfigAvatarPerfLimiter
     */
    'AndroidMobile': PerformanceLimiterInfo;
    /**
     * 
     * @type {PerformanceLimiterInfo}
     * @memberof APIConfigAvatarPerfLimiter
     */
    'PC': PerformanceLimiterInfo;
    /**
     * 
     * @type {PerformanceLimiterInfo}
     * @memberof APIConfigAvatarPerfLimiter
     */
    'Pico': PerformanceLimiterInfo;
    /**
     * 
     * @type {PerformanceLimiterInfo}
     * @memberof APIConfigAvatarPerfLimiter
     */
    'Quest': PerformanceLimiterInfo;
    /**
     * 
     * @type {PerformanceLimiterInfo}
     * @memberof APIConfigAvatarPerfLimiter
     */
    'XRElite': PerformanceLimiterInfo;
    /**
     * 
     * @type {PerformanceLimiterInfo}
     * @memberof APIConfigAvatarPerfLimiter
     */
    'iOSMobile': PerformanceLimiterInfo;
}
/**
 * Constants
 * @export
 * @interface APIConfigConstants
 */
export interface APIConfigConstants {
    /**
     * 
     * @type {APIConfigConstantsGROUPS}
     * @memberof APIConfigConstants
     */
    'GROUPS': APIConfigConstantsGROUPS;
    /**
     * 
     * @type {APIConfigConstantsINSTANCE}
     * @memberof APIConfigConstants
     */
    'INSTANCE': APIConfigConstantsINSTANCE;
    /**
     * 
     * @type {APIConfigConstantsLANGUAGE}
     * @memberof APIConfigConstants
     */
    'LANGUAGE': APIConfigConstantsLANGUAGE;
}
/**
 * Group-related constants
 * @export
 * @interface APIConfigConstantsGROUPS
 */
export interface APIConfigConstantsGROUPS {
    /**
     * Maximum group capacity
     * @type {number}
     * @memberof APIConfigConstantsGROUPS
     */
    'CAPACITY'?: number;
    /**
     * Requirements for transferring group ownership
     * @type {Array<string>}
     * @memberof APIConfigConstantsGROUPS
     */
    'GROUP_TRANSFER_REQUIREMENTS'?: Array<string>;
    /**
     * Maximum number of invite requests
     * @type {number}
     * @memberof APIConfigConstantsGROUPS
     */
    'MAX_INVITES_REQUESTS'?: number;
    /**
     * Maximum number of joined groups
     * @type {number}
     * @memberof APIConfigConstantsGROUPS
     */
    'MAX_JOINED'?: number;
    /**
     * Maximum number of joined groups for VRChat Plus members
     * @type {number}
     * @memberof APIConfigConstantsGROUPS
     */
    'MAX_JOINED_PLUS'?: number;
    /**
     * Maximum number of supported languages
     * @type {number}
     * @memberof APIConfigConstantsGROUPS
     */
    'MAX_LANGUAGES'?: number;
    /**
     * Maximum number of group links
     * @type {number}
     * @memberof APIConfigConstantsGROUPS
     */
    'MAX_LINKS'?: number;
    /**
     * Maximum number of management roles in a group
     * @type {number}
     * @memberof APIConfigConstantsGROUPS
     */
    'MAX_MANAGEMENT_ROLES'?: number;
    /**
     * Maximum number of groups a user can own
     * @type {number}
     * @memberof APIConfigConstantsGROUPS
     */
    'MAX_OWNED'?: number;
    /**
     * Maximum number of roles in a group
     * @type {number}
     * @memberof APIConfigConstantsGROUPS
     */
    'MAX_ROLES'?: number;
}
/**
 * Instance-related constants
 * @export
 * @interface APIConfigConstantsINSTANCE
 */
export interface APIConfigConstantsINSTANCE {
    /**
     * 
     * @type {APIConfigConstantsINSTANCEPOPULATIONBRACKETS}
     * @memberof APIConfigConstantsINSTANCE
     */
    'POPULATION_BRACKETS'?: APIConfigConstantsINSTANCEPOPULATIONBRACKETS;
}
/**
 * Population brackets based on instance population
 * @export
 * @interface APIConfigConstantsINSTANCEPOPULATIONBRACKETS
 */
export interface APIConfigConstantsINSTANCEPOPULATIONBRACKETS {
    /**
     * 
     * @type {APIConfigConstantsINSTANCEPOPULATIONBRACKETSCROWDED}
     * @memberof APIConfigConstantsINSTANCEPOPULATIONBRACKETS
     */
    'CROWDED'?: APIConfigConstantsINSTANCEPOPULATIONBRACKETSCROWDED;
    /**
     * 
     * @type {APIConfigConstantsINSTANCEPOPULATIONBRACKETSFEW}
     * @memberof APIConfigConstantsINSTANCEPOPULATIONBRACKETS
     */
    'FEW'?: APIConfigConstantsINSTANCEPOPULATIONBRACKETSFEW;
    /**
     * 
     * @type {APIConfigConstantsINSTANCEPOPULATIONBRACKETSMANY}
     * @memberof APIConfigConstantsINSTANCEPOPULATIONBRACKETS
     */
    'MANY'?: APIConfigConstantsINSTANCEPOPULATIONBRACKETSMANY;
}
/**
 * Crowded population range
 * @export
 * @interface APIConfigConstantsINSTANCEPOPULATIONBRACKETSCROWDED
 */
export interface APIConfigConstantsINSTANCEPOPULATIONBRACKETSCROWDED {
    /**
     * Maximum population for a crowded instance
     * @type {number}
     * @memberof APIConfigConstantsINSTANCEPOPULATIONBRACKETSCROWDED
     */
    'max'?: number;
    /**
     * Minimum population for a crowded instance
     * @type {number}
     * @memberof APIConfigConstantsINSTANCEPOPULATIONBRACKETSCROWDED
     */
    'min'?: number;
}
/**
 * Few population range
 * @export
 * @interface APIConfigConstantsINSTANCEPOPULATIONBRACKETSFEW
 */
export interface APIConfigConstantsINSTANCEPOPULATIONBRACKETSFEW {
    /**
     * Maximum population for a few instance
     * @type {number}
     * @memberof APIConfigConstantsINSTANCEPOPULATIONBRACKETSFEW
     */
    'max'?: number;
    /**
     * Minimum population for a few instance
     * @type {number}
     * @memberof APIConfigConstantsINSTANCEPOPULATIONBRACKETSFEW
     */
    'min'?: number;
}
/**
 * Many population range
 * @export
 * @interface APIConfigConstantsINSTANCEPOPULATIONBRACKETSMANY
 */
export interface APIConfigConstantsINSTANCEPOPULATIONBRACKETSMANY {
    /**
     * Maximum population for a many instance
     * @type {number}
     * @memberof APIConfigConstantsINSTANCEPOPULATIONBRACKETSMANY
     */
    'max'?: number;
    /**
     * Minimum population for a many instance
     * @type {number}
     * @memberof APIConfigConstantsINSTANCEPOPULATIONBRACKETSMANY
     */
    'min'?: number;
}
/**
 * Language-related constants
 * @export
 * @interface APIConfigConstantsLANGUAGE
 */
export interface APIConfigConstantsLANGUAGE {
    /**
     * Supported spoken language options
     * @type {{ [key: string]: string; }}
     * @memberof APIConfigConstantsLANGUAGE
     */
    'SPOKEN_LANGUAGE_OPTIONS'?: { [key: string]: string; };
}
/**
 * Download links for various development assets.
 * @export
 * @interface APIConfigDownloadURLList
 */
export interface APIConfigDownloadURLList {
    /**
     * Download link for legacy SDK2
     * @type {string}
     * @memberof APIConfigDownloadURLList
     * @deprecated
     */
    'sdk2': string;
    /**
     * Download link for SDK3 for Avatars
     * @type {string}
     * @memberof APIConfigDownloadURLList
     */
    'sdk3-avatars': string;
    /**
     * Download link for SDK3 for Worlds
     * @type {string}
     * @memberof APIConfigDownloadURLList
     */
    'sdk3-worlds': string;
    /**
     * Download link for the Creator Companion
     * @type {string}
     * @memberof APIConfigDownloadURLList
     */
    'vcc': string;
    /**
     * Download link for ???
     * @type {string}
     * @memberof APIConfigDownloadURLList
     */
    'bootstrap': string;
}
/**
 * 
 * @export
 * @interface APIConfigEvents
 */
export interface APIConfigEvents {
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfigEvents
     */
    'distanceClose': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfigEvents
     */
    'distanceFactor': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfigEvents
     */
    'distanceFar': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfigEvents
     */
    'groupDistance': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfigEvents
     */
    'maximumBunchSize': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfigEvents
     */
    'notVisibleFactor': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfigEvents
     */
    'playerOrderBucketSize': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfigEvents
     */
    'playerOrderFactor': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfigEvents
     */
    'slowUpdateFactorThreshold': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfigEvents
     */
    'viewSegmentLength': number;
}
/**
 * Minimum supported client build number for various platforms
 * @export
 * @interface APIConfigMinSupportedClientBuildNumber
 */
export interface APIConfigMinSupportedClientBuildNumber {
    /**
     * 
     * @type {PlatformBuildInfo}
     * @memberof APIConfigMinSupportedClientBuildNumber
     */
    'AppStore': PlatformBuildInfo;
    /**
     * 
     * @type {PlatformBuildInfo}
     * @memberof APIConfigMinSupportedClientBuildNumber
     */
    'Default': PlatformBuildInfo;
    /**
     * 
     * @type {PlatformBuildInfo}
     * @memberof APIConfigMinSupportedClientBuildNumber
     */
    'Firebase': PlatformBuildInfo;
    /**
     * 
     * @type {PlatformBuildInfo}
     * @memberof APIConfigMinSupportedClientBuildNumber
     */
    'FirebaseiOS': PlatformBuildInfo;
    /**
     * 
     * @type {PlatformBuildInfo}
     * @memberof APIConfigMinSupportedClientBuildNumber
     */
    'GooglePlay': PlatformBuildInfo;
    /**
     * 
     * @type {PlatformBuildInfo}
     * @memberof APIConfigMinSupportedClientBuildNumber
     */
    'PC': PlatformBuildInfo;
    /**
     * 
     * @type {PlatformBuildInfo}
     * @memberof APIConfigMinSupportedClientBuildNumber
     */
    'PicoStore': PlatformBuildInfo;
    /**
     * 
     * @type {PlatformBuildInfo}
     * @memberof APIConfigMinSupportedClientBuildNumber
     */
    'QuestAppLab': PlatformBuildInfo;
    /**
     * 
     * @type {PlatformBuildInfo}
     * @memberof APIConfigMinSupportedClientBuildNumber
     */
    'QuestStore': PlatformBuildInfo;
    /**
     * 
     * @type {PlatformBuildInfo}
     * @memberof APIConfigMinSupportedClientBuildNumber
     */
    'TestFlight': PlatformBuildInfo;
    /**
     * 
     * @type {PlatformBuildInfo}
     * @memberof APIConfigMinSupportedClientBuildNumber
     */
    'XRElite': PlatformBuildInfo;
}
/**
 * Whether to allow offline analysis
 * @export
 * @interface APIConfigOfflineAnalysis
 */
export interface APIConfigOfflineAnalysis {
    /**
     * Whether to allow offline analysis
     * @type {boolean}
     * @memberof APIConfigOfflineAnalysis
     */
    'android'?: boolean;
    /**
     * Whether to allow offline analysis
     * @type {boolean}
     * @memberof APIConfigOfflineAnalysis
     */
    'standalonewindows'?: boolean;
}
/**
 * Categories available for reporting objectionable content
 * @export
 * @interface APIConfigReportCategories
 */
export interface APIConfigReportCategories {
    /**
     * 
     * @type {ReportCategory}
     * @memberof APIConfigReportCategories
     */
    'avatar': ReportCategory;
    /**
     * 
     * @type {ReportCategory}
     * @memberof APIConfigReportCategories
     */
    'avatarpage'?: ReportCategory;
    /**
     * 
     * @type {ReportCategory}
     * @memberof APIConfigReportCategories
     */
    'behavior': ReportCategory;
    /**
     * 
     * @type {ReportCategory}
     * @memberof APIConfigReportCategories
     */
    'chat': ReportCategory;
    /**
     * 
     * @type {ReportCategory}
     * @memberof APIConfigReportCategories
     */
    'emoji'?: ReportCategory;
    /**
     * 
     * @type {ReportCategory}
     * @memberof APIConfigReportCategories
     */
    'environment': ReportCategory;
    /**
     * 
     * @type {ReportCategory}
     * @memberof APIConfigReportCategories
     */
    'groupstore': ReportCategory;
    /**
     * 
     * @type {ReportCategory}
     * @memberof APIConfigReportCategories
     */
    'image': ReportCategory;
    /**
     * 
     * @type {ReportCategory}
     * @memberof APIConfigReportCategories
     */
    'text': ReportCategory;
    /**
     * 
     * @type {ReportCategory}
     * @memberof APIConfigReportCategories
     */
    'sticker'?: ReportCategory;
    /**
     * 
     * @type {ReportCategory}
     * @memberof APIConfigReportCategories
     */
    'warnings': ReportCategory;
    /**
     * 
     * @type {ReportCategory}
     * @memberof APIConfigReportCategories
     */
    'worldimage': ReportCategory;
    /**
     * 
     * @type {ReportCategory}
     * @memberof APIConfigReportCategories
     */
    'worldstore': ReportCategory;
}
/**
 * Options for reporting content
 * @export
 * @interface APIConfigReportOptions
 */
export interface APIConfigReportOptions {
    /**
     * 
     * @type {APIConfigReportOptionsAvatar}
     * @memberof APIConfigReportOptions
     */
    'avatar'?: APIConfigReportOptionsAvatar;
    /**
     * 
     * @type {APIConfigReportOptionsGroup}
     * @memberof APIConfigReportOptions
     */
    'group'?: APIConfigReportOptionsGroup;
    /**
     * 
     * @type {APIConfigReportOptionsUser}
     * @memberof APIConfigReportOptions
     */
    'user'?: APIConfigReportOptionsUser;
    /**
     * 
     * @type {APIConfigReportOptionsWorld}
     * @memberof APIConfigReportOptions
     */
    'world'?: APIConfigReportOptionsWorld;
}
/**
 * 
 * @export
 * @interface APIConfigReportOptionsAvatar
 */
export interface APIConfigReportOptionsAvatar {
    /**
     * 
     * @type {Array<string>}
     * @memberof APIConfigReportOptionsAvatar
     */
    'avatar'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof APIConfigReportOptionsAvatar
     */
    'avatarpage'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof APIConfigReportOptionsAvatar
     */
    'warnings'?: Array<string>;
}
/**
 * 
 * @export
 * @interface APIConfigReportOptionsGroup
 */
export interface APIConfigReportOptionsGroup {
    /**
     * 
     * @type {Array<string>}
     * @memberof APIConfigReportOptionsGroup
     */
    'groupstore'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof APIConfigReportOptionsGroup
     */
    'image'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof APIConfigReportOptionsGroup
     */
    'text'?: Array<string>;
}
/**
 * 
 * @export
 * @interface APIConfigReportOptionsUser
 */
export interface APIConfigReportOptionsUser {
    /**
     * 
     * @type {Array<string>}
     * @memberof APIConfigReportOptionsUser
     */
    'behavior'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof APIConfigReportOptionsUser
     */
    'chat'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof APIConfigReportOptionsUser
     */
    'emoji'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof APIConfigReportOptionsUser
     */
    'image'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof APIConfigReportOptionsUser
     */
    'sticker'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof APIConfigReportOptionsUser
     */
    'text'?: Array<string>;
}
/**
 * 
 * @export
 * @interface APIConfigReportOptionsWorld
 */
export interface APIConfigReportOptionsWorld {
    /**
     * 
     * @type {Array<string>}
     * @memberof APIConfigReportOptionsWorld
     */
    'environment'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof APIConfigReportOptionsWorld
     */
    'text'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof APIConfigReportOptionsWorld
     */
    'warnings'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof APIConfigReportOptionsWorld
     */
    'worldimage'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof APIConfigReportOptionsWorld
     */
    'worldstore'?: Array<string>;
}
/**
 * Reasons available for reporting users
 * @export
 * @interface APIConfigReportReasons
 */
export interface APIConfigReportReasons {
    /**
     * 
     * @type {ReportReason}
     * @memberof APIConfigReportReasons
     */
    'billing': ReportReason;
    /**
     * 
     * @type {ReportReason}
     * @memberof APIConfigReportReasons
     */
    'botting': ReportReason;
    /**
     * 
     * @type {ReportReason}
     * @memberof APIConfigReportReasons
     */
    'cancellation': ReportReason;
    /**
     * 
     * @type {ReportReason}
     * @memberof APIConfigReportReasons
     */
    'copyright'?: ReportReason;
    /**
     * 
     * @type {ReportReason}
     * @memberof APIConfigReportReasons
     */
    'fraud'?: ReportReason;
    /**
     * 
     * @type {ReportReason}
     * @memberof APIConfigReportReasons
     */
    'gore': ReportReason;
    /**
     * 
     * @type {ReportReason}
     * @memberof APIConfigReportReasons
     */
    'hacking': ReportReason;
    /**
     * 
     * @type {ReportReason}
     * @memberof APIConfigReportReasons
     */
    'harassing': ReportReason;
    /**
     * 
     * @type {ReportReason}
     * @memberof APIConfigReportReasons
     */
    'hateful': ReportReason;
    /**
     * 
     * @type {ReportReason}
     * @memberof APIConfigReportReasons
     */
    'impersonation': ReportReason;
    /**
     * 
     * @type {ReportReason}
     * @memberof APIConfigReportReasons
     */
    'inappropriate': ReportReason;
    /**
     * 
     * @type {ReportReason}
     * @memberof APIConfigReportReasons
     */
    'leaking': ReportReason;
    /**
     * 
     * @type {ReportReason}
     * @memberof APIConfigReportReasons
     */
    'malicious': ReportReason;
    /**
     * 
     * @type {ReportReason}
     * @memberof APIConfigReportReasons
     */
    'missing': ReportReason;
    /**
     * 
     * @type {ReportReason}
     * @memberof APIConfigReportReasons
     */
    'nudity': ReportReason;
    /**
     * 
     * @type {ReportReason}
     * @memberof APIConfigReportReasons
     */
    'renewal': ReportReason;
    /**
     * 
     * @type {ReportReason}
     * @memberof APIConfigReportReasons
     */
    'security': ReportReason;
    /**
     * 
     * @type {ReportReason}
     * @memberof APIConfigReportReasons
     */
    'service': ReportReason;
    /**
     * 
     * @type {ReportReason}
     * @memberof APIConfigReportReasons
     */
    'sexual': ReportReason;
    /**
     * 
     * @type {ReportReason}
     * @memberof APIConfigReportReasons
     */
    'technical'?: ReportReason;
    /**
     * 
     * @type {ReportReason}
     * @memberof APIConfigReportReasons
     */
    'threatening': ReportReason;
    /**
     * 
     * @type {ReportReason}
     * @memberof APIConfigReportReasons
     */
    'visuals': ReportReason;
}
/**
 * 
 * @export
 * @interface APIHealth
 */
export interface APIHealth {
    /**
     * 
     * @type {boolean}
     * @memberof APIHealth
     */
    'ok': boolean;
    /**
     * 
     * @type {string}
     * @memberof APIHealth
     */
    'serverName': string;
    /**
     * 
     * @type {string}
     * @memberof APIHealth
     */
    'buildVersionTag': string;
}
/**
 * 
 * @export
 * @interface AccountDeletionLog
 */
export interface AccountDeletionLog {
    /**
     * Typically \"Deletion requested\" or \"Deletion canceled\". Other messages like \"Deletion completed\" may exist, but are these are not possible to see as a regular user.
     * @type {string}
     * @memberof AccountDeletionLog
     */
    'message'?: string;
    /**
     * When the deletion is scheduled to happen, standard is 14 days after the request.
     * @type {string}
     * @memberof AccountDeletionLog
     */
    'deletionScheduled'?: string | null;
    /**
     * Date and time of the deletion request.
     * @type {string}
     * @memberof AccountDeletionLog
     */
    'dateTime'?: string;
}
/**
 * 
 * @export
 * @interface AddFavoriteRequest
 */
export interface AddFavoriteRequest {
    /**
     * 
     * @type {FavoriteType}
     * @memberof AddFavoriteRequest
     */
    'type': FavoriteType;
    /**
     * Must be either AvatarID, WorldID or UserID.
     * @type {string}
     * @memberof AddFavoriteRequest
     */
    'favoriteId': string;
    /**
     * Tags indicate which group this favorite belongs to. Adding multiple groups makes it show up in all. Removing it from one in that case removes it from all.
     * @type {Array<string>}
     * @memberof AddFavoriteRequest
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface AddGroupGalleryImageRequest
 */
export interface AddGroupGalleryImageRequest {
    /**
     * 
     * @type {string}
     * @memberof AddGroupGalleryImageRequest
     */
    'fileId': string;
}
/**
 * `verified` is obsolete.  User who have verified and are 18+ can switch to `plus18` status. 
 * @export
 * @enum {string}
 */

export const AgeVerificationStatus = {
    hidden: 'hidden',
    verified: 'verified',
    plus18: '18+'
} as const;

export type AgeVerificationStatus = typeof AgeVerificationStatus[keyof typeof AgeVerificationStatus];


/**
 * 
 * @export
 * @interface Avatar
 */
export interface Avatar {
    /**
     * 
     * @type {string}
     * @memberof Avatar
     */
    'acknowledgements'?: string;
    /**
     * Not present from general search `/avatars`, only on specific requests `/avatars/{avatarId}`.
     * @type {string}
     * @memberof Avatar
     */
    'assetUrl'?: string;
    /**
     * Not present from general search `/avatars`, only on specific requests `/avatars/{avatarId}`. **Deprecation:** `Object` has unknown usage/fields, and is always empty. Use normal `Url` field instead.
     * @type {object}
     * @memberof Avatar
     */
    'assetUrlObject'?: object;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof Avatar
     */
    'authorId': string;
    /**
     * 
     * @type {string}
     * @memberof Avatar
     */
    'authorName': string;
    /**
     * 
     * @type {string}
     * @memberof Avatar
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Avatar
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof Avatar
     */
    'featured': boolean;
    /**
     * 
     * @type {number}
     * @memberof Avatar
     */
    'highestPrice'?: number;
    /**
     * 
     * @type {string}
     * @memberof Avatar
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Avatar
     */
    'imageUrl': string;
    /**
     * 
     * @type {boolean}
     * @memberof Avatar
     */
    'lock'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Avatar
     */
    'lowestPrice'?: number;
    /**
     * 
     * @type {string}
     * @memberof Avatar
     */
    'name': string;
    /**
     * 
     * @type {AvatarPerformance}
     * @memberof Avatar
     */
    'performance': AvatarPerformance;
    /**
     * 
     * @type {string}
     * @memberof Avatar
     */
    'productId'?: string;
    /**
     * 
     * @type {Array<AvatarPublishedListingsInner>}
     * @memberof Avatar
     */
    'publishedListings'?: Array<AvatarPublishedListingsInner>;
    /**
     * 
     * @type {ReleaseStatus}
     * @memberof Avatar
     */
    'releaseStatus': ReleaseStatus;
    /**
     * 
     * @type {boolean}
     * @memberof Avatar
     */
    'searchable'?: boolean;
    /**
     * 
     * @type {AvatarStyles}
     * @memberof Avatar
     */
    'styles': AvatarStyles;
    /**
     *  
     * @type {Array<string>}
     * @memberof Avatar
     */
    'tags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Avatar
     */
    'thumbnailImageUrl': string;
    /**
     * 
     * @type {string}
     * @memberof Avatar
     */
    'unityPackageUrl': string;
    /**
     * 
     * @type {AvatarUnityPackageUrlObject}
     * @memberof Avatar
     * @deprecated
     */
    'unityPackageUrlObject': AvatarUnityPackageUrlObject;
    /**
     * 
     * @type {Set<UnityPackage>}
     * @memberof Avatar
     */
    'unityPackages': Set<UnityPackage>;
    /**
     * 
     * @type {string}
     * @memberof Avatar
     */
    'updated_at': string;
    /**
     * 
     * @type {number}
     * @memberof Avatar
     */
    'version': number;
}
/**
 * 
 * @export
 * @interface AvatarPerformance
 */
export interface AvatarPerformance {
    /**
     * 
     * @type {string}
     * @memberof AvatarPerformance
     */
    'android'?: string;
    /**
     * 
     * @type {number}
     * @memberof AvatarPerformance
     */
    'android-sort'?: number;
    /**
     * 
     * @type {string}
     * @memberof AvatarPerformance
     */
    'ios'?: string;
    /**
     * 
     * @type {number}
     * @memberof AvatarPerformance
     */
    'ios-sort'?: number;
    /**
     * 
     * @type {string}
     * @memberof AvatarPerformance
     */
    'standalonewindows'?: string;
    /**
     * 
     * @type {number}
     * @memberof AvatarPerformance
     */
    'standalonewindows-sort'?: number;
}
/**
 * 
 * @export
 * @interface AvatarPublishedListingsInner
 */
export interface AvatarPublishedListingsInner {
    /**
     * 
     * @type {string}
     * @memberof AvatarPublishedListingsInner
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof AvatarPublishedListingsInner
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AvatarPublishedListingsInner
     */
    'imageId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AvatarPublishedListingsInner
     */
    'listingId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AvatarPublishedListingsInner
     */
    'listingType'?: string;
    /**
     * 
     * @type {number}
     * @memberof AvatarPublishedListingsInner
     */
    'priceTokens'?: number;
}
/**
 * 
 * @export
 * @interface AvatarStyles
 */
export interface AvatarStyles {
    /**
     * 
     * @type {string}
     * @memberof AvatarStyles
     */
    'primary'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AvatarStyles
     */
    'secondary'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof AvatarStyles
     */
    'supplementary'?: Array<string>;
}
/**
 * **Deprecation:** `Object` has unknown usage/fields, and is always empty. Use normal `Url` field instead.
 * @export
 * @interface AvatarUnityPackageUrlObject
 */
export interface AvatarUnityPackageUrlObject {
    /**
     * 
     * @type {string}
     * @memberof AvatarUnityPackageUrlObject
     */
    'unityPackageUrl'?: string;
}
/**
 * 
 * @export
 * @interface Badge
 */
export interface Badge {
    /**
     * only present in CurrentUser badges
     * @type {string}
     * @memberof Badge
     */
    'assignedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Badge
     */
    'badgeDescription': string;
    /**
     * 
     * @type {string}
     * @memberof Badge
     */
    'badgeId': string;
    /**
     * direct url to image
     * @type {string}
     * @memberof Badge
     */
    'badgeImageUrl': string;
    /**
     * 
     * @type {string}
     * @memberof Badge
     */
    'badgeName': string;
    /**
     * only present in CurrentUser badges
     * @type {boolean}
     * @memberof Badge
     */
    'hidden'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof Badge
     */
    'showcased': boolean;
    /**
     * only present in CurrentUser badges
     * @type {string}
     * @memberof Badge
     */
    'updatedAt'?: string | null;
}
/**
 * 
 * @export
 * @interface Balance
 */
export interface Balance {
    /**
     * 
     * @type {number}
     * @memberof Balance
     */
    'balance': number;
    /**
     * 
     * @type {boolean}
     * @memberof Balance
     */
    'noTransactions'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Balance
     */
    'tiliaResponse'?: boolean;
}
/**
 * 
 * @export
 * @interface BanGroupMemberRequest
 */
export interface BanGroupMemberRequest {
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof BanGroupMemberRequest
     */
    'userId': string;
}
/**
 * 
 * @export
 * @interface ChangeUserTagsRequest
 */
export interface ChangeUserTagsRequest {
    /**
     * The tags being added or removed.
     * @type {Array<string>}
     * @memberof ChangeUserTagsRequest
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface CreateAvatarRequest
 */
export interface CreateAvatarRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateAvatarRequest
     */
    'assetUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAvatarRequest
     */
    'assetVersion'?: string;
    /**
     * This can be `standalonewindows` or `android`, but can also pretty much be any random Unity verison such as `2019.2.4-801-Release` or `2019.2.2-772-Release` or even `unknownplatform`.
     * @type {string}
     * @memberof CreateAvatarRequest
     */
    'platform'?: string;
    /**
     * A date and time of the pattern `M/d/yyyy h:mm:ss tt` (see C Sharp `System.DateTime`)
     * @type {string}
     * @memberof CreateAvatarRequest
     */
    'created_at'?: string;
    /**
     * A date and time of the pattern `M/d/yyyy h:mm:ss tt` (see C Sharp `System.DateTime`)
     * @type {string}
     * @memberof CreateAvatarRequest
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAvatarRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAvatarRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAvatarRequest
     */
    'description'?: string;
    /**
     *  
     * @type {Array<string>}
     * @memberof CreateAvatarRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateAvatarRequest
     */
    'imageUrl': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAvatarRequest
     */
    'thumbnailImageUrl'?: string;
    /**
     * 
     * @type {ReleaseStatus}
     * @memberof CreateAvatarRequest
     */
    'releaseStatus'?: ReleaseStatus;
    /**
     * 
     * @type {number}
     * @memberof CreateAvatarRequest
     */
    'version'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateAvatarRequest
     */
    'unityPackageUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAvatarRequest
     */
    'unityVersion'?: string;
}
/**
 * 
 * @export
 * @interface CreateFileRequest
 */
export interface CreateFileRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateFileRequest
     */
    'name': string;
    /**
     * 
     * @type {MIMEType}
     * @memberof CreateFileRequest
     */
    'mimeType': MIMEType;
    /**
     * 
     * @type {string}
     * @memberof CreateFileRequest
     */
    'extension': string;
    /**
     *  
     * @type {Array<string>}
     * @memberof CreateFileRequest
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreateFileVersionRequest
 */
export interface CreateFileVersionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateFileVersionRequest
     */
    'signatureMd5': string;
    /**
     * 
     * @type {number}
     * @memberof CreateFileVersionRequest
     */
    'signatureSizeInBytes': number;
    /**
     * 
     * @type {string}
     * @memberof CreateFileVersionRequest
     */
    'fileMd5'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateFileVersionRequest
     */
    'fileSizeInBytes'?: number;
}
/**
 * 
 * @export
 * @interface CreateGroupAnnouncementRequest
 */
export interface CreateGroupAnnouncementRequest {
    /**
     * Announcement title
     * @type {string}
     * @memberof CreateGroupAnnouncementRequest
     */
    'title': string;
    /**
     * Announcement text
     * @type {string}
     * @memberof CreateGroupAnnouncementRequest
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupAnnouncementRequest
     */
    'imageId'?: string;
    /**
     * Send notification to group members.
     * @type {boolean}
     * @memberof CreateGroupAnnouncementRequest
     */
    'sendNotification'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateGroupGalleryRequest
 */
export interface CreateGroupGalleryRequest {
    /**
     * Name of the gallery.
     * @type {string}
     * @memberof CreateGroupGalleryRequest
     */
    'name': string;
    /**
     * Description of the gallery.
     * @type {string}
     * @memberof CreateGroupGalleryRequest
     */
    'description'?: string;
    /**
     * Whether the gallery is members only.
     * @type {boolean}
     * @memberof CreateGroupGalleryRequest
     */
    'membersOnly'?: boolean;
    /**
     *  
     * @type {Array<string>}
     * @memberof CreateGroupGalleryRequest
     */
    'roleIdsToView'?: Array<string> | null;
    /**
     *  
     * @type {Array<string>}
     * @memberof CreateGroupGalleryRequest
     */
    'roleIdsToSubmit'?: Array<string> | null;
    /**
     *  
     * @type {Array<string>}
     * @memberof CreateGroupGalleryRequest
     */
    'roleIdsToAutoApprove'?: Array<string> | null;
    /**
     *  
     * @type {Array<string>}
     * @memberof CreateGroupGalleryRequest
     */
    'roleIdsToManage'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface CreateGroupInviteRequest
 */
export interface CreateGroupInviteRequest {
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof CreateGroupInviteRequest
     */
    'userId': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateGroupInviteRequest
     */
    'confirmOverrideBlock'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateGroupPostRequest
 */
export interface CreateGroupPostRequest {
    /**
     * Post title
     * @type {string}
     * @memberof CreateGroupPostRequest
     */
    'title': string;
    /**
     * Post text
     * @type {string}
     * @memberof CreateGroupPostRequest
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupPostRequest
     */
    'imageId'?: string;
    /**
     * Send notification to group members.
     * @type {boolean}
     * @memberof CreateGroupPostRequest
     */
    'sendNotification': boolean;
    /**
     *  
     * @type {Array<string>}
     * @memberof CreateGroupPostRequest
     */
    'roleIds'?: Array<string>;
    /**
     * 
     * @type {GroupPostVisibility}
     * @memberof CreateGroupPostRequest
     */
    'visibility': GroupPostVisibility;
}
/**
 * 
 * @export
 * @interface CreateGroupRequest
 */
export interface CreateGroupRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateGroupRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupRequest
     */
    'shortCode': string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupRequest
     */
    'description'?: string;
    /**
     * 
     * @type {GroupJoinState}
     * @memberof CreateGroupRequest
     */
    'joinState'?: GroupJoinState;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupRequest
     */
    'iconId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupRequest
     */
    'bannerId'?: string | null;
    /**
     * 
     * @type {GroupPrivacy}
     * @memberof CreateGroupRequest
     */
    'privacy'?: GroupPrivacy;
    /**
     * 
     * @type {GroupRoleTemplate}
     * @memberof CreateGroupRequest
     */
    'roleTemplate': GroupRoleTemplate;
}
/**
 * 
 * @export
 * @interface CreateGroupRoleRequest
 */
export interface CreateGroupRoleRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateGroupRoleRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupRoleRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupRoleRequest
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateGroupRoleRequest
     */
    'isSelfAssignable'?: boolean;
    /**
     * 
     * @type {Array<GroupPermissions>}
     * @memberof CreateGroupRoleRequest
     */
    'permissions'?: Array<GroupPermissions>;
}
/**
 * 
 * @export
 * @interface CreateInstanceRequest
 */
export interface CreateInstanceRequest {
    /**
     * WorldID be \"offline\" on User profiles if you are not friends with that user.
     * @type {string}
     * @memberof CreateInstanceRequest
     */
    'worldId': string;
    /**
     * 
     * @type {InstanceType}
     * @memberof CreateInstanceRequest
     */
    'type': InstanceType;
    /**
     * 
     * @type {InstanceRegion}
     * @memberof CreateInstanceRequest
     */
    'region': InstanceRegion;
    /**
     * A groupId if the instance type is \"group\", null if instance type is public, or a userId otherwise
     * @type {string}
     * @memberof CreateInstanceRequest
     */
    'ownerId'?: string | null;
    /**
     * Group roleIds that are allowed to join if the type is \"group\" and groupAccessType is \"member\"
     * @type {Array<string>}
     * @memberof CreateInstanceRequest
     */
    'roleIds'?: Array<string>;
    /**
     * 
     * @type {GroupAccessType}
     * @memberof CreateInstanceRequest
     */
    'groupAccessType'?: GroupAccessType;
    /**
     * 
     * @type {boolean}
     * @memberof CreateInstanceRequest
     */
    'queueEnabled'?: boolean;
    /**
     * The time after which users won\'t be allowed to join the instance. This doesn\'t work for public instances.
     * @type {string}
     * @memberof CreateInstanceRequest
     */
    'closedAt'?: string;
    /**
     * Only applies to invite type instances to make them invite+
     * @type {boolean}
     * @memberof CreateInstanceRequest
     */
    'canRequestInvite'?: boolean;
    /**
     * Currently unused, but will eventually be a flag to set if the closing of the instance should kick people.
     * @type {boolean}
     * @memberof CreateInstanceRequest
     */
    'hardClose'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateInstanceRequest
     */
    'inviteOnly'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateInstanceRequest
     */
    'ageGate'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateInstanceRequest
     */
    'instancePersistenceEnabled'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof CreateInstanceRequest
     */
    'displayName'?: string | null;
    /**
     * 
     * @type {InstanceContentSettings}
     * @memberof CreateInstanceRequest
     */
    'contentSettings'?: InstanceContentSettings;
}
/**
 * 
 * @export
 * @interface CreateWorldRequest
 */
export interface CreateWorldRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateWorldRequest
     */
    'assetUrl': string;
    /**
     * 
     * @type {number}
     * @memberof CreateWorldRequest
     */
    'assetVersion'?: number;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof CreateWorldRequest
     */
    'authorId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorldRequest
     */
    'authorName'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateWorldRequest
     */
    'capacity'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateWorldRequest
     */
    'description'?: string;
    /**
     * WorldID be \"offline\" on User profiles if you are not friends with that user.
     * @type {string}
     * @memberof CreateWorldRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorldRequest
     */
    'imageUrl': string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorldRequest
     */
    'name': string;
    /**
     * This can be `standalonewindows` or `android`, but can also pretty much be any random Unity verison such as `2019.2.4-801-Release` or `2019.2.2-772-Release` or even `unknownplatform`.
     * @type {string}
     * @memberof CreateWorldRequest
     */
    'platform'?: string;
    /**
     * 
     * @type {ReleaseStatus}
     * @memberof CreateWorldRequest
     */
    'releaseStatus'?: ReleaseStatus;
    /**
     *  
     * @type {Array<string>}
     * @memberof CreateWorldRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateWorldRequest
     */
    'unityPackageUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorldRequest
     */
    'unityVersion'?: string;
}
/**
 * 
 * @export
 * @interface CurrentUser
 */
export interface CurrentUser {
    /**
     * 
     * @type {number}
     * @memberof CurrentUser
     */
    'acceptedTOSVersion': number;
    /**
     * 
     * @type {number}
     * @memberof CurrentUser
     */
    'acceptedPrivacyVersion'?: number;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'accountDeletionDate'?: string | null;
    /**
     *  
     * @type {Array<AccountDeletionLog>}
     * @memberof CurrentUser
     */
    'accountDeletionLog'?: Array<AccountDeletionLog> | null;
    /**
     *  
     * @type {Array<string>}
     * @memberof CurrentUser
     */
    'activeFriends'?: Array<string>;
    /**
     * 
     * @type {AgeVerificationStatus}
     * @memberof CurrentUser
     */
    'ageVerificationStatus': AgeVerificationStatus;
    /**
     * `true` if, user is age verified (not 18+).
     * @type {boolean}
     * @memberof CurrentUser
     */
    'ageVerified': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CurrentUser
     */
    'allowAvatarCopying': boolean;
    /**
     * The auth token for NEWLY REGISTERED ACCOUNTS ONLY (/auth/register)
     * @type {string}
     * @memberof CurrentUser
     */
    'authToken'?: string;
    /**
     *  
     * @type {Array<Badge>}
     * @memberof CurrentUser
     */
    'badges'?: Array<Badge>;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'bio': string;
    /**
     *  
     * @type {Array<string>}
     * @memberof CurrentUser
     */
    'bioLinks': Array<string>;
    /**
     * These tags begin with `content_` and control content gating
     * @type {Array<string>}
     * @memberof CurrentUser
     */
    'contentFilters'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'currentAvatar': string;
    /**
     * When profilePicOverride is not empty, use it instead.
     * @type {string}
     * @memberof CurrentUser
     */
    'currentAvatarImageUrl': string;
    /**
     * When profilePicOverride is not empty, use it instead.
     * @type {string}
     * @memberof CurrentUser
     */
    'currentAvatarThumbnailImageUrl': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CurrentUser
     */
    'currentAvatarTags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'date_joined': string;
    /**
     * 
     * @type {DeveloperType}
     * @memberof CurrentUser
     */
    'developerType': DeveloperType;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'displayName': string;
    /**
     * 
     * @type {boolean}
     * @memberof CurrentUser
     */
    'emailVerified': boolean;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'fallbackAvatar'?: string;
    /**
     * Always empty array.
     * @type {Array<string>}
     * @memberof CurrentUser
     * @deprecated
     */
    'friendGroupNames': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'friendKey': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CurrentUser
     */
    'friends': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof CurrentUser
     */
    'hasBirthday': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CurrentUser
     */
    'hideContentFilterSettings'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'userLanguage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'userLanguageCode'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof CurrentUser
     */
    'hasEmail': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CurrentUser
     */
    'hasLoggedInFromClient': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CurrentUser
     */
    'hasPendingEmail': boolean;
    /**
     * WorldID be \"offline\" on User profiles if you are not friends with that user.
     * @type {string}
     * @memberof CurrentUser
     */
    'homeLocation': string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof CurrentUser
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof CurrentUser
     */
    'isAdult': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CurrentUser
     */
    'isBoopingEnabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CurrentUser
     */
    'isFriend': boolean;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'last_activity'?: string;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'last_login': string;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'last_mobile': string | null;
    /**
     * This can be `standalonewindows` or `android`, but can also pretty much be any random Unity verison such as `2019.2.4-801-Release` or `2019.2.2-772-Release` or even `unknownplatform`.
     * @type {string}
     * @memberof CurrentUser
     */
    'last_platform': string;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'obfuscatedEmail': string;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'obfuscatedPendingEmail': string;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'oculusId': string;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'googleId'?: string;
    /**
     * 
     * @type {object}
     * @memberof CurrentUser
     */
    'googleDetails'?: object;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'picoId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'viveId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CurrentUser
     */
    'offlineFriends'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CurrentUser
     */
    'onlineFriends'?: Array<string>;
    /**
     *  
     * @type {Array<PastDisplayName>}
     * @memberof CurrentUser
     */
    'pastDisplayNames': Array<PastDisplayName>;
    /**
     * 
     * @type {CurrentUserPresence}
     * @memberof CurrentUser
     */
    'presence'?: CurrentUserPresence;
    /**
     * 
     * @type {Array<CurrentUserPlatformHistoryInner>}
     * @memberof CurrentUser
     */
    'platform_history'?: Array<CurrentUserPlatformHistoryInner>;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'profilePicOverride': string;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'profilePicOverrideThumbnail': string;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'pronouns': string;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'queuedInstance'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof CurrentUser
     */
    'receiveMobileInvitations'?: boolean;
    /**
     * 
     * @type {UserState}
     * @memberof CurrentUser
     */
    'state': UserState;
    /**
     * 
     * @type {UserStatus}
     * @memberof CurrentUser
     */
    'status': UserStatus;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'statusDescription': string;
    /**
     * 
     * @type {boolean}
     * @memberof CurrentUser
     */
    'statusFirstTime': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof CurrentUser
     */
    'statusHistory': Array<string>;
    /**
     * 
     * @type {object}
     * @memberof CurrentUser
     */
    'steamDetails': object;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'steamId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CurrentUser
     */
    'tags': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof CurrentUser
     */
    'twoFactorAuthEnabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'twoFactorAuthEnabledDate'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof CurrentUser
     */
    'unsubscribe': boolean;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'userIcon': string;
    /**
     * -| **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
     * @type {string}
     * @memberof CurrentUser
     * @deprecated
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface CurrentUserPlatformHistoryInner
 */
export interface CurrentUserPlatformHistoryInner {
    /**
     * 
     * @type {boolean}
     * @memberof CurrentUserPlatformHistoryInner
     */
    'isMobile'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CurrentUserPlatformHistoryInner
     */
    'platform'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CurrentUserPlatformHistoryInner
     */
    'recorded'?: string;
}
/**
 * 
 * @export
 * @interface CurrentUserPresence
 */
export interface CurrentUserPresence {
    /**
     * 
     * @type {string}
     * @memberof CurrentUserPresence
     */
    'avatarThumbnail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CurrentUserPresence
     */
    'currentAvatarTags'?: string;
    /**
     * 
     * @type {string}
     * @memberof CurrentUserPresence
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CurrentUserPresence
     */
    'debugflag'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CurrentUserPresence
     */
    'groups'?: Array<string> | null;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof CurrentUserPresence
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CurrentUserPresence
     */
    'instance'?: string | null;
    /**
     * either an InstanceType or an empty string
     * @type {string}
     * @memberof CurrentUserPresence
     */
    'instanceType'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CurrentUserPresence
     */
    'isRejoining'?: string | null;
    /**
     * either a Platform or an empty string
     * @type {string}
     * @memberof CurrentUserPresence
     */
    'platform'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CurrentUserPresence
     */
    'profilePicOverride'?: string | null;
    /**
     * either a UserStatus or empty string
     * @type {string}
     * @memberof CurrentUserPresence
     */
    'status'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CurrentUserPresence
     */
    'travelingToInstance'?: string | null;
    /**
     * WorldID be \"offline\" on User profiles if you are not friends with that user.
     * @type {string}
     * @memberof CurrentUserPresence
     */
    'travelingToWorld'?: string;
    /**
     * 
     * @type {string}
     * @memberof CurrentUserPresence
     */
    'userIcon'?: string | null;
    /**
     * WorldID be \"offline\" on User profiles if you are not friends with that user.
     * @type {string}
     * @memberof CurrentUserPresence
     */
    'world'?: string;
}
/**
 * \"none\" User is a normal user \"trusted\" Unknown \"internal\" Is a VRChat Developer \"moderator\" Is a VRChat Moderator  Staff can hide their developerType at will.
 * @export
 * @enum {string}
 */

export const DeveloperType = {
    None: 'none',
    Trusted: 'trusted',
    Internal: 'internal',
    Moderator: 'moderator'
} as const;

export type DeveloperType = typeof DeveloperType[keyof typeof DeveloperType];


/**
 * 
 * @export
 * @interface Disable2FAResult
 */
export interface Disable2FAResult {
    /**
     * 
     * @type {boolean}
     * @memberof Disable2FAResult
     */
    'removed': boolean;
}
/**
 * 
 * @export
 * @interface DynamicContentRow
 */
export interface DynamicContentRow {
    /**
     * 
     * @type {number}
     * @memberof DynamicContentRow
     */
    'index'?: number;
    /**
     * 
     * @type {string}
     * @memberof DynamicContentRow
     */
    'name': string;
    /**
     * Usually \"ThisPlatformSupported\", but can also be other values such as \"all\" or platform specific identifiers.
     * @type {string}
     * @memberof DynamicContentRow
     */
    'platform': string;
    /**
     * 
     * @type {string}
     * @memberof DynamicContentRow
     */
    'sortHeading': string;
    /**
     * 
     * @type {string}
     * @memberof DynamicContentRow
     */
    'sortOrder': string;
    /**
     * 
     * @type {string}
     * @memberof DynamicContentRow
     */
    'sortOwnership': string;
    /**
     * Tag to filter content for this row.
     * @type {string}
     * @memberof DynamicContentRow
     */
    'tag'?: string;
    /**
     * Type is not present if it is a world.
     * @type {string}
     * @memberof DynamicContentRow
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface Favorite
 */
export interface Favorite {
    /**
     * MUST be either AvatarID, UserID or WorldID.
     * @type {string}
     * @memberof Favorite
     */
    'favoriteId': string;
    /**
     * 
     * @type {string}
     * @memberof Favorite
     */
    'id': string;
    /**
     *  
     * @type {Array<string>}
     * @memberof Favorite
     */
    'tags': Array<string>;
    /**
     * 
     * @type {FavoriteType}
     * @memberof Favorite
     */
    'type': FavoriteType;
}
/**
 * 
 * @export
 * @interface FavoriteGroup
 */
export interface FavoriteGroup {
    /**
     * 
     * @type {string}
     * @memberof FavoriteGroup
     */
    'displayName': string;
    /**
     * 
     * @type {string}
     * @memberof FavoriteGroup
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FavoriteGroup
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof FavoriteGroup
     */
    'ownerDisplayName': string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof FavoriteGroup
     */
    'ownerId': string;
    /**
     *  
     * @type {Array<string>}
     * @memberof FavoriteGroup
     */
    'tags': Array<string>;
    /**
     * 
     * @type {FavoriteType}
     * @memberof FavoriteGroup
     */
    'type': FavoriteType;
    /**
     * 
     * @type {FavoriteGroupVisibility}
     * @memberof FavoriteGroup
     */
    'visibility': FavoriteGroupVisibility;
}
/**
 * 
 * @export
 * @interface FavoriteGroupLimits
 */
export interface FavoriteGroupLimits {
    /**
     * 
     * @type {number}
     * @memberof FavoriteGroupLimits
     */
    'avatar': number;
    /**
     * 
     * @type {number}
     * @memberof FavoriteGroupLimits
     */
    'friend': number;
    /**
     * 
     * @type {number}
     * @memberof FavoriteGroupLimits
     */
    'world': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const FavoriteGroupVisibility = {
    Private: 'private',
    Friends: 'friends',
    Public: 'public'
} as const;

export type FavoriteGroupVisibility = typeof FavoriteGroupVisibility[keyof typeof FavoriteGroupVisibility];


/**
 * 
 * @export
 * @interface FavoriteLimits
 */
export interface FavoriteLimits {
    /**
     * 
     * @type {number}
     * @memberof FavoriteLimits
     */
    'defaultMaxFavoriteGroups': number;
    /**
     * 
     * @type {number}
     * @memberof FavoriteLimits
     */
    'defaultMaxFavoritesPerGroup': number;
    /**
     * 
     * @type {FavoriteGroupLimits}
     * @memberof FavoriteLimits
     */
    'maxFavoriteGroups': FavoriteGroupLimits;
    /**
     * 
     * @type {FavoriteGroupLimits}
     * @memberof FavoriteLimits
     */
    'maxFavoritesPerGroup': FavoriteGroupLimits;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const FavoriteType = {
    World: 'world',
    Friend: 'friend',
    Avatar: 'avatar'
} as const;

export type FavoriteType = typeof FavoriteType[keyof typeof FavoriteType];


/**
 * 
 * @export
 * @interface FavoritedWorld
 */
export interface FavoritedWorld {
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof FavoritedWorld
     */
    'authorId': string;
    /**
     * 
     * @type {string}
     * @memberof FavoritedWorld
     */
    'authorName': string;
    /**
     * 
     * @type {number}
     * @memberof FavoritedWorld
     */
    'capacity': number;
    /**
     * 
     * @type {string}
     * @memberof FavoritedWorld
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof FavoritedWorld
     */
    'recommendedCapacity'?: number;
    /**
     * 
     * @type {string}
     * @memberof FavoritedWorld
     */
    'created_at': string;
    /**
     * 
     * @type {InstanceContentSettings}
     * @memberof FavoritedWorld
     */
    'defaultContentSettings'?: InstanceContentSettings;
    /**
     * 
     * @type {number}
     * @memberof FavoritedWorld
     */
    'favorites': number;
    /**
     * 
     * @type {string}
     * @memberof FavoritedWorld
     */
    'favoriteGroup': string;
    /**
     * 
     * @type {string}
     * @memberof FavoritedWorld
     */
    'favoriteId': string;
    /**
     * 
     * @type {boolean}
     * @memberof FavoritedWorld
     */
    'featured': boolean;
    /**
     * 
     * @type {number}
     * @memberof FavoritedWorld
     */
    'visits'?: number;
    /**
     * 
     * @type {number}
     * @memberof FavoritedWorld
     */
    'heat': number;
    /**
     * WorldID be \"offline\" on User profiles if you are not friends with that user.
     * @type {string}
     * @memberof FavoritedWorld
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FavoritedWorld
     */
    'imageUrl': string;
    /**
     * 
     * @type {string}
     * @memberof FavoritedWorld
     */
    'labsPublicationDate': string;
    /**
     * 
     * @type {string}
     * @memberof FavoritedWorld
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof FavoritedWorld
     */
    'occupants': number;
    /**
     * 
     * @type {string}
     * @memberof FavoritedWorld
     */
    'organization': string;
    /**
     * 
     * @type {number}
     * @memberof FavoritedWorld
     */
    'popularity': number;
    /**
     * 
     * @type {string}
     * @memberof FavoritedWorld
     */
    'previewYoutubeId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FavoritedWorld
     */
    'publicationDate': string;
    /**
     * 
     * @type {ReleaseStatus}
     * @memberof FavoritedWorld
     */
    'releaseStatus': ReleaseStatus;
    /**
     *  
     * @type {Array<string>}
     * @memberof FavoritedWorld
     */
    'tags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof FavoritedWorld
     */
    'thumbnailImageUrl': string;
    /**
     *  
     * @type {Array<UnityPackage>}
     * @memberof FavoritedWorld
     */
    'unityPackages': Array<UnityPackage>;
    /**
     * 
     * @type {string}
     * @memberof FavoritedWorld
     */
    'updated_at': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof FavoritedWorld
     */
    'urlList': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FavoritedWorld
     */
    'udonProducts'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof FavoritedWorld
     */
    'version': number;
}
/**
 * 
 * @export
 * @interface Feedback
 */
export interface Feedback {
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof Feedback
     */
    'commenterId': string;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    'commenterName': string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof Feedback
     */
    'contentAuthorId': string;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    'contentAuthorName': string | null;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    'contentId': string;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    'contentName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    'contentType': string;
    /**
     * 
     * @type {number}
     * @memberof Feedback
     */
    'contentVersion': number | null;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    'reason': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Feedback
     */
    'tags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface FileAnalysis
 */
export interface FileAnalysis {
    /**
     * 
     * @type {FileAnalysisAvatarStats}
     * @memberof FileAnalysis
     */
    'avatarStats': FileAnalysisAvatarStats;
    /**
     * 
     * @type {string}
     * @memberof FileAnalysis
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileAnalysis
     */
    'encryptionKey'?: string;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysis
     */
    'fileSize': number;
    /**
     * 
     * @type {string}
     * @memberof FileAnalysis
     */
    'performanceRating'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FileAnalysis
     */
    'success': boolean;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysis
     */
    'uncompressedSize': number;
}
/**
 * 
 * @export
 * @interface FileAnalysisAvatarStats
 */
export interface FileAnalysisAvatarStats {
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'animatorCount': number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'audioSourceCount': number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'blendShapeCount': number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'boneCount': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof FileAnalysisAvatarStats
     */
    'bounds': Array<number>;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'cameraCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'clothCount': number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'constraintCount': number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'contactCount': number;
    /**
     * 
     * @type {boolean}
     * @memberof FileAnalysisAvatarStats
     */
    'customExpressions': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileAnalysisAvatarStats
     */
    'customizeAnimationLayers': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileAnalysisAvatarStats
     */
    'enableEyeLook': boolean;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'lightCount': number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'lineRendererCount': number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'lipSync': number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'materialCount': number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'materialSlotsUsed': number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'meshCount': number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'meshIndices': number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'meshParticleMaxPolygons': number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'meshPolygons': number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'meshVertices': number;
    /**
     * 
     * @type {boolean}
     * @memberof FileAnalysisAvatarStats
     */
    'particleCollisionEnabled': boolean;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'particleSystemCount': number;
    /**
     * 
     * @type {boolean}
     * @memberof FileAnalysisAvatarStats
     */
    'particleTrailsEnabled': boolean;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'physBoneColliderCount': number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'physBoneCollisionCheckCount': number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'physBoneComponentCount': number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'physBoneTransformCount': number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'physicsColliders': number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'physicsRigidbodies': number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'skinnedMeshCount': number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'skinnedMeshIndices': number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'skinnedMeshPolygons': number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'skinnedMeshVertices': number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'totalClothVertices': number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'totalIndices': number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'totalMaxParticles': number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'totalPolygons': number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'totalTextureUsage': number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'totalVertices': number;
    /**
     * 
     * @type {number}
     * @memberof FileAnalysisAvatarStats
     */
    'trailRendererCount': number;
    /**
     * 
     * @type {boolean}
     * @memberof FileAnalysisAvatarStats
     */
    'writeDefaultsUsed': boolean;
}
/**
 * 
 * @export
 * @interface FileData
 */
export interface FileData {
    /**
     * 
     * @type {string}
     * @memberof FileData
     */
    'category': FileDataCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof FileData
     */
    'fileName': string;
    /**
     * 
     * @type {string}
     * @memberof FileData
     */
    'md5'?: string;
    /**
     * 
     * @type {number}
     * @memberof FileData
     */
    'sizeInBytes': number;
    /**
     * 
     * @type {FileStatus}
     * @memberof FileData
     */
    'status': FileStatus;
    /**
     * 
     * @type {string}
     * @memberof FileData
     */
    'uploadId': string;
    /**
     * 
     * @type {string}
     * @memberof FileData
     */
    'url': string;
}

export const FileDataCategoryEnum = {
    Multipart: 'multipart',
    Queued: 'queued',
    Simple: 'simple'
} as const;

export type FileDataCategoryEnum = typeof FileDataCategoryEnum[keyof typeof FileDataCategoryEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const FileStatus = {
    Waiting: 'waiting',
    Complete: 'complete',
    None: 'none',
    Queued: 'queued'
} as const;

export type FileStatus = typeof FileStatus[keyof typeof FileStatus];


/**
 * 
 * @export
 * @interface FileUploadURL
 */
export interface FileUploadURL {
    /**
     * 
     * @type {string}
     * @memberof FileUploadURL
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface FileVersion
 */
export interface FileVersion {
    /**
     * 
     * @type {string}
     * @memberof FileVersion
     */
    'created_at': string;
    /**
     * Usually only present if `true`
     * @type {boolean}
     * @memberof FileVersion
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {FileData}
     * @memberof FileVersion
     */
    'delta'?: FileData;
    /**
     * 
     * @type {FileData}
     * @memberof FileVersion
     */
    'file'?: FileData;
    /**
     * 
     * @type {FileData}
     * @memberof FileVersion
     */
    'signature'?: FileData;
    /**
     * 
     * @type {FileStatus}
     * @memberof FileVersion
     */
    'status': FileStatus;
    /**
     * Incremental version counter, can only be increased.
     * @type {number}
     * @memberof FileVersion
     */
    'version': number;
}
/**
 * 
 * @export
 * @interface FileVersionUploadStatus
 */
export interface FileVersionUploadStatus {
    /**
     * 
     * @type {string}
     * @memberof FileVersionUploadStatus
     */
    'uploadId': string;
    /**
     * 
     * @type {string}
     * @memberof FileVersionUploadStatus
     */
    'fileName': string;
    /**
     * 
     * @type {number}
     * @memberof FileVersionUploadStatus
     */
    'nextPartNumber': number;
    /**
     * 
     * @type {number}
     * @memberof FileVersionUploadStatus
     */
    'maxParts': number;
    /**
     * 
     * @type {Array<object>}
     * @memberof FileVersionUploadStatus
     */
    'parts': Array<object>;
    /**
     * Unknown
     * @type {Array<object>}
     * @memberof FileVersionUploadStatus
     */
    'etags': Array<object>;
}
/**
 * 
 * @export
 * @interface FinishFileDataUploadRequest
 */
export interface FinishFileDataUploadRequest {
    /**
     * Array of ETags uploaded.
     * @type {Set<string>}
     * @memberof FinishFileDataUploadRequest
     */
    'etags'?: Set<string>;
    /**
     * Always a zero in string form, despite how many parts uploaded.
     * @type {string}
     * @memberof FinishFileDataUploadRequest
     * @deprecated
     */
    'nextPartNumber': string;
    /**
     * Always a zero in string form, despite how many parts uploaded.
     * @type {string}
     * @memberof FinishFileDataUploadRequest
     * @deprecated
     */
    'maxParts': string;
}
/**
 * 
 * @export
 * @interface FriendStatus
 */
export interface FriendStatus {
    /**
     * 
     * @type {boolean}
     * @memberof FriendStatus
     */
    'incomingRequest': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FriendStatus
     */
    'isFriend': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FriendStatus
     */
    'outgoingRequest': boolean;
}
/**
 * 
 * @export
 * @interface GetGroupPosts200Response
 */
export interface GetGroupPosts200Response {
    /**
     * 
     * @type {Array<GroupPost>}
     * @memberof GetGroupPosts200Response
     */
    'posts'?: Array<GroupPost>;
}
/**
 * 
 * @export
 * @interface GetUserGroupInstances200Response
 */
export interface GetUserGroupInstances200Response {
    /**
     * 
     * @type {string}
     * @memberof GetUserGroupInstances200Response
     */
    'fetchedAt'?: string;
    /**
     * 
     * @type {Array<Instance>}
     * @memberof GetUserGroupInstances200Response
     */
    'instances'?: Array<Instance>;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {boolean}
     * @memberof Group
     */
    'ageVerificationSlotsAvailable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'ageVerificationBetaCode'?: string;
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    'ageVerificationBetaSlots'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Group
     */
    'badges'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'shortCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'discriminator'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'iconUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'bannerUrl'?: string | null;
    /**
     * 
     * @type {GroupPrivacy}
     * @memberof Group
     */
    'privacy'?: GroupPrivacy;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof Group
     */
    'ownerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'rules'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Group
     */
    'links'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Group
     */
    'languages'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'iconId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'bannerId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    'memberCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'memberCountSyncedAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Group
     */
    'isVerified'?: boolean;
    /**
     * 
     * @type {GroupJoinState}
     * @memberof Group
     */
    'joinState'?: GroupJoinState;
    /**
     * 
     * @type {Array<string>}
     * @memberof Group
     */
    'tags'?: Array<string>;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof Group
     */
    'transferTargetId'?: string;
    /**
     * 
     * @type {Array<GroupGallery>}
     * @memberof Group
     */
    'galleries'?: Array<GroupGallery>;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'lastPostCreatedAt'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    'onlineMemberCount'?: number;
    /**
     * 
     * @type {GroupMemberStatus}
     * @memberof Group
     */
    'membershipStatus'?: GroupMemberStatus;
    /**
     * 
     * @type {GroupMyMember}
     * @memberof Group
     */
    'myMember'?: GroupMyMember;
    /**
     * Only returned if ?includeRoles=true is specified.
     * @type {Array<GroupRole>}
     * @memberof Group
     */
    'roles'?: Array<GroupRole> | null;
}
/**
 * Group access type when the instance type is \"group\"
 * @export
 * @enum {string}
 */

export const GroupAccessType = {
    Public: 'public',
    Plus: 'plus',
    Members: 'members'
} as const;

export type GroupAccessType = typeof GroupAccessType[keyof typeof GroupAccessType];


/**
 * 
 * @export
 * @interface GroupAnnouncement
 */
export interface GroupAnnouncement {
    /**
     * 
     * @type {string}
     * @memberof GroupAnnouncement
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupAnnouncement
     */
    'groupId'?: string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof GroupAnnouncement
     */
    'authorId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupAnnouncement
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GroupAnnouncement
     */
    'text'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GroupAnnouncement
     */
    'imageId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupAnnouncement
     */
    'imageUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GroupAnnouncement
     */
    'createdAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GroupAnnouncement
     */
    'updatedAt'?: string | null;
}
/**
 * 
 * @export
 * @interface GroupAuditLogEntry
 */
export interface GroupAuditLogEntry {
    /**
     * 
     * @type {string}
     * @memberof GroupAuditLogEntry
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupAuditLogEntry
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupAuditLogEntry
     */
    'groupId'?: string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof GroupAuditLogEntry
     */
    'actorId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupAuditLogEntry
     */
    'actorDisplayName'?: string;
    /**
     * Typically a UserID, GroupID, GroupRoleID, or Location, but could be other types of IDs.
     * @type {string}
     * @memberof GroupAuditLogEntry
     */
    'targetId'?: string;
    /**
     * The type of event that occurred. This is a string that is prefixed with the type of object that the event occurred on. For example, a group role update event would be prefixed with `group.role`.
     * @type {string}
     * @memberof GroupAuditLogEntry
     */
    'eventType'?: string;
    /**
     * A human-readable description of the event.
     * @type {string}
     * @memberof GroupAuditLogEntry
     */
    'description'?: string;
    /**
     * The data associated with the event. The format of this data is dependent on the event type.
     * @type {object}
     * @memberof GroupAuditLogEntry
     */
    'data'?: object;
}
/**
 * 
 * @export
 * @interface GroupGallery
 */
export interface GroupGallery {
    /**
     * 
     * @type {string}
     * @memberof GroupGallery
     */
    'id'?: string;
    /**
     * Name of the gallery.
     * @type {string}
     * @memberof GroupGallery
     */
    'name'?: string;
    /**
     * Description of the gallery.
     * @type {string}
     * @memberof GroupGallery
     */
    'description'?: string;
    /**
     * Whether the gallery is members only.
     * @type {boolean}
     * @memberof GroupGallery
     */
    'membersOnly'?: boolean;
    /**
     *  
     * @type {Array<string>}
     * @memberof GroupGallery
     */
    'roleIdsToView'?: Array<string> | null;
    /**
     *  
     * @type {Array<string>}
     * @memberof GroupGallery
     */
    'roleIdsToSubmit'?: Array<string> | null;
    /**
     *  
     * @type {Array<string>}
     * @memberof GroupGallery
     */
    'roleIdsToAutoApprove'?: Array<string> | null;
    /**
     *  
     * @type {Array<string>}
     * @memberof GroupGallery
     */
    'roleIdsToManage'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof GroupGallery
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupGallery
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface GroupGalleryImage
 */
export interface GroupGalleryImage {
    /**
     * 
     * @type {string}
     * @memberof GroupGalleryImage
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupGalleryImage
     */
    'groupId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupGalleryImage
     */
    'galleryId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupGalleryImage
     */
    'fileId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupGalleryImage
     */
    'imageUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupGalleryImage
     */
    'createdAt'?: string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof GroupGalleryImage
     */
    'submittedByUserId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GroupGalleryImage
     */
    'approved'?: boolean;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof GroupGalleryImage
     */
    'approvedByUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupGalleryImage
     */
    'approvedAt'?: string;
}
/**
 * 
 * @export
 * @interface GroupInstance
 */
export interface GroupInstance {
    /**
     * 
     * @type {string}
     * @memberof GroupInstance
     */
    'instanceId': string;
    /**
     * InstanceID can be \"offline\" on User profiles if you are not friends with that user and \"private\" if you are friends and user is in private instance.
     * @type {string}
     * @memberof GroupInstance
     */
    'location': string;
    /**
     * 
     * @type {World}
     * @memberof GroupInstance
     */
    'world': World;
    /**
     * 
     * @type {number}
     * @memberof GroupInstance
     */
    'memberCount': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const GroupJoinRequestAction = {
    Accept: 'accept',
    Reject: 'reject'
} as const;

export type GroupJoinRequestAction = typeof GroupJoinRequestAction[keyof typeof GroupJoinRequestAction];


/**
 * 
 * @export
 * @enum {string}
 */

export const GroupJoinState = {
    Closed: 'closed',
    Invite: 'invite',
    Request: 'request',
    Open: 'open'
} as const;

export type GroupJoinState = typeof GroupJoinState[keyof typeof GroupJoinState];


/**
 * 
 * @export
 * @interface GroupLimitedMember
 */
export interface GroupLimitedMember {
    /**
     * 
     * @type {string}
     * @memberof GroupLimitedMember
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupLimitedMember
     */
    'groupId'?: string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof GroupLimitedMember
     */
    'userId'?: string;
    /**
     * Whether the user is representing the group. This makes the group show up above the name tag in-game.
     * @type {boolean}
     * @memberof GroupLimitedMember
     */
    'isRepresenting'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupLimitedMember
     */
    'roleIds'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupLimitedMember
     */
    'mRoleIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GroupLimitedMember
     */
    'joinedAt'?: string | null;
    /**
     * 
     * @type {GroupMemberStatus}
     * @memberof GroupLimitedMember
     */
    'membershipStatus'?: GroupMemberStatus;
    /**
     * 
     * @type {string}
     * @memberof GroupLimitedMember
     */
    'visibility'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GroupLimitedMember
     */
    'isSubscribedToAnnouncements'?: boolean;
    /**
     * Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
     * @type {string}
     * @memberof GroupLimitedMember
     */
    'createdAt'?: string | null;
    /**
     * Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
     * @type {string}
     * @memberof GroupLimitedMember
     */
    'bannedAt'?: string | null;
    /**
     * Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
     * @type {string}
     * @memberof GroupLimitedMember
     */
    'managerNotes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GroupLimitedMember
     */
    'lastPostReadAt'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GroupLimitedMember
     */
    'hasJoinedFromPurchase'?: boolean;
}
/**
 * 
 * @export
 * @interface GroupMember
 */
export interface GroupMember {
    /**
     * 
     * @type {string}
     * @memberof GroupMember
     */
    'acceptedByDisplayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GroupMember
     */
    'acceptedById'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GroupMember
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupMember
     */
    'groupId'?: string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof GroupMember
     */
    'userId'?: string;
    /**
     * Whether the user is representing the group. This makes the group show up above the name tag in-game.
     * @type {boolean}
     * @memberof GroupMember
     */
    'isRepresenting'?: boolean;
    /**
     * 
     * @type {GroupMemberLimitedUser}
     * @memberof GroupMember
     */
    'user'?: GroupMemberLimitedUser;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupMember
     */
    'roleIds'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupMember
     */
    'mRoleIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GroupMember
     */
    'joinedAt'?: string | null;
    /**
     * 
     * @type {GroupMemberStatus}
     * @memberof GroupMember
     */
    'membershipStatus'?: GroupMemberStatus;
    /**
     * 
     * @type {string}
     * @memberof GroupMember
     */
    'visibility'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GroupMember
     */
    'isSubscribedToAnnouncements'?: boolean;
    /**
     * Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
     * @type {string}
     * @memberof GroupMember
     */
    'createdAt'?: string | null;
    /**
     * Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
     * @type {string}
     * @memberof GroupMember
     */
    'bannedAt'?: string | null;
    /**
     * Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
     * @type {string}
     * @memberof GroupMember
     */
    'managerNotes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GroupMember
     */
    'lastPostReadAt'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GroupMember
     */
    'hasJoinedFromPurchase'?: boolean;
}
/**
 * Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
 * @export
 * @interface GroupMemberLimitedUser
 */
export interface GroupMemberLimitedUser {
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof GroupMemberLimitedUser
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupMemberLimitedUser
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupMemberLimitedUser
     */
    'thumbnailUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GroupMemberLimitedUser
     */
    'iconUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupMemberLimitedUser
     */
    'profilePicOverride'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupMemberLimitedUser
     */
    'currentAvatarThumbnailImageUrl'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupMemberLimitedUser
     */
    'currentAvatarTags'?: Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const GroupMemberStatus = {
    Inactive: 'inactive',
    Member: 'member',
    Requested: 'requested',
    Invited: 'invited',
    Banned: 'banned',
    Userblocked: 'userblocked'
} as const;

export type GroupMemberStatus = typeof GroupMemberStatus[keyof typeof GroupMemberStatus];


/**
 * 
 * @export
 * @interface GroupMyMember
 */
export interface GroupMyMember {
    /**
     * 
     * @type {string}
     * @memberof GroupMyMember
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupMyMember
     */
    'groupId'?: string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof GroupMyMember
     */
    'userId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupMyMember
     */
    'roleIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GroupMyMember
     */
    'acceptedByDisplayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GroupMyMember
     */
    'acceptedById'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GroupMyMember
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupMyMember
     */
    'managerNotes'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupMyMember
     */
    'membershipStatus'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GroupMyMember
     */
    'isSubscribedToAnnouncements'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GroupMyMember
     */
    'visibility'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GroupMyMember
     */
    'isRepresenting'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GroupMyMember
     */
    'joinedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupMyMember
     */
    'bannedAt'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GroupMyMember
     */
    'has2FA'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GroupMyMember
     */
    'hasJoinedFromPurchase'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GroupMyMember
     */
    'lastPostReadAt'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupMyMember
     */
    'mRoleIds'?: Array<string>;
    /**
     * 
     * @type {Array<GroupPermissions>}
     * @memberof GroupMyMember
     */
    'permissions'?: Array<GroupPermissions>;
}
/**
 * A permission that can be granted to a role in a group.
 * @export
 * @interface GroupPermission
 */
export interface GroupPermission {
    /**
     * The name of the permission.
     * @type {string}
     * @memberof GroupPermission
     */
    'name'?: string;
    /**
     * The display name of the permission.
     * @type {string}
     * @memberof GroupPermission
     */
    'displayName'?: string;
    /**
     * Human-readable description of the permission.
     * @type {string}
     * @memberof GroupPermission
     */
    'help'?: string;
    /**
     * Whether this permission is a \"management\" permission.
     * @type {boolean}
     * @memberof GroupPermission
     */
    'isManagementPermission'?: boolean;
    /**
     * Whether the user is allowed to add this permission to a role.
     * @type {boolean}
     * @memberof GroupPermission
     */
    'allowedToAdd'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const GroupPermissions = {
    group_all: '*',
    group_announcement_manage: 'group-announcement-manage',
    group_audit_view: 'group-audit-view',
    group_bans_manage: 'group-bans-manage',
    group_data_manage: 'group-data-manage',
    group_default_role_manage: 'group-default-role-manage',
    group_galleries_manage: 'group-galleries-manage',
    group_instance_age_gated_create: 'group-instance-age-gated-create',
    group_instance_join: 'group-instance-join',
    group_instance_manage: 'group-instance-manage',
    group_instance_moderate: 'group-instance-moderate',
    group_instance_open_create: 'group-instance-open-create',
    group_instance_plus_create: 'group-instance-plus-create',
    group_instance_plus_portal: 'group-instance-plus-portal',
    group_instance_plus_portal_unlocked: 'group-instance-plus-portal-unlocked',
    group_instance_public_create: 'group-instance-public-create',
    group_instance_queue_priority: 'group-instance-queue-priority',
    group_instance_restricted_create: 'group-instance-restricted-create',
    group_invites_manage: 'group-invites-manage',
    group_members_manage: 'group-members-manage',
    group_members_remove: 'group-members-remove',
    group_members_viewall: 'group-members-viewall',
    group_roles_assign: 'group-roles-assign',
    group_roles_manage: 'group-roles-manage'
} as const;

export type GroupPermissions = typeof GroupPermissions[keyof typeof GroupPermissions];


/**
 * 
 * @export
 * @interface GroupPost
 */
export interface GroupPost {
    /**
     * 
     * @type {string}
     * @memberof GroupPost
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupPost
     */
    'groupId'?: string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof GroupPost
     */
    'authorId'?: string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof GroupPost
     */
    'editorId'?: string;
    /**
     * 
     * @type {GroupPostVisibility}
     * @memberof GroupPost
     */
    'visibility'?: GroupPostVisibility;
    /**
     *  
     * @type {Array<string>}
     * @memberof GroupPost
     */
    'roleId'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GroupPost
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupPost
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupPost
     */
    'imageId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupPost
     */
    'imageUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GroupPost
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupPost
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const GroupPostVisibility = {
    Group: 'group',
    Public: 'public'
} as const;

export type GroupPostVisibility = typeof GroupPostVisibility[keyof typeof GroupPostVisibility];


/**
 * 
 * @export
 * @enum {string}
 */

export const GroupPrivacy = {
    Default: 'default',
    Private: 'private'
} as const;

export type GroupPrivacy = typeof GroupPrivacy[keyof typeof GroupPrivacy];


/**
 * 
 * @export
 * @interface GroupRole
 */
export interface GroupRole {
    /**
     * 
     * @type {string}
     * @memberof GroupRole
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupRole
     */
    'groupId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupRole
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupRole
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GroupRole
     */
    'isSelfAssignable'?: boolean;
    /**
     * 
     * @type {Array<GroupPermissions>}
     * @memberof GroupRole
     */
    'permissions'?: Array<GroupPermissions>;
    /**
     * 
     * @type {boolean}
     * @memberof GroupRole
     */
    'isManagementRole'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GroupRole
     */
    'requiresTwoFactor'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GroupRole
     */
    'requiresPurchase'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof GroupRole
     */
    'order'?: number;
    /**
     * 
     * @type {string}
     * @memberof GroupRole
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupRole
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const GroupRoleTemplate = {
    Default: 'default',
    ManagedFree: 'managedFree',
    ManagedInvite: 'managedInvite',
    ManagedRequest: 'managedRequest'
} as const;

export type GroupRoleTemplate = typeof GroupRoleTemplate[keyof typeof GroupRoleTemplate];


/**
 * 
 * @export
 * @interface GroupRoleTemplateValues
 */
export interface GroupRoleTemplateValues {
    /**
     * 
     * @type {Array<GroupPermissions>}
     * @memberof GroupRoleTemplateValues
     */
    'basePermissions': Array<GroupPermissions>;
    /**
     * 
     * @type {string}
     * @memberof GroupRoleTemplateValues
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof GroupRoleTemplateValues
     */
    'name': string;
    /**
     * 
     * @type {GroupRoleTemplateValuesRoles}
     * @memberof GroupRoleTemplateValues
     */
    'roles': GroupRoleTemplateValuesRoles;
}
/**
 * 
 * @export
 * @interface GroupRoleTemplateValuesRoles
 */
export interface GroupRoleTemplateValuesRoles {
    /**
     * 
     * @type {string}
     * @memberof GroupRoleTemplateValuesRoles
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupRoleTemplateValuesRoles
     */
    'name'?: string;
    /**
     * 
     * @type {Array<GroupPermissions>}
     * @memberof GroupRoleTemplateValuesRoles
     */
    'basePermissions'?: Array<GroupPermissions>;
    /**
     * 
     * @type {boolean}
     * @memberof GroupRoleTemplateValuesRoles
     */
    'isAddedOnJoin'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const GroupSearchSort = {
    Asc: 'joinedAt:asc',
    Desc: 'joinedAt:desc'
} as const;

export type GroupSearchSort = typeof GroupSearchSort[keyof typeof GroupSearchSort];


/**
 * 
 * @export
 * @enum {string}
 */

export const GroupUserVisibility = {
    Visible: 'visible',
    Hidden: 'hidden',
    Friends: 'friends'
} as const;

export type GroupUserVisibility = typeof GroupUserVisibility[keyof typeof GroupUserVisibility];


/**
 * 
 * @export
 * @interface InfoPush
 */
export interface InfoPush {
    /**
     * 
     * @type {string}
     * @memberof InfoPush
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof InfoPush
     */
    'isEnabled': boolean;
    /**
     * 
     * @type {ReleaseStatus}
     * @memberof InfoPush
     */
    'releaseStatus': ReleaseStatus;
    /**
     * 
     * @type {number}
     * @memberof InfoPush
     */
    'priority': number;
    /**
     *  
     * @type {Array<string>}
     * @memberof InfoPush
     */
    'tags': Array<string>;
    /**
     * 
     * @type {InfoPushData}
     * @memberof InfoPush
     */
    'data': InfoPushData;
    /**
     * Unknown usage, MD5
     * @type {string}
     * @memberof InfoPush
     */
    'hash': string;
    /**
     * 
     * @type {string}
     * @memberof InfoPush
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof InfoPush
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof InfoPush
     */
    'startDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof InfoPush
     */
    'endDate'?: string;
}
/**
 * 
 * @export
 * @interface InfoPushData
 */
export interface InfoPushData {
    /**
     * 
     * @type {DynamicContentRow}
     * @memberof InfoPushData
     */
    'contentList'?: DynamicContentRow;
    /**
     * 
     * @type {string}
     * @memberof InfoPushData
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof InfoPushData
     */
    'imageUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof InfoPushData
     */
    'name'?: string;
    /**
     * 
     * @type {InfoPushDataClickable}
     * @memberof InfoPushData
     */
    'onPressed'?: InfoPushDataClickable;
    /**
     * 
     * @type {string}
     * @memberof InfoPushData
     */
    'template'?: string;
    /**
     * 
     * @type {string}
     * @memberof InfoPushData
     */
    'version'?: string;
    /**
     * 
     * @type {InfoPushDataArticle}
     * @memberof InfoPushData
     */
    'article'?: InfoPushDataArticle;
}
/**
 * 
 * @export
 * @interface InfoPushDataArticle
 */
export interface InfoPushDataArticle {
    /**
     * 
     * @type {InfoPushDataArticleContent}
     * @memberof InfoPushDataArticle
     */
    'content'?: InfoPushDataArticleContent;
}
/**
 * 
 * @export
 * @interface InfoPushDataArticleContent
 */
export interface InfoPushDataArticleContent {
    /**
     * 
     * @type {string}
     * @memberof InfoPushDataArticleContent
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof InfoPushDataArticleContent
     */
    'imageUrl'?: string;
    /**
     * 
     * @type {InfoPushDataClickable}
     * @memberof InfoPushDataArticleContent
     */
    'onPressed'?: InfoPushDataClickable;
}
/**
 * 
 * @export
 * @interface InfoPushDataClickable
 */
export interface InfoPushDataClickable {
    /**
     * 
     * @type {string}
     * @memberof InfoPushDataClickable
     */
    'command': InfoPushDataClickableCommandEnum;
    /**
     * In case of OpenURL, this would contain the link.
     * @type {Array<string>}
     * @memberof InfoPushDataClickable
     */
    'parameters'?: Array<string>;
}

export const InfoPushDataClickableCommandEnum = {
    OpenUrl: 'OpenURL',
    OpenVrcPlusMenu: 'OpenVRCPlusMenu',
    OpenSafetyMenu: 'OpenSafetyMenu',
    CannedWorldSearch: 'CannedWorldSearch'
} as const;

export type InfoPushDataClickableCommandEnum = typeof InfoPushDataClickableCommandEnum[keyof typeof InfoPushDataClickableCommandEnum];

/**
 * * `hidden` field is only present if InstanceType is `hidden` aka \"Friends+\", and is instance creator. * `friends` field is only present if InstanceType is `friends` aka \"Friends\", and is instance creator. * `private` field is only present if InstanceType is `private` aka \"Invite\" or \"Invite+\", and is instance creator.
 * @export
 * @interface Instance
 */
export interface Instance {
    /**
     * 
     * @type {boolean}
     * @memberof Instance
     */
    'active': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Instance
     */
    'ageGate'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof Instance
     */
    'canRequestInvite': boolean;
    /**
     * 
     * @type {number}
     * @memberof Instance
     */
    'capacity': number;
    /**
     * Always returns \"unknown\".
     * @type {string}
     * @memberof Instance
     * @deprecated
     */
    'clientNumber': string;
    /**
     * 
     * @type {InstanceContentSettings}
     * @memberof Instance
     */
    'contentSettings': InstanceContentSettings;
    /**
     * 
     * @type {string}
     * @memberof Instance
     */
    'displayName': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Instance
     */
    'full': boolean;
    /**
     * 
     * @type {number}
     * @memberof Instance
     */
    'gameServerVersion'?: number;
    /**
     * InstanceID can be \"offline\" on User profiles if you are not friends with that user and \"private\" if you are friends and user is in private instance.
     * @type {string}
     * @memberof Instance
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Instance
     */
    'instanceId': string;
    /**
     * 
     * @type {string}
     * @memberof Instance
     */
    'instancePersistenceEnabled': string | null;
    /**
     * InstanceID can be \"offline\" on User profiles if you are not friends with that user and \"private\" if you are friends and user is in private instance.
     * @type {string}
     * @memberof Instance
     */
    'location': string;
    /**
     * 
     * @type {number}
     * @memberof Instance
     */
    'n_users': number;
    /**
     * 
     * @type {string}
     * @memberof Instance
     */
    'name': string;
    /**
     * A groupId if the instance type is \"group\", null if instance type is public, or a userId otherwise
     * @type {string}
     * @memberof Instance
     */
    'ownerId'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Instance
     */
    'permanent': boolean;
    /**
     * 
     * @type {Region}
     * @memberof Instance
     */
    'photonRegion': Region;
    /**
     * 
     * @type {InstancePlatforms}
     * @memberof Instance
     */
    'platforms': InstancePlatforms;
    /**
     * 
     * @type {boolean}
     * @memberof Instance
     */
    'playerPersistenceEnabled': boolean | null;
    /**
     * 
     * @type {InstanceRegion}
     * @memberof Instance
     */
    'region': InstanceRegion;
    /**
     * 
     * @type {string}
     * @memberof Instance
     */
    'secureName': string;
    /**
     * 
     * @type {string}
     * @memberof Instance
     */
    'shortName'?: string | null;
    /**
     * The tags array on Instances usually contain the language tags of the people in the instance. 
     * @type {Array<string>}
     * @memberof Instance
     */
    'tags': Array<string>;
    /**
     * 
     * @type {InstanceType}
     * @memberof Instance
     */
    'type': InstanceType;
    /**
     * WorldID be \"offline\" on User profiles if you are not friends with that user.
     * @type {string}
     * @memberof Instance
     */
    'worldId': string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof Instance
     */
    'hidden'?: string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof Instance
     */
    'friends'?: string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof Instance
     */
    'private'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Instance
     */
    'queueEnabled': boolean;
    /**
     * 
     * @type {number}
     * @memberof Instance
     */
    'queueSize': number;
    /**
     * 
     * @type {number}
     * @memberof Instance
     */
    'recommendedCapacity': number;
    /**
     * 
     * @type {boolean}
     * @memberof Instance
     */
    'roleRestricted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Instance
     */
    'strict': boolean;
    /**
     * 
     * @type {number}
     * @memberof Instance
     */
    'userCount': number;
    /**
     * 
     * @type {World}
     * @memberof Instance
     */
    'world': World;
    /**
     * The users field is present on instances created by the requesting user.
     * @type {Array<LimitedUserInstance>}
     * @memberof Instance
     */
    'users'?: Array<LimitedUserInstance>;
    /**
     * 
     * @type {GroupAccessType}
     * @memberof Instance
     */
    'groupAccessType'?: GroupAccessType;
    /**
     * 
     * @type {boolean}
     * @memberof Instance
     */
    'hasCapacityForYou'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Instance
     */
    'nonce'?: string;
    /**
     * 
     * @type {string}
     * @memberof Instance
     */
    'closedAt'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Instance
     */
    'hardClose'?: boolean | null;
}
/**
 * Types of dynamic user content permitted in an instance
 * @export
 * @interface InstanceContentSettings
 */
export interface InstanceContentSettings {
    /**
     * 
     * @type {boolean}
     * @memberof InstanceContentSettings
     */
    'drones'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InstanceContentSettings
     */
    'emoji'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InstanceContentSettings
     */
    'pedestals'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InstanceContentSettings
     */
    'prints'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InstanceContentSettings
     */
    'stickers'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InstanceContentSettings
     */
    'props'?: boolean;
}
/**
 * 
 * @export
 * @interface InstancePlatforms
 */
export interface InstancePlatforms {
    /**
     * 
     * @type {number}
     * @memberof InstancePlatforms
     */
    'android': number;
    /**
     * 
     * @type {number}
     * @memberof InstancePlatforms
     */
    'ios'?: number;
    /**
     * 
     * @type {number}
     * @memberof InstancePlatforms
     */
    'standalonewindows': number;
}
/**
 * Instance region
 * @export
 * @enum {string}
 */

export const InstanceRegion = {
    Us: 'us',
    Use: 'use',
    Eu: 'eu',
    Jp: 'jp',
    Unknown: 'unknown'
} as const;

export type InstanceRegion = typeof InstanceRegion[keyof typeof InstanceRegion];


/**
 * 
 * @export
 * @interface InstanceShortNameResponse
 */
export interface InstanceShortNameResponse {
    /**
     * 
     * @type {string}
     * @memberof InstanceShortNameResponse
     */
    'secureName': string;
    /**
     * 
     * @type {string}
     * @memberof InstanceShortNameResponse
     */
    'shortName'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const InstanceType = {
    Public: 'public',
    Hidden: 'hidden',
    Friends: 'friends',
    Private: 'private',
    Group: 'group'
} as const;

export type InstanceType = typeof InstanceType[keyof typeof InstanceType];


/**
 * 
 * @export
 * @interface InviteMessage
 */
export interface InviteMessage {
    /**
     * 
     * @type {boolean}
     * @memberof InviteMessage
     */
    'canBeUpdated': boolean;
    /**
     * 
     * @type {string}
     * @memberof InviteMessage
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InviteMessage
     */
    'message': string;
    /**
     * 
     * @type {InviteMessageType}
     * @memberof InviteMessage
     */
    'messageType': InviteMessageType;
    /**
     * Changes to 60 when updated, although probably server-side configurable.
     * @type {number}
     * @memberof InviteMessage
     */
    'remainingCooldownMinutes': number;
    /**
     * 
     * @type {number}
     * @memberof InviteMessage
     */
    'slot': number;
    /**
     * 
     * @type {string}
     * @memberof InviteMessage
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const InviteMessageType = {
    Message: 'message',
    Response: 'response',
    Request: 'request',
    RequestResponse: 'requestResponse'
} as const;

export type InviteMessageType = typeof InviteMessageType[keyof typeof InviteMessageType];


/**
 * 
 * @export
 * @interface InviteRequest
 */
export interface InviteRequest {
    /**
     * InstanceID can be \"offline\" on User profiles if you are not friends with that user and \"private\" if you are friends and user is in private instance.
     * @type {string}
     * @memberof InviteRequest
     */
    'instanceId': string;
    /**
     * 
     * @type {number}
     * @memberof InviteRequest
     */
    'messageSlot'?: number;
}
/**
 * 
 * @export
 * @interface InviteResponse
 */
export interface InviteResponse {
    /**
     * 
     * @type {number}
     * @memberof InviteResponse
     */
    'responseSlot': number;
}
/**
 * 
 * @export
 * @interface Jam
 */
export interface Jam {
    /**
     * 
     * @type {string}
     * @memberof Jam
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Jam
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof Jam
     */
    'isVisible': boolean;
    /**
     * 
     * @type {string}
     * @memberof Jam
     */
    'moreInfo': string;
    /**
     * One of: - submissions_open - closed
     * @type {string}
     * @memberof Jam
     */
    'state': string;
    /**
     * 
     * @type {JamStateChangeDates}
     * @memberof Jam
     */
    'stateChangeDates': JamStateChangeDates;
    /**
     * 
     * @type {string}
     * @memberof Jam
     */
    'submissionContentGateDate': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Jam
     */
    'submissionContentGated': boolean;
    /**
     * 
     * @type {string}
     * @memberof Jam
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Jam
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface JamStateChangeDates
 */
export interface JamStateChangeDates {
    /**
     * 
     * @type {string}
     * @memberof JamStateChangeDates
     */
    'closed'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JamStateChangeDates
     */
    'submissionsClosed'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JamStateChangeDates
     */
    'submissionsOpened'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JamStateChangeDates
     */
    'winnersSelected'?: string | null;
}
/**
 * 
 * @export
 * @interface License
 */
export interface License {
    /**
     * Either a AvatarID, LicenseGroupID, PermissionID or ProductID. This depends on the `forType` field.
     * @type {string}
     * @memberof License
     */
    'forId': string;
    /**
     * 
     * @type {LicenseType}
     * @memberof License
     */
    'forType': LicenseType;
    /**
     * 
     * @type {string}
     * @memberof License
     */
    'forName': string;
    /**
     * 
     * @type {LicenseAction}
     * @memberof License
     */
    'forAction': LicenseAction;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const LicenseAction = {
    Wear: 'wear',
    Have: 'have'
} as const;

export type LicenseAction = typeof LicenseAction[keyof typeof LicenseAction];


/**
 * 
 * @export
 * @interface LicenseGroup
 */
export interface LicenseGroup {
    /**
     * 
     * @type {string}
     * @memberof LicenseGroup
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LicenseGroup
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LicenseGroup
     */
    'description': string;
    /**
     * 
     * @type {Array<License>}
     * @memberof LicenseGroup
     */
    'licenses': Array<License>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const LicenseType = {
    Avatar: 'avatar',
    LicenseGroup: 'licenseGroup',
    Permission: 'permission',
    Product: 'product'
} as const;

export type LicenseType = typeof LicenseType[keyof typeof LicenseType];


/**
 * 
 * @export
 * @interface LimitedGroup
 */
export interface LimitedGroup {
    /**
     * 
     * @type {string}
     * @memberof LimitedGroup
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LimitedGroup
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof LimitedGroup
     */
    'shortCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof LimitedGroup
     */
    'discriminator'?: string;
    /**
     * 
     * @type {string}
     * @memberof LimitedGroup
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof LimitedGroup
     */
    'iconUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LimitedGroup
     */
    'bannerUrl'?: string | null;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof LimitedGroup
     */
    'ownerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof LimitedGroup
     */
    'rules'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LimitedGroup
     */
    'iconId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LimitedGroup
     */
    'bannerId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof LimitedGroup
     */
    'memberCount'?: number;
    /**
     *  
     * @type {Array<string>}
     * @memberof LimitedGroup
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof LimitedGroup
     */
    'createdAt'?: string;
    /**
     * 
     * @type {GroupMemberStatus}
     * @memberof LimitedGroup
     */
    'membershipStatus'?: GroupMemberStatus;
    /**
     * 
     * @type {boolean}
     * @memberof LimitedGroup
     */
    'isSearchable'?: boolean;
    /**
     *  
     * @type {Array<GroupGallery>}
     * @memberof LimitedGroup
     */
    'galleries'?: Array<GroupGallery>;
}
/**
 * 
 * @export
 * @interface LimitedUnityPackage
 */
export interface LimitedUnityPackage {
    /**
     * This can be `standalonewindows` or `android`, but can also pretty much be any random Unity verison such as `2019.2.4-801-Release` or `2019.2.2-772-Release` or even `unknownplatform`.
     * @type {string}
     * @memberof LimitedUnityPackage
     */
    'platform': string;
    /**
     * 
     * @type {string}
     * @memberof LimitedUnityPackage
     */
    'unityVersion': string;
}
/**
 * User object received when querying your friends list
 * @export
 * @interface LimitedUserFriend
 */
export interface LimitedUserFriend {
    /**
     * 
     * @type {string}
     * @memberof LimitedUserFriend
     */
    'bio'?: string;
    /**
     *  
     * @type {Array<string>}
     * @memberof LimitedUserFriend
     */
    'bioLinks'?: Array<string>;
    /**
     * When profilePicOverride is not empty, use it instead.
     * @type {string}
     * @memberof LimitedUserFriend
     */
    'currentAvatarImageUrl': string;
    /**
     * When profilePicOverride is not empty, use it instead.
     * @type {string}
     * @memberof LimitedUserFriend
     */
    'currentAvatarThumbnailImageUrl'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LimitedUserFriend
     */
    'currentAvatarTags'?: Array<string>;
    /**
     * 
     * @type {DeveloperType}
     * @memberof LimitedUserFriend
     */
    'developerType': DeveloperType;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserFriend
     */
    'displayName': string;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserFriend
     */
    'friendKey': string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof LimitedUserFriend
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof LimitedUserFriend
     */
    'isFriend': boolean;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserFriend
     */
    'imageUrl': string;
    /**
     * This can be `standalonewindows` or `android`, but can also pretty much be any random Unity verison such as `2019.2.4-801-Release` or `2019.2.2-772-Release` or even `unknownplatform`.
     * @type {string}
     * @memberof LimitedUserFriend
     */
    'last_platform': string;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserFriend
     */
    'location': string;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserFriend
     */
    'last_login': string | null;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserFriend
     */
    'last_activity': string | null;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserFriend
     */
    'last_mobile': string | null;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserFriend
     */
    'platform': string;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserFriend
     */
    'profilePicOverride': string;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserFriend
     */
    'profilePicOverrideThumbnail': string;
    /**
     * 
     * @type {UserStatus}
     * @memberof LimitedUserFriend
     */
    'status': UserStatus;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserFriend
     */
    'statusDescription': string;
    /**
     * <- Always empty.
     * @type {Array<string>}
     * @memberof LimitedUserFriend
     */
    'tags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserFriend
     */
    'userIcon': string;
}
/**
 * 
 * @export
 * @interface LimitedUserGroups
 */
export interface LimitedUserGroups {
    /**
     * 
     * @type {string}
     * @memberof LimitedUserGroups
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserGroups
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserGroups
     */
    'shortCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserGroups
     */
    'discriminator'?: string;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserGroups
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserGroups
     */
    'iconId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserGroups
     */
    'iconUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserGroups
     */
    'bannerId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserGroups
     */
    'bannerUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserGroups
     */
    'privacy'?: string;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserGroups
     */
    'lastPostCreatedAt'?: string | null;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof LimitedUserGroups
     */
    'ownerId'?: string;
    /**
     * 
     * @type {number}
     * @memberof LimitedUserGroups
     */
    'memberCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserGroups
     */
    'groupId'?: string;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserGroups
     */
    'memberVisibility'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LimitedUserGroups
     */
    'isRepresenting'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LimitedUserGroups
     */
    'mutualGroup'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserGroups
     */
    'lastPostReadAt'?: string | null;
}
/**
 * User object received when querying your own instance
 * @export
 * @interface LimitedUserInstance
 */
export interface LimitedUserInstance {
    /**
     * 
     * @type {AgeVerificationStatus}
     * @memberof LimitedUserInstance
     */
    'ageVerificationStatus': AgeVerificationStatus;
    /**
     * `true` if, user is age verified (not 18+).
     * @type {boolean}
     * @memberof LimitedUserInstance
     */
    'ageVerified': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LimitedUserInstance
     */
    'allowAvatarCopying': boolean;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserInstance
     */
    'bio'?: string;
    /**
     *  
     * @type {Array<string>}
     * @memberof LimitedUserInstance
     */
    'bioLinks'?: Array<string>;
    /**
     * When profilePicOverride is not empty, use it instead.
     * @type {string}
     * @memberof LimitedUserInstance
     */
    'currentAvatarImageUrl': string;
    /**
     * When profilePicOverride is not empty, use it instead.
     * @type {string}
     * @memberof LimitedUserInstance
     */
    'currentAvatarThumbnailImageUrl': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LimitedUserInstance
     */
    'currentAvatarTags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserInstance
     */
    'date_joined': string | null;
    /**
     * 
     * @type {DeveloperType}
     * @memberof LimitedUserInstance
     */
    'developerType': DeveloperType;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserInstance
     */
    'displayName': string;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserInstance
     */
    'friendKey': string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof LimitedUserInstance
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof LimitedUserInstance
     */
    'isFriend': boolean;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserInstance
     */
    'imageUrl'?: string;
    /**
     * This can be `standalonewindows` or `android`, but can also pretty much be any random Unity verison such as `2019.2.4-801-Release` or `2019.2.2-772-Release` or even `unknownplatform`.
     * @type {string}
     * @memberof LimitedUserInstance
     */
    'last_platform': string;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserInstance
     */
    'last_activity': string | null;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserInstance
     */
    'last_mobile': string | null;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserInstance
     */
    'platform'?: string;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserInstance
     */
    'profilePicOverride': string;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserInstance
     */
    'profilePicOverrideThumbnail': string;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserInstance
     */
    'pronouns': string;
    /**
     * 
     * @type {UserState}
     * @memberof LimitedUserInstance
     */
    'state': UserState;
    /**
     * 
     * @type {UserStatus}
     * @memberof LimitedUserInstance
     */
    'status': UserStatus;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserInstance
     */
    'statusDescription': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LimitedUserInstance
     */
    'tags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserInstance
     */
    'userIcon': string;
}
/**
 * User object received when searching
 * @export
 * @interface LimitedUserSearch
 */
export interface LimitedUserSearch {
    /**
     * 
     * @type {string}
     * @memberof LimitedUserSearch
     */
    'bio'?: string;
    /**
     *  
     * @type {Array<string>}
     * @memberof LimitedUserSearch
     */
    'bioLinks'?: Array<string>;
    /**
     * When profilePicOverride is not empty, use it instead.
     * @type {string}
     * @memberof LimitedUserSearch
     */
    'currentAvatarImageUrl': string;
    /**
     * When profilePicOverride is not empty, use it instead.
     * @type {string}
     * @memberof LimitedUserSearch
     */
    'currentAvatarThumbnailImageUrl': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LimitedUserSearch
     */
    'currentAvatarTags': Array<string>;
    /**
     * 
     * @type {DeveloperType}
     * @memberof LimitedUserSearch
     */
    'developerType': DeveloperType;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserSearch
     */
    'displayName': string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof LimitedUserSearch
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof LimitedUserSearch
     */
    'isFriend': boolean;
    /**
     * This can be `standalonewindows` or `android`, but can also pretty much be any random Unity verison such as `2019.2.4-801-Release` or `2019.2.2-772-Release` or even `unknownplatform`.
     * @type {string}
     * @memberof LimitedUserSearch
     */
    'last_platform': string;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserSearch
     */
    'profilePicOverride': string;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserSearch
     */
    'pronouns'?: string;
    /**
     * 
     * @type {UserStatus}
     * @memberof LimitedUserSearch
     */
    'status': UserStatus;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserSearch
     */
    'statusDescription': string;
    /**
     * <- Always empty.
     * @type {Array<string>}
     * @memberof LimitedUserSearch
     */
    'tags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof LimitedUserSearch
     */
    'userIcon': string;
}
/**
 * 
 * @export
 * @interface LimitedWorld
 */
export interface LimitedWorld {
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof LimitedWorld
     */
    'authorId': string;
    /**
     * 
     * @type {string}
     * @memberof LimitedWorld
     */
    'authorName': string;
    /**
     * 
     * @type {number}
     * @memberof LimitedWorld
     */
    'capacity': number;
    /**
     * 
     * @type {number}
     * @memberof LimitedWorld
     */
    'recommendedCapacity'?: number;
    /**
     * 
     * @type {string}
     * @memberof LimitedWorld
     */
    'created_at': string;
    /**
     * 
     * @type {InstanceContentSettings}
     * @memberof LimitedWorld
     */
    'defaultContentSettings'?: InstanceContentSettings;
    /**
     * 
     * @type {number}
     * @memberof LimitedWorld
     */
    'favorites': number;
    /**
     * 
     * @type {number}
     * @memberof LimitedWorld
     */
    'visits'?: number;
    /**
     * 
     * @type {number}
     * @memberof LimitedWorld
     */
    'heat': number;
    /**
     * WorldID be \"offline\" on User profiles if you are not friends with that user.
     * @type {string}
     * @memberof LimitedWorld
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LimitedWorld
     */
    'imageUrl': string;
    /**
     * 
     * @type {string}
     * @memberof LimitedWorld
     */
    'labsPublicationDate': string;
    /**
     * 
     * @type {string}
     * @memberof LimitedWorld
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof LimitedWorld
     */
    'occupants': number;
    /**
     * 
     * @type {string}
     * @memberof LimitedWorld
     */
    'organization': string;
    /**
     * 
     * @type {number}
     * @memberof LimitedWorld
     */
    'popularity': number;
    /**
     * 
     * @type {string}
     * @memberof LimitedWorld
     */
    'previewYoutubeId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LimitedWorld
     */
    'publicationDate': string;
    /**
     * 
     * @type {ReleaseStatus}
     * @memberof LimitedWorld
     */
    'releaseStatus': ReleaseStatus;
    /**
     * 
     * @type {string}
     * @memberof LimitedWorld
     */
    'storeId'?: string;
    /**
     *  
     * @type {Array<string>}
     * @memberof LimitedWorld
     */
    'tags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof LimitedWorld
     */
    'thumbnailImageUrl': string;
    /**
     *  
     * @type {Array<LimitedUnityPackage>}
     * @memberof LimitedWorld
     */
    'unityPackages': Array<LimitedUnityPackage>;
    /**
     * 
     * @type {string}
     * @memberof LimitedWorld
     */
    'updated_at': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LimitedWorld
     */
    'udonProducts'?: Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MIMEType = {
    ImageJpeg: 'image/jpeg',
    ImageJpg: 'image/jpg',
    ImagePng: 'image/png',
    ImageWebp: 'image/webp',
    ImageGif: 'image/gif',
    ImageBmp: 'image/bmp',
    ImageSvgxml: 'image/svgxml',
    ImageTiff: 'image/tiff',
    ApplicationXAvatar: 'application/x-avatar',
    ApplicationXWorld: 'application/x-world',
    ApplicationGzip: 'application/gzip',
    ApplicationXRsyncSignature: 'application/x-rsync-signature',
    ApplicationXRsyncDelta: 'application/x-rsync-delta',
    ApplicationOctetStream: 'application/octet-stream'
} as const;

export type MIMEType = typeof MIMEType[keyof typeof MIMEType];


/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {Response}
     * @memberof ModelError
     */
    'error'?: Response;
}
/**
 * 
 * @export
 * @interface ModelFile
 */
export interface ModelFile {
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'animationStyle'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'maskTag'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'extension': string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'id': string;
    /**
     * 
     * @type {MIMEType}
     * @memberof ModelFile
     */
    'mimeType': MIMEType;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'name': string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof ModelFile
     */
    'ownerId': string;
    /**
     *  
     * @type {Array<string>}
     * @memberof ModelFile
     */
    'tags': Array<string>;
    /**
     *  
     * @type {Set<FileVersion>}
     * @memberof ModelFile
     */
    'versions': Set<FileVersion>;
}
/**
 * 
 * @export
 * @interface ModerateUserRequest
 */
export interface ModerateUserRequest {
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof ModerateUserRequest
     */
    'moderated': string;
    /**
     * 
     * @type {PlayerModerationType}
     * @memberof ModerateUserRequest
     */
    'type': PlayerModerationType;
}
/**
 * 
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'created_at': string;
    /**
     * **NOTICE:** This is not a JSON object when received from the REST API, but it is when received from the Websocket API. When received from the REST API, this is a json **encoded** object, meaning you have to json-de-encode to get the NotificationDetail object depending on the NotificationType.
     * @type {string}
     * @memberof Notification
     */
    'details': string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'message': string;
    /**
     * Not included in notification objects received from the Websocket API
     * @type {boolean}
     * @memberof Notification
     */
    'seen'?: boolean;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof Notification
     */
    'receiverUserId'?: string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof Notification
     */
    'senderUserId': string;
    /**
     * -| **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
     * @type {string}
     * @memberof Notification
     * @deprecated
     */
    'senderUsername'?: string;
    /**
     * 
     * @type {NotificationType}
     * @memberof Notification
     */
    'type': NotificationType;
}
/**
 * 
 * @export
 * @interface NotificationDetailInvite
 */
export interface NotificationDetailInvite {
    /**
     * 
     * @type {string}
     * @memberof NotificationDetailInvite
     */
    'inviteMessage'?: string;
    /**
     * WorldID be \"offline\" on User profiles if you are not friends with that user.
     * @type {string}
     * @memberof NotificationDetailInvite
     */
    'worldId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationDetailInvite
     */
    'worldName': string;
}
/**
 * 
 * @export
 * @interface NotificationDetailInviteResponse
 */
export interface NotificationDetailInviteResponse {
    /**
     * 
     * @type {string}
     * @memberof NotificationDetailInviteResponse
     */
    'inResponseTo': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationDetailInviteResponse
     */
    'responseMessage': string;
}
/**
 * 
 * @export
 * @interface NotificationDetailRequestInvite
 */
export interface NotificationDetailRequestInvite {
    /**
     * TODO: Does this still exist?
     * @type {string}
     * @memberof NotificationDetailRequestInvite
     */
    'platform'?: string;
    /**
     * Used when using InviteMessage Slot.
     * @type {string}
     * @memberof NotificationDetailRequestInvite
     */
    'requestMessage'?: string;
}
/**
 * 
 * @export
 * @interface NotificationDetailRequestInviteResponse
 */
export interface NotificationDetailRequestInviteResponse {
    /**
     * 
     * @type {string}
     * @memberof NotificationDetailRequestInviteResponse
     */
    'inResponseTo': string;
    /**
     * Used when using InviteMessage Slot.
     * @type {string}
     * @memberof NotificationDetailRequestInviteResponse
     */
    'requestMessage'?: string;
}
/**
 * 
 * @export
 * @interface NotificationDetailVoteToKick
 */
export interface NotificationDetailVoteToKick {
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof NotificationDetailVoteToKick
     */
    'initiatorUserId': string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof NotificationDetailVoteToKick
     */
    'userToKickId': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const NotificationType = {
    FriendRequest: 'friendRequest',
    Invite: 'invite',
    InviteResponse: 'inviteResponse',
    Message: 'message',
    RequestInvite: 'requestInvite',
    RequestInviteResponse: 'requestInviteResponse',
    Votetokick: 'votetokick'
} as const;

export type NotificationType = typeof NotificationType[keyof typeof NotificationType];


/**
 * 
 * @export
 * @enum {string}
 */

export const OrderOption = {
    Ascending: 'ascending',
    Descending: 'descending'
} as const;

export type OrderOption = typeof OrderOption[keyof typeof OrderOption];


/**
 * 
 * @export
 * @interface PaginatedGroupAuditLogEntryList
 */
export interface PaginatedGroupAuditLogEntryList {
    /**
     *  
     * @type {Array<GroupAuditLogEntry>}
     * @memberof PaginatedGroupAuditLogEntryList
     */
    'results'?: Array<GroupAuditLogEntry>;
    /**
     * The total number of results that the query would return if there were no pagination.
     * @type {number}
     * @memberof PaginatedGroupAuditLogEntryList
     */
    'totalCount'?: number;
    /**
     * Whether there are more results after this page.
     * @type {boolean}
     * @memberof PaginatedGroupAuditLogEntryList
     */
    'hasNext'?: boolean;
}
/**
 * 
 * @export
 * @interface PastDisplayName
 */
export interface PastDisplayName {
    /**
     * 
     * @type {string}
     * @memberof PastDisplayName
     */
    'displayName': string;
    /**
     * 
     * @type {string}
     * @memberof PastDisplayName
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface Pending2FAResult
 */
export interface Pending2FAResult {
    /**
     * 
     * @type {string}
     * @memberof Pending2FAResult
     */
    'qrCodeDataUrl': string;
    /**
     * 
     * @type {string}
     * @memberof Pending2FAResult
     */
    'secret': string;
}
/**
 * Info about the performance limits on a platform
 * @export
 * @interface PerformanceLimiterInfo
 */
export interface PerformanceLimiterInfo {
    /**
     * Maximum amount of seats. -1 means no limit.
     * @type {number}
     * @memberof PerformanceLimiterInfo
     */
    'maxSeats': number;
}
/**
 * Avatar Performance ratings.
 * @export
 * @enum {string}
 */

export const PerformanceRatings = {
    None: 'None',
    Excellent: 'Excellent',
    Good: 'Good',
    Medium: 'Medium',
    Poor: 'Poor',
    VeryPoor: 'VeryPoor'
} as const;

export type PerformanceRatings = typeof PerformanceRatings[keyof typeof PerformanceRatings];


/**
 * 
 * @export
 * @interface Permission
 */
export interface Permission {
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'ownerDisplayName': string;
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'name': string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof Permission
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'type'?: string;
    /**
     * 
     * @type {object}
     * @memberof Permission
     */
    'data'?: object;
}
/**
 * Build information for a platform
 * @export
 * @interface PlatformBuildInfo
 */
export interface PlatformBuildInfo {
    /**
     * Minimum build number required for the platform
     * @type {number}
     * @memberof PlatformBuildInfo
     */
    'minBuildNumber': number;
    /**
     * Redirection URL for updating the app
     * @type {string}
     * @memberof PlatformBuildInfo
     */
    'redirectionAddress'?: string;
}
/**
 * 
 * @export
 * @interface PlayerModeration
 */
export interface PlayerModeration {
    /**
     * 
     * @type {string}
     * @memberof PlayerModeration
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerModeration
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerModeration
     */
    'sourceDisplayName': string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof PlayerModeration
     */
    'sourceUserId': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerModeration
     */
    'targetDisplayName': string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof PlayerModeration
     */
    'targetUserId': string;
    /**
     * 
     * @type {PlayerModerationType}
     * @memberof PlayerModeration
     */
    'type': PlayerModerationType;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PlayerModerationType = {
    Mute: 'mute',
    Unmute: 'unmute',
    Block: 'block',
    Unblock: 'unblock',
    InteractOn: 'interactOn',
    InteractOff: 'interactOff'
} as const;

export type PlayerModerationType = typeof PlayerModerationType[keyof typeof PlayerModerationType];


/**
 * Info about a print
 * @export
 * @interface Print
 */
export interface Print {
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof Print
     */
    'authorId': string;
    /**
     * 
     * @type {string}
     * @memberof Print
     */
    'authorName': string;
    /**
     * 
     * @type {string}
     * @memberof Print
     */
    'createdAt': string;
    /**
     * 
     * @type {PrintFiles}
     * @memberof Print
     */
    'files': PrintFiles;
    /**
     * 
     * @type {string}
     * @memberof Print
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Print
     */
    'note': string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof Print
     */
    'ownerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Print
     */
    'timestamp': string;
    /**
     * WorldID be \"offline\" on User profiles if you are not friends with that user.
     * @type {string}
     * @memberof Print
     */
    'worldId': string;
    /**
     * 
     * @type {string}
     * @memberof Print
     */
    'worldName': string;
}
/**
 * 
 * @export
 * @interface PrintFiles
 */
export interface PrintFiles {
    /**
     * 
     * @type {string}
     * @memberof PrintFiles
     */
    'fileId'?: string;
    /**
     * Link to file, e.g. https://api.vrchat.cloud/api/1/file/file_66fe782d-f2bd-4462-9761-1d766d7b2b26/1/file
     * @type {string}
     * @memberof PrintFiles
     */
    'image'?: string;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * 
     * @type {boolean}
     * @memberof Product
     */
    'archived': boolean;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'displayName': string;
    /**
     * 
     * @type {boolean}
     * @memberof Product
     */
    'groupAccess'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Product
     */
    'groupAccessRemove'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'groupId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'groupRoleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'imageId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Product
     */
    'parentListings': Array<string>;
    /**
     * 
     * @type {ProductType}
     * @memberof Product
     */
    'productType': ProductType;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'sellerDisplayName': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'sellerId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Product
     */
    'tags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'updated': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Product
     */
    'useForSubscriberList'?: boolean;
}
/**
 * 
 * @export
 * @interface ProductListing
 */
export interface ProductListing {
    /**
     * 
     * @type {boolean}
     * @memberof ProductListing
     */
    'active': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProductListing
     */
    'archived': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProductListing
     */
    'buyerRefundable': boolean;
    /**
     * 
     * @type {string}
     * @memberof ProductListing
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof ProductListing
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ProductListing
     */
    'displayName': string;
    /**
     * 
     * @type {number}
     * @memberof ProductListing
     */
    'duration'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductListing
     */
    'durationType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductListing
     */
    'groupIcon': string;
    /**
     * 
     * @type {string}
     * @memberof ProductListing
     */
    'groupId': string;
    /**
     * 
     * @type {string}
     * @memberof ProductListing
     */
    'groupName': string;
    /**
     * 
     * @type {Array<Product>}
     * @memberof ProductListing
     */
    'hydratedProducts'?: Array<Product>;
    /**
     * 
     * @type {string}
     * @memberof ProductListing
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProductListing
     */
    'imageId': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProductListing
     */
    'instant': boolean;
    /**
     * 
     * @type {ProductListingType}
     * @memberof ProductListing
     */
    'listingType': ProductListingType;
    /**
     * 
     * @type {Array<ProductListingVariant>}
     * @memberof ProductListing
     */
    'listingVariants': Array<ProductListingVariant>;
    /**
     * 
     * @type {boolean}
     * @memberof ProductListing
     */
    'permanent': boolean;
    /**
     * 
     * @type {number}
     * @memberof ProductListing
     */
    'priceTokens': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductListing
     */
    'productIds': Array<string>;
    /**
     * 
     * @type {ProductType}
     * @memberof ProductListing
     */
    'productType': ProductType;
    /**
     * 
     * @type {Array<object>}
     * @memberof ProductListing
     */
    'products': Array<object>;
    /**
     * 
     * @type {boolean}
     * @memberof ProductListing
     */
    'quantifiable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProductListing
     */
    'recurrable': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProductListing
     */
    'refundable': boolean;
    /**
     * 
     * @type {string}
     * @memberof ProductListing
     */
    'sellerDisplayName': string;
    /**
     * 
     * @type {string}
     * @memberof ProductListing
     */
    'sellerId': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProductListing
     */
    'stackable': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductListing
     */
    'storeIds': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductListing
     */
    'tags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ProductListing
     */
    'updated': string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ProductListingType = {
    Subscription: 'subscription'
} as const;

export type ProductListingType = typeof ProductListingType[keyof typeof ProductListingType];


/**
 * 
 * @export
 * @interface ProductListingVariant
 */
export interface ProductListingVariant {
    /**
     * 
     * @type {string}
     * @memberof ProductListingVariant
     */
    'effectiveFrom'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductListingVariant
     */
    'listingVariantId': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProductListingVariant
     */
    'nonRefundable': boolean;
    /**
     * 
     * @type {number}
     * @memberof ProductListingVariant
     */
    'quantity': number;
    /**
     * 
     * @type {boolean}
     * @memberof ProductListingVariant
     */
    'sellerVariant': boolean;
    /**
     * 
     * @type {number}
     * @memberof ProductListingVariant
     */
    'unitPriceTokens': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ProductType = {
    Listing: 'listing',
    Role: 'role',
    Udon: 'udon'
} as const;

export type ProductType = typeof ProductType[keyof typeof ProductType];


/**
 * API/Photon region.
 * @export
 * @enum {string}
 */

export const Region = {
    Us: 'us',
    Use: 'use',
    Usw: 'usw',
    Usx: 'usx',
    Eu: 'eu',
    Jp: 'jp',
    Unknown: 'unknown'
} as const;

export type Region = typeof Region[keyof typeof Region];


/**
 * 
 * @export
 * @interface RegisterUserAccountRequest
 */
export interface RegisterUserAccountRequest {
    /**
     * Display Name / Username (Username is a sanitized version)
     * @type {string}
     * @memberof RegisterUserAccountRequest
     */
    'username': string;
    /**
     * Password
     * @type {string}
     * @memberof RegisterUserAccountRequest
     */
    'password': string;
    /**
     * Email address
     * @type {string}
     * @memberof RegisterUserAccountRequest
     */
    'email': string;
    /**
     * Birth year
     * @type {string}
     * @memberof RegisterUserAccountRequest
     */
    'year': string;
    /**
     * Birth month of year
     * @type {string}
     * @memberof RegisterUserAccountRequest
     */
    'month': string;
    /**
     * Birth day of month
     * @type {string}
     * @memberof RegisterUserAccountRequest
     */
    'day': string;
    /**
     * Captcha code
     * @type {string}
     * @memberof RegisterUserAccountRequest
     */
    'captchaCode': string;
    /**
     * Whether to recieve promotional emails
     * @type {boolean}
     * @memberof RegisterUserAccountRequest
     */
    'subscribe': boolean;
    /**
     * The most recent version of the TOS
     * @type {number}
     * @memberof RegisterUserAccountRequest
     */
    'acceptedTOSVersion': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ReleaseStatus = {
    Public: 'public',
    Private: 'private',
    Hidden: 'hidden',
    All: 'all'
} as const;

export type ReleaseStatus = typeof ReleaseStatus[keyof typeof ReleaseStatus];


/**
 * A category used for reporting content
 * @export
 * @interface ReportCategory
 */
export interface ReportCategory {
    /**
     * The description of the report category
     * @type {string}
     * @memberof ReportCategory
     */
    'description'?: string;
    /**
     * The title of the report category
     * @type {string}
     * @memberof ReportCategory
     */
    'title'?: string;
    /**
     * The label of the report category
     * @type {string}
     * @memberof ReportCategory
     */
    'text': string;
    /**
     * The tooltip that describes the category
     * @type {string}
     * @memberof ReportCategory
     */
    'tooltip': string;
}
/**
 * A reason used for reporting users
 * @export
 * @interface ReportReason
 */
export interface ReportReason {
    /**
     * The label or name of the report reason
     * @type {string}
     * @memberof ReportReason
     */
    'text': string;
    /**
     * A brief explanation of what this reason entails
     * @type {string}
     * @memberof ReportReason
     */
    'tooltip': string;
}
/**
 * 
 * @export
 * @interface RepresentedGroup
 */
export interface RepresentedGroup {
    /**
     * 
     * @type {string}
     * @memberof RepresentedGroup
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RepresentedGroup
     */
    'shortCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof RepresentedGroup
     */
    'discriminator'?: string;
    /**
     * 
     * @type {string}
     * @memberof RepresentedGroup
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof RepresentedGroup
     */
    'iconId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RepresentedGroup
     */
    'iconUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RepresentedGroup
     */
    'bannerId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RepresentedGroup
     */
    'bannerUrl'?: string | null;
    /**
     * 
     * @type {GroupPrivacy}
     * @memberof RepresentedGroup
     */
    'privacy'?: GroupPrivacy;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof RepresentedGroup
     */
    'ownerId'?: string;
    /**
     * 
     * @type {number}
     * @memberof RepresentedGroup
     */
    'memberCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof RepresentedGroup
     */
    'groupId'?: string;
    /**
     * 
     * @type {GroupUserVisibility}
     * @memberof RepresentedGroup
     */
    'memberVisibility'?: GroupUserVisibility;
    /**
     * 
     * @type {boolean}
     * @memberof RepresentedGroup
     */
    'isRepresenting'?: boolean;
}
/**
 * 
 * @export
 * @interface RequestInviteRequest
 */
export interface RequestInviteRequest {
    /**
     * 
     * @type {number}
     * @memberof RequestInviteRequest
     */
    'messageSlot'?: number;
}
/**
 * 
 * @export
 * @interface RespondGroupJoinRequest
 */
export interface RespondGroupJoinRequest {
    /**
     * 
     * @type {GroupJoinRequestAction}
     * @memberof RespondGroupJoinRequest
     */
    'action': GroupJoinRequestAction;
    /**
     * Whether to block the user from requesting again
     * @type {boolean}
     * @memberof RespondGroupJoinRequest
     */
    'block'?: boolean;
}
/**
 * 
 * @export
 * @interface Response
 */
export interface Response {
    /**
     * 
     * @type {string}
     * @memberof Response
     */
    'message'?: string;
    /**
     * 
     * @type {number}
     * @memberof Response
     */
    'status_code': number;
}
/**
 * 
 * @export
 * @interface SentNotification
 */
export interface SentNotification {
    /**
     * 
     * @type {string}
     * @memberof SentNotification
     */
    'created_at': string;
    /**
     * 
     * @type {object}
     * @memberof SentNotification
     */
    'details': object;
    /**
     * 
     * @type {string}
     * @memberof SentNotification
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SentNotification
     */
    'message': string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof SentNotification
     */
    'receiverUserId': string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof SentNotification
     */
    'senderUserId': string;
    /**
     * -| **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
     * @type {string}
     * @memberof SentNotification
     * @deprecated
     */
    'senderUsername'?: string;
    /**
     * 
     * @type {NotificationType}
     * @memberof SentNotification
     */
    'type': NotificationType;
}
/**
 * Statistics about the user\'s currently queued service request
 * @export
 * @interface ServiceQueueStats
 */
export interface ServiceQueueStats {
    /**
     * 
     * @type {number}
     * @memberof ServiceQueueStats
     */
    'estimatedServiceDurationSeconds': number;
}
/**
 * Status information for a service request
 * @export
 * @interface ServiceStatus
 */
export interface ServiceStatus {
    /**
     * 
     * @type {string}
     * @memberof ServiceStatus
     */
    'created_at': string;
    /**
     * The id of this service, NOT the id of the thing this service was requested for.
     * @type {string}
     * @memberof ServiceStatus
     */
    'id': string;
    /**
     * 
     * @type {Array<object>}
     * @memberof ServiceStatus
     */
    'progress': Array<object>;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof ServiceStatus
     */
    'requesterUserId': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceStatus
     */
    'state': string;
    /**
     * The id of the thing this service was requested for.
     * @type {string}
     * @memberof ServiceStatus
     */
    'subjectId': string;
    /**
     * The kind of the thing this service was requested for.
     * @type {string}
     * @memberof ServiceStatus
     */
    'subjectType': string;
    /**
     * The kind of service that was requested.
     * @type {string}
     * @memberof ServiceStatus
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceStatus
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SortOption = {
    Popularity: 'popularity',
    Heat: 'heat',
    Trust: 'trust',
    Shuffle: 'shuffle',
    Random: 'random',
    Favorites: 'favorites',
    ReportScore: 'reportScore',
    ReportCount: 'reportCount',
    PublicationDate: 'publicationDate',
    LabsPublicationDate: 'labsPublicationDate',
    Created: 'created',
    CreatedAt: '_created_at',
    Updated: 'updated',
    UpdatedAt: '_updated_at',
    Order: 'order',
    Relevance: 'relevance',
    Magic: 'magic',
    Name: 'name'
} as const;

export type SortOption = typeof SortOption[keyof typeof SortOption];


/**
 * 
 * @export
 * @interface Submission
 */
export interface Submission {
    /**
     * Either world ID or avatar ID
     * @type {string}
     * @memberof Submission
     */
    'contentId': string;
    /**
     * 
     * @type {string}
     * @memberof Submission
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Submission
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Submission
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Submission
     */
    'jamId': string;
    /**
     * 
     * @type {number}
     * @memberof Submission
     */
    'ratingScore'?: number;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof Submission
     */
    'submitterId': string;
}
/**
 * 
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'steamItemId': string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'oculusSku'?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'googleProductId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'googlePlanId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'picoSku'?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'appleProductId'?: string;
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'description': string;
    /**
     * 
     * @type {SubscriptionPeriod}
     * @memberof Subscription
     */
    'period': SubscriptionPeriod;
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    'tier': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SubscriptionPeriod = {
    Hour: 'hour',
    Day: 'day',
    Week: 'week',
    Month: 'month',
    Year: 'year'
} as const;

export type SubscriptionPeriod = typeof SubscriptionPeriod[keyof typeof SubscriptionPeriod];


/**
 * 
 * @export
 * @interface Success
 */
export interface Success {
    /**
     * 
     * @type {Response}
     * @memberof Success
     */
    'success'?: Response;
}
/**
 * 
 * @export
 * @interface TiliaStatus
 */
export interface TiliaStatus {
    /**
     * 
     * @type {boolean}
     * @memberof TiliaStatus
     */
    'economyOnline': boolean;
    /**
     * 
     * @type {number}
     * @memberof TiliaStatus
     */
    'economyState'?: number;
    /**
     * 
     * @type {string}
     * @memberof TiliaStatus
     */
    'plannedOfflineWindowStart'?: string;
    /**
     * 
     * @type {string}
     * @memberof TiliaStatus
     */
    'plannedOfflineWindowEnd'?: string;
}
/**
 * 
 * @export
 * @interface TiliaTOS
 */
export interface TiliaTOS {
    /**
     * 
     * @type {boolean}
     * @memberof TiliaTOS
     */
    'signed_tos': boolean;
}
/**
 * 
 * @export
 * @interface TokenBundle
 */
export interface TokenBundle {
    /**
     * 
     * @type {string}
     * @memberof TokenBundle
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TokenBundle
     */
    'steamItemId': string;
    /**
     * 
     * @type {string}
     * @memberof TokenBundle
     */
    'oculusSku': string;
    /**
     * 
     * @type {string}
     * @memberof TokenBundle
     */
    'googleProductId'?: string;
    /**
     * price of the bundle
     * @type {number}
     * @memberof TokenBundle
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof TokenBundle
     */
    'description': string;
    /**
     * number of tokens received
     * @type {number}
     * @memberof TokenBundle
     */
    'tokens': number;
    /**
     * direct url to image
     * @type {string}
     * @memberof TokenBundle
     */
    'imageUrl': string;
}
/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'id': string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof Transaction
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'userDisplayName'?: string;
    /**
     * 
     * @type {TransactionStatus}
     * @memberof Transaction
     */
    'status': TransactionStatus;
    /**
     * 
     * @type {Subscription}
     * @memberof Transaction
     */
    'subscription': Subscription;
    /**
     * 
     * @type {boolean}
     * @memberof Transaction
     */
    'sandbox': boolean;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'updated_at': string;
    /**
     * 
     * @type {TransactionSteamInfo}
     * @memberof Transaction
     */
    'steam'?: TransactionSteamInfo;
    /**
     * 
     * @type {TransactionAgreement}
     * @memberof Transaction
     */
    'agreement'?: TransactionAgreement;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'error': string;
    /**
     * 
     * @type {boolean}
     * @memberof Transaction
     */
    'isGift'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Transaction
     */
    'isTokens'?: boolean;
}
/**
 * Represents a single Transaction, which is likely between VRChat and Steam.
 * @export
 * @interface TransactionAgreement
 */
export interface TransactionAgreement {
    /**
     * 
     * @type {string}
     * @memberof TransactionAgreement
     */
    'agreementId': string;
    /**
     * 
     * @type {number}
     * @memberof TransactionAgreement
     */
    'itemId': number;
    /**
     * 
     * @type {string}
     * @memberof TransactionAgreement
     */
    'agreement': string;
    /**
     * This is NOT TransactionStatus, but whatever Steam return.
     * @type {string}
     * @memberof TransactionAgreement
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionAgreement
     */
    'period': string;
    /**
     * 
     * @type {number}
     * @memberof TransactionAgreement
     */
    'frequency': number;
    /**
     * 
     * @type {string}
     * @memberof TransactionAgreement
     */
    'billingType': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionAgreement
     */
    'startDate': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionAgreement
     */
    'endDate': string;
    /**
     * 
     * @type {number}
     * @memberof TransactionAgreement
     */
    'recurringAmt': number;
    /**
     * 
     * @type {string}
     * @memberof TransactionAgreement
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionAgreement
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionAgreement
     */
    'nextPayment': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionAgreement
     */
    'lastPayment': string;
    /**
     * 
     * @type {number}
     * @memberof TransactionAgreement
     */
    'lastAmount': number;
    /**
     * 
     * @type {number}
     * @memberof TransactionAgreement
     */
    'lastAmountVat': number;
    /**
     * 
     * @type {number}
     * @memberof TransactionAgreement
     */
    'outstanding': number;
    /**
     * 
     * @type {number}
     * @memberof TransactionAgreement
     */
    'failedAttempts': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TransactionStatus = {
    Active: 'active',
    Failed: 'failed',
    Expired: 'expired',
    Chargeback: 'chargeback'
} as const;

export type TransactionStatus = typeof TransactionStatus[keyof typeof TransactionStatus];


/**
 * 
 * @export
 * @interface TransactionSteamInfo
 */
export interface TransactionSteamInfo {
    /**
     * 
     * @type {TransactionSteamWalletInfo}
     * @memberof TransactionSteamInfo
     */
    'walletInfo': TransactionSteamWalletInfo;
    /**
     * Steam User ID
     * @type {string}
     * @memberof TransactionSteamInfo
     */
    'steamId': string;
    /**
     * Steam Order ID
     * @type {string}
     * @memberof TransactionSteamInfo
     */
    'orderId': string;
    /**
     * Empty
     * @type {string}
     * @memberof TransactionSteamInfo
     */
    'steamUrl': string;
    /**
     * Steam Transaction ID, NOT the same as VRChat TransactionID
     * @type {string}
     * @memberof TransactionSteamInfo
     */
    'transId': string;
}
/**
 * 
 * @export
 * @interface TransactionSteamWalletInfo
 */
export interface TransactionSteamWalletInfo {
    /**
     * 
     * @type {string}
     * @memberof TransactionSteamWalletInfo
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionSteamWalletInfo
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionSteamWalletInfo
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionSteamWalletInfo
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface TwoFactorAuthCode
 */
export interface TwoFactorAuthCode {
    /**
     * 
     * @type {string}
     * @memberof TwoFactorAuthCode
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface TwoFactorEmailCode
 */
export interface TwoFactorEmailCode {
    /**
     * 
     * @type {string}
     * @memberof TwoFactorEmailCode
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface TwoFactorRecoveryCodes
 */
export interface TwoFactorRecoveryCodes {
    /**
     * 
     * @type {Array<string>}
     * @memberof TwoFactorRecoveryCodes
     */
    'requiresTwoFactorAuth'?: Array<string>;
    /**
     * 
     * @type {Array<TwoFactorRecoveryCodesOtpInner>}
     * @memberof TwoFactorRecoveryCodes
     */
    'otp'?: Array<TwoFactorRecoveryCodesOtpInner>;
}
/**
 * 
 * @export
 * @interface TwoFactorRecoveryCodesOtpInner
 */
export interface TwoFactorRecoveryCodesOtpInner {
    /**
     * 
     * @type {string}
     * @memberof TwoFactorRecoveryCodesOtpInner
     */
    'code': string;
    /**
     * 
     * @type {boolean}
     * @memberof TwoFactorRecoveryCodesOtpInner
     */
    'used': boolean;
}
/**
 * 
 * @export
 * @interface UnityPackage
 */
export interface UnityPackage {
    /**
     * 
     * @type {string}
     * @memberof UnityPackage
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UnityPackage
     */
    'assetUrl'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof UnityPackage
     */
    'assetUrlObject'?: object;
    /**
     * 
     * @type {number}
     * @memberof UnityPackage
     */
    'assetVersion': number;
    /**
     * 
     * @type {string}
     * @memberof UnityPackage
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnityPackage
     */
    'impostorizerVersion'?: string;
    /**
     * 
     * @type {PerformanceRatings}
     * @memberof UnityPackage
     */
    'performanceRating'?: PerformanceRatings;
    /**
     * This can be `standalonewindows` or `android`, but can also pretty much be any random Unity verison such as `2019.2.4-801-Release` or `2019.2.2-772-Release` or even `unknownplatform`.
     * @type {string}
     * @memberof UnityPackage
     */
    'platform': string;
    /**
     * 
     * @type {string}
     * @memberof UnityPackage
     */
    'pluginUrl'?: string;
    /**
     * 
     * @type {object}
     * @memberof UnityPackage
     */
    'pluginUrlObject'?: object;
    /**
     * 
     * @type {number}
     * @memberof UnityPackage
     */
    'unitySortNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof UnityPackage
     */
    'unityVersion': string;
    /**
     * 
     * @type {string}
     * @memberof UnityPackage
     */
    'worldSignature'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UnityPackage
     */
    'impostorUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UnityPackage
     */
    'scanStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnityPackage
     */
    'variant'?: string;
}
/**
 * 
 * @export
 * @interface UpdateAvatarRequest
 */
export interface UpdateAvatarRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateAvatarRequest
     */
    'assetUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAvatarRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAvatarRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAvatarRequest
     */
    'description'?: string;
    /**
     *  
     * @type {Array<string>}
     * @memberof UpdateAvatarRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateAvatarRequest
     */
    'imageUrl'?: string;
    /**
     * 
     * @type {ReleaseStatus}
     * @memberof UpdateAvatarRequest
     */
    'releaseStatus'?: ReleaseStatus;
    /**
     * 
     * @type {number}
     * @memberof UpdateAvatarRequest
     */
    'version'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateAvatarRequest
     */
    'unityPackageUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAvatarRequest
     */
    'unityVersion'?: string;
}
/**
 * 
 * @export
 * @interface UpdateFavoriteGroupRequest
 */
export interface UpdateFavoriteGroupRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateFavoriteGroupRequest
     */
    'displayName'?: string;
    /**
     * 
     * @type {FavoriteGroupVisibility}
     * @memberof UpdateFavoriteGroupRequest
     */
    'visibility'?: FavoriteGroupVisibility;
    /**
     * Tags on FavoriteGroups are believed to do nothing.
     * @type {Array<string>}
     * @memberof UpdateFavoriteGroupRequest
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateGroupGalleryRequest
 */
export interface UpdateGroupGalleryRequest {
    /**
     * Name of the gallery.
     * @type {string}
     * @memberof UpdateGroupGalleryRequest
     */
    'name'?: string;
    /**
     * Description of the gallery.
     * @type {string}
     * @memberof UpdateGroupGalleryRequest
     */
    'description'?: string;
    /**
     * Whether the gallery is members only.
     * @type {boolean}
     * @memberof UpdateGroupGalleryRequest
     */
    'membersOnly'?: boolean;
    /**
     *  
     * @type {Array<string>}
     * @memberof UpdateGroupGalleryRequest
     */
    'roleIdsToView'?: Array<string> | null;
    /**
     *  
     * @type {Array<string>}
     * @memberof UpdateGroupGalleryRequest
     */
    'roleIdsToSubmit'?: Array<string> | null;
    /**
     *  
     * @type {Array<string>}
     * @memberof UpdateGroupGalleryRequest
     */
    'roleIdsToAutoApprove'?: Array<string> | null;
    /**
     *  
     * @type {Array<string>}
     * @memberof UpdateGroupGalleryRequest
     */
    'roleIdsToManage'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface UpdateGroupMemberRequest
 */
export interface UpdateGroupMemberRequest {
    /**
     * 
     * @type {GroupUserVisibility}
     * @memberof UpdateGroupMemberRequest
     */
    'visibility'?: GroupUserVisibility;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateGroupMemberRequest
     */
    'isSubscribedToAnnouncements'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateGroupMemberRequest
     */
    'managerNotes'?: string;
}
/**
 * 
 * @export
 * @interface UpdateGroupRepresentationRequest
 */
export interface UpdateGroupRepresentationRequest {
    /**
     * Whether the user is representing the group.
     * @type {boolean}
     * @memberof UpdateGroupRepresentationRequest
     */
    'isRepresenting': boolean;
}
/**
 * 
 * @export
 * @interface UpdateGroupRequest
 */
export interface UpdateGroupRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateGroupRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateGroupRequest
     */
    'shortCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateGroupRequest
     */
    'description'?: string;
    /**
     * 
     * @type {GroupJoinState}
     * @memberof UpdateGroupRequest
     */
    'joinState'?: GroupJoinState;
    /**
     * 
     * @type {string}
     * @memberof UpdateGroupRequest
     */
    'iconId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateGroupRequest
     */
    'bannerId'?: string | null;
    /**
     * 3 letter language code
     * @type {Array<string>}
     * @memberof UpdateGroupRequest
     */
    'languages'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateGroupRequest
     */
    'links'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateGroupRequest
     */
    'rules'?: string;
    /**
     *  
     * @type {Array<string>}
     * @memberof UpdateGroupRequest
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateGroupRoleRequest
 */
export interface UpdateGroupRoleRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateGroupRoleRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateGroupRoleRequest
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateGroupRoleRequest
     */
    'isSelfAssignable'?: boolean;
    /**
     * 
     * @type {Array<GroupPermissions>}
     * @memberof UpdateGroupRoleRequest
     */
    'permissions'?: Array<GroupPermissions>;
    /**
     * 
     * @type {number}
     * @memberof UpdateGroupRoleRequest
     */
    'order'?: number;
}
/**
 * 
 * @export
 * @interface UpdateInviteMessageRequest
 */
export interface UpdateInviteMessageRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateInviteMessageRequest
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface UpdateUserBadgeRequest
 */
export interface UpdateUserBadgeRequest {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserBadgeRequest
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserBadgeRequest
     */
    'showcased'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateUserNoteRequest
 */
export interface UpdateUserNoteRequest {
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof UpdateUserNoteRequest
     */
    'targetUserId': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserNoteRequest
     */
    'note': string;
}
/**
 * 
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'email'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    'unsubscribe'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'birthday'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateUserRequest
     */
    'acceptedTOSVersion'?: number;
    /**
     *  
     * @type {Array<string>}
     * @memberof UpdateUserRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {UserStatus}
     * @memberof UpdateUserRequest
     */
    'status'?: UserStatus;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'statusDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'bio'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateUserRequest
     */
    'bioLinks'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'pronouns'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    'isBoopingEnabled'?: boolean;
    /**
     * MUST be a valid VRChat /file/ url.
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'userIcon'?: string;
    /**
     * These tags begin with `content_` and control content gating
     * @type {Array<string>}
     * @memberof UpdateUserRequest
     */
    'contentFilters'?: Array<string>;
    /**
     * MUST specify currentPassword as well to change display name
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'displayName'?: string;
    /**
     * MUST specify currentPassword as well to revert display name
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    'revertDisplayName'?: boolean;
    /**
     * MUST specify currentPassword as well to change password
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'currentPassword'?: string;
}
/**
 * 
 * @export
 * @interface UpdateWorldRequest
 */
export interface UpdateWorldRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateWorldRequest
     */
    'assetUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWorldRequest
     */
    'assetVersion'?: string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof UpdateWorldRequest
     */
    'authorId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWorldRequest
     */
    'authorName'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateWorldRequest
     */
    'capacity'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateWorldRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWorldRequest
     */
    'imageUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWorldRequest
     */
    'name'?: string;
    /**
     * This can be `standalonewindows` or `android`, but can also pretty much be any random Unity verison such as `2019.2.4-801-Release` or `2019.2.2-772-Release` or even `unknownplatform`.
     * @type {string}
     * @memberof UpdateWorldRequest
     */
    'platform'?: string;
    /**
     * 
     * @type {ReleaseStatus}
     * @memberof UpdateWorldRequest
     */
    'releaseStatus'?: ReleaseStatus;
    /**
     *  
     * @type {Array<string>}
     * @memberof UpdateWorldRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateWorldRequest
     */
    'unityPackageUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWorldRequest
     */
    'unityVersion'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {AgeVerificationStatus}
     * @memberof User
     */
    'ageVerificationStatus': AgeVerificationStatus;
    /**
     * `true` if, user is age verified (not 18+).
     * @type {boolean}
     * @memberof User
     */
    'ageVerified': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'allowAvatarCopying': boolean;
    /**
     *  
     * @type {Array<Badge>}
     * @memberof User
     */
    'badges'?: Array<Badge>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'bio': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'bioLinks': Array<string>;
    /**
     * When profilePicOverride is not empty, use it instead.
     * @type {string}
     * @memberof User
     */
    'currentAvatarImageUrl': string;
    /**
     * When profilePicOverride is not empty, use it instead.
     * @type {string}
     * @memberof User
     */
    'currentAvatarThumbnailImageUrl': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'currentAvatarTags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'date_joined': string;
    /**
     * 
     * @type {DeveloperType}
     * @memberof User
     */
    'developerType': DeveloperType;
    /**
     * A users visual display name. This is what shows up in-game, and can different from their `username`. Changing display name is restricted to a cooldown period.
     * @type {string}
     * @memberof User
     */
    'displayName': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'friendKey': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'friendRequestStatus'?: string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * InstanceID can be \"offline\" on User profiles if you are not friends with that user and \"private\" if you are friends and user is in private instance.
     * @type {string}
     * @memberof User
     */
    'instanceId'?: string;
    /**
     * Either their `friendKey`, or empty string if you are not friends. Unknown usage.
     * @type {boolean}
     * @memberof User
     */
    'isFriend': boolean;
    /**
     * Either a date-time or empty string.
     * @type {string}
     * @memberof User
     */
    'last_activity': string;
    /**
     * Either a date-time or empty string.
     * @type {string}
     * @memberof User
     */
    'last_login': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'last_mobile'?: string | null;
    /**
     * This can be `standalonewindows` or `android`, but can also pretty much be any random Unity verison such as `2019.2.4-801-Release` or `2019.2.2-772-Release` or even `unknownplatform`.
     * @type {string}
     * @memberof User
     */
    'last_platform': string;
    /**
     * WorldID be \"offline\" on User profiles if you are not friends with that user.
     * @type {string}
     * @memberof User
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'note'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'platform'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'profilePicOverride': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'profilePicOverrideThumbnail': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'pronouns': string;
    /**
     * 
     * @type {UserState}
     * @memberof User
     */
    'state': UserState;
    /**
     * 
     * @type {UserStatus}
     * @memberof User
     */
    'status': UserStatus;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'statusDescription': string;
    /**
     *  
     * @type {Array<string>}
     * @memberof User
     */
    'tags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'travelingToInstance'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'travelingToLocation'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'travelingToWorld'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'userIcon': string;
    /**
     * -| A users unique name, used during login. This is different from `displayName` which is what shows up in-game. A users `username` can never be changed.\' **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
     * @type {string}
     * @memberof User
     * @deprecated
     */
    'username'?: string;
    /**
     * WorldID be \"offline\" on User profiles if you are not friends with that user.
     * @type {string}
     * @memberof User
     */
    'worldId'?: string;
}
/**
 * Status object representing if a queried user by username or userId exists or not. This model is primarily used by the `/auth/exists` endpoint, which in turn is used during registration. Please see the documentation on that endpoint for more information on usage.
 * @export
 * @interface UserExists
 */
export interface UserExists {
    /**
     * Status if a user exist with that username or userId.
     * @type {boolean}
     * @memberof UserExists
     */
    'userExists': boolean;
    /**
     * Is the username valid?
     * @type {boolean}
     * @memberof UserExists
     */
    'nameOk'?: boolean;
}
/**
 * 
 * @export
 * @interface UserNote
 */
export interface UserNote {
    /**
     * 
     * @type {string}
     * @memberof UserNote
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserNote
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserNote
     */
    'note': string;
    /**
     * 
     * @type {UserNoteTargetUser}
     * @memberof UserNote
     */
    'targetUser'?: UserNoteTargetUser;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof UserNote
     */
    'targetUserId': string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof UserNote
     */
    'userId': string;
}
/**
 * 
 * @export
 * @interface UserNoteTargetUser
 */
export interface UserNoteTargetUser {
    /**
     * 
     * @type {Array<string>}
     * @memberof UserNoteTargetUser
     */
    'currentAvatarTags'?: Array<string>;
    /**
     * When profilePicOverride is not empty, use it instead.
     * @type {string}
     * @memberof UserNoteTargetUser
     */
    'currentAvatarThumbnailImageUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserNoteTargetUser
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserNoteTargetUser
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserNoteTargetUser
     */
    'profilePicOverride'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserNoteTargetUser
     */
    'userIcon'?: string;
}
/**
 * * \"online\" User is online in VRChat * \"active\" User is online, but not in VRChat * \"offline\" User is offline  Always offline when returned through `getCurrentUser` (/auth/user).
 * @export
 * @enum {string}
 */

export const UserState = {
    Offline: 'offline',
    Active: 'active',
    Online: 'online'
} as const;

export type UserState = typeof UserState[keyof typeof UserState];


/**
 * Defines the User\'s current status, for example \"ask me\", \"join me\" or \"offline. This status is a combined indicator of their online activity and privacy preference.
 * @export
 * @enum {string}
 */

export const UserStatus = {
    Active: 'active',
    JoinMe: 'join me',
    AskMe: 'ask me',
    Busy: 'busy',
    Offline: 'offline'
} as const;

export type UserStatus = typeof UserStatus[keyof typeof UserStatus];


/**
 * 
 * @export
 * @interface UserSubscription
 */
export interface UserSubscription {
    /**
     * 
     * @type {string}
     * @memberof UserSubscription
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserSubscription
     */
    'transactionId': string;
    /**
     * Which \"Store\" it came from. Right now only Stores are \"Steam\" and \"Admin\".
     * @type {string}
     * @memberof UserSubscription
     */
    'store': string;
    /**
     * 
     * @type {string}
     * @memberof UserSubscription
     */
    'steamItemId'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserSubscription
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof UserSubscription
     */
    'description': string;
    /**
     * 
     * @type {SubscriptionPeriod}
     * @memberof UserSubscription
     */
    'period': SubscriptionPeriod;
    /**
     * 
     * @type {number}
     * @memberof UserSubscription
     */
    'tier': number;
    /**
     * 
     * @type {boolean}
     * @memberof UserSubscription
     */
    'active': boolean;
    /**
     * 
     * @type {TransactionStatus}
     * @memberof UserSubscription
     */
    'status': TransactionStatus;
    /**
     * 
     * @type {string}
     * @memberof UserSubscription
     */
    'starts'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSubscription
     */
    'expires': string;
    /**
     * 
     * @type {string}
     * @memberof UserSubscription
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof UserSubscription
     */
    'updated_at': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserSubscription
     */
    'licenseGroups': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof UserSubscription
     */
    'isGift': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserSubscription
     */
    'isBulkGift': boolean;
}
/**
 * 
 * @export
 * @interface Verify2FAEmailCodeResult
 */
export interface Verify2FAEmailCodeResult {
    /**
     * 
     * @type {boolean}
     * @memberof Verify2FAEmailCodeResult
     */
    'verified': boolean;
}
/**
 * 
 * @export
 * @interface Verify2FAResult
 */
export interface Verify2FAResult {
    /**
     * 
     * @type {boolean}
     * @memberof Verify2FAResult
     */
    'verified': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Verify2FAResult
     */
    'enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface VerifyAuthTokenResult
 */
export interface VerifyAuthTokenResult {
    /**
     * 
     * @type {boolean}
     * @memberof VerifyAuthTokenResult
     */
    'ok': boolean;
    /**
     * 
     * @type {string}
     * @memberof VerifyAuthTokenResult
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface World
 */
export interface World {
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof World
     */
    'authorId': string;
    /**
     * 
     * @type {string}
     * @memberof World
     */
    'authorName': string;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    'capacity': number;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    'recommendedCapacity': number;
    /**
     * 
     * @type {string}
     * @memberof World
     */
    'created_at': string;
    /**
     * 
     * @type {InstanceContentSettings}
     * @memberof World
     */
    'defaultContentSettings'?: InstanceContentSettings;
    /**
     * 
     * @type {string}
     * @memberof World
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    'favorites'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof World
     */
    'featured': boolean;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    'heat': number;
    /**
     * WorldID be \"offline\" on User profiles if you are not friends with that user.
     * @type {string}
     * @memberof World
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof World
     */
    'imageUrl': string;
    /**
     * Will always be an empty list when unauthenticated.
     * @type {Array<Array<any>>}
     * @memberof World
     */
    'instances'?: Array<Array<any>>;
    /**
     * 
     * @type {string}
     * @memberof World
     */
    'labsPublicationDate': string;
    /**
     * 
     * @type {string}
     * @memberof World
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof World
     */
    'namespace'?: string;
    /**
     * Will always be `0` when unauthenticated.
     * @type {number}
     * @memberof World
     */
    'occupants'?: number;
    /**
     * 
     * @type {string}
     * @memberof World
     */
    'organization': string;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    'popularity': number;
    /**
     * 
     * @type {string}
     * @memberof World
     */
    'previewYoutubeId'?: string | null;
    /**
     * Will always be `0` when unauthenticated.
     * @type {number}
     * @memberof World
     */
    'privateOccupants'?: number;
    /**
     * Will always be `0` when unauthenticated.
     * @type {number}
     * @memberof World
     */
    'publicOccupants'?: number;
    /**
     * 
     * @type {string}
     * @memberof World
     */
    'publicationDate': string;
    /**
     * 
     * @type {ReleaseStatus}
     * @memberof World
     */
    'releaseStatus': ReleaseStatus;
    /**
     * 
     * @type {string}
     * @memberof World
     */
    'storeId'?: string;
    /**
     *  
     * @type {Array<string>}
     * @memberof World
     */
    'tags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof World
     */
    'thumbnailImageUrl': string;
    /**
     * Empty if unauthenticated.
     * @type {Array<UnityPackage>}
     * @memberof World
     */
    'unityPackages'?: Array<UnityPackage>;
    /**
     * 
     * @type {string}
     * @memberof World
     */
    'updated_at': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof World
     */
    'urlList'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    'version': number;
    /**
     * 
     * @type {number}
     * @memberof World
     */
    'visits': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof World
     */
    'udonProducts'?: Array<string>;
}
/**
 * 
 * @export
 * @interface WorldMetadata
 */
export interface WorldMetadata {
    /**
     * WorldID be \"offline\" on User profiles if you are not friends with that user.
     * @type {string}
     * @memberof WorldMetadata
     */
    'id': string;
    /**
     * 
     * @type {object}
     * @memberof WorldMetadata
     */
    'metadata': object;
}
/**
 * 
 * @export
 * @interface WorldPublishStatus
 */
export interface WorldPublishStatus {
    /**
     * 
     * @type {boolean}
     * @memberof WorldPublishStatus
     */
    'canPublish': boolean;
}

/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancels the sequence for enabling time-based 2FA.
         * @summary Cancel pending enabling of time-based 2FA codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPending2FA: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/twofactorauth/totp/pending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks if a user by a given `username`, `displayName` or `email` exist. This is used during registration to check if a username has already been taken, during change of displayName to check if a displayName is available, and during change of email to check if the email is already used. In the later two cases the `excludeUserId` is used to exclude oneself, otherwise the result would always be true.  It is **REQUIRED** to include **AT LEAST** `username`, `displayName` **or** `email` query parameter. Although they can be combined - in addition with `excludeUserId` (generally to exclude yourself) - to further fine-tune the search.
         * @summary Check User Exists
         * @param {string} [email] Filter by email.
         * @param {string} [displayName] Filter by displayName.
         * @param {string} [username] Filter by Username.
         * @param {string} [excludeUserId] Exclude by UserID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUserExists: async (email?: string, displayName?: string, username?: string, excludeUserId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/exists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (displayName !== undefined) {
                localVarQueryParameter['displayName'] = displayName;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (excludeUserId !== undefined) {
                localVarQueryParameter['excludeUserId'] = excludeUserId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Confirms the email address for a user
         * @summary Confirm Email
         * @param {string} id Target user for which to verify email.
         * @param {string} verifyEmail Token to verify email.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmEmail: async (id: string, verifyEmail: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('confirmEmail', 'id', id)
            // verify required parameter 'verifyEmail' is not null or undefined
            assertParamExists('confirmEmail', 'verifyEmail', verifyEmail)
            const localVarPath = `/auth/confirmEmail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (verifyEmail !== undefined) {
                localVarQueryParameter['verify_email'] = verifyEmail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the account with given ID. Normal users only have permission to delete their own account. Account deletion is 14 days from this request, and will be cancelled if you do an authenticated request with the account afterwards.  **VRC+ NOTE:** Despite the 14-days cooldown, any VRC+ subscription will be cancelled **immediately**.  **METHOD NOTE:** Despite this being a Delete action, the method type required is PUT.
         * @summary Delete User
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUser', 'userId', userId)
            const localVarPath = `/users/{userId}/delete`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disables 2FA for the currently logged in account
         * @summary Disable 2FA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disable2FA: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/twofactorauth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Begins the sequence for enabling time-based 2FA.
         * @summary Enable time-based 2FA codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enable2FA: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/twofactorauth/totp/pending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint does the following two operations:   1) Checks if you are already logged in by looking for a valid `auth` cookie. If you are have a valid auth cookie then no additional auth-related actions are taken. If you are **not** logged in then it will log you in with the `Authorization` header and set the `auth` cookie. The `auth` cookie will only be sent once.   2) If logged in, this function will also return the CurrentUser object containing detailed information about the currently logged in user.  The auth string after `Authorization: Basic {string}` is a base64-encoded string of the username and password, both individually url-encoded, and then joined with a colon.    > base64(urlencode(username):urlencode(password))  **WARNING: Session Limit:** Each authentication with login credentials counts as a separate session, out of which you have a limited amount. Make sure to save and reuse the `auth` cookie if you are often restarting the program. The provided API libraries automatically save cookies during runtime, but does not persist during restart. While it can be fine to use username/password during development, expect in production to very fast run into the rate-limit and be temporarily blocked from making new sessions until older ones expire. The exact number of simultaneous sessions is unknown/undisclosed.
         * @summary Login and/or Get Current User Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            // authentication authHeader required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication twoFactorAuthCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the OTP (One Time Password) recovery codes for accounts with 2FA-protection enabled.
         * @summary Get 2FA Recovery codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecoveryCodes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/user/twofactorauth/otp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalidates the login session.
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ~~Register a new user account.~~  **DEPRECATED:** Automated creation of accounts has no legitimate public third-party use case, and would be in violation of ToS 13.2: *By using the Platform, you agree not to: i. [...] use the Platform in a manner inconsistent with individual human usage* This endpoint is documented in the interest of completeness
         * @summary Register User Account
         * @param {RegisterUserAccountRequest} registerUserAccountRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        registerUserAccount: async (registerUserAccountRequest: RegisterUserAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerUserAccountRequest' is not null or undefined
            assertParamExists('registerUserAccount', 'registerUserAccountRequest', registerUserAccountRequest)
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerUserAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests a resend of pending email address confirmation email
         * @summary Resend Email Confirmation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEmailConfirmation: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/user/resendEmail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finishes the login sequence with a normal 2FA-generated code for accounts with 2FA-protection enabled.
         * @summary Verify 2FA code
         * @param {TwoFactorAuthCode} twoFactorAuthCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify2FA: async (twoFactorAuthCode: TwoFactorAuthCode, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'twoFactorAuthCode' is not null or undefined
            assertParamExists('verify2FA', 'twoFactorAuthCode', twoFactorAuthCode)
            const localVarPath = `/auth/twofactorauth/totp/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twoFactorAuthCode, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finishes the login sequence with an 2FA email code.
         * @summary Verify 2FA email code
         * @param {TwoFactorEmailCode} twoFactorEmailCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify2FAEmailCode: async (twoFactorEmailCode: TwoFactorEmailCode, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'twoFactorEmailCode' is not null or undefined
            assertParamExists('verify2FAEmailCode', 'twoFactorEmailCode', twoFactorEmailCode)
            const localVarPath = `/auth/twofactorauth/emailotp/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twoFactorEmailCode, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify whether the currently provided Auth Token is valid.
         * @summary Verify Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAuthToken: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies a login attempt for a user
         * @summary Verify Login Place
         * @param {string} token Token to verify login attempt.
         * @param {string} [userId] Filter by UserID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyLoginPlace: async (token: string, userId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('verifyLoginPlace', 'token', token)
            const localVarPath = `/auth/verifyLoginPlace`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finishes sequence for enabling time-based 2FA.
         * @summary Verify Pending 2FA code
         * @param {TwoFactorAuthCode} twoFactorAuthCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyPending2FA: async (twoFactorAuthCode: TwoFactorAuthCode, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'twoFactorAuthCode' is not null or undefined
            assertParamExists('verifyPending2FA', 'twoFactorAuthCode', twoFactorAuthCode)
            const localVarPath = `/auth/twofactorauth/totp/pending/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twoFactorAuthCode, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finishes the login sequence with an OTP (One Time Password) recovery code for accounts with 2FA-protection enabled.
         * @summary Verify 2FA code with Recovery code
         * @param {TwoFactorAuthCode} twoFactorAuthCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyRecoveryCode: async (twoFactorAuthCode: TwoFactorAuthCode, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'twoFactorAuthCode' is not null or undefined
            assertParamExists('verifyRecoveryCode', 'twoFactorAuthCode', twoFactorAuthCode)
            const localVarPath = `/auth/twofactorauth/otp/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twoFactorAuthCode, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancels the sequence for enabling time-based 2FA.
         * @summary Cancel pending enabling of time-based 2FA codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelPending2FA(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Disable2FAResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelPending2FA(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Checks if a user by a given `username`, `displayName` or `email` exist. This is used during registration to check if a username has already been taken, during change of displayName to check if a displayName is available, and during change of email to check if the email is already used. In the later two cases the `excludeUserId` is used to exclude oneself, otherwise the result would always be true.  It is **REQUIRED** to include **AT LEAST** `username`, `displayName` **or** `email` query parameter. Although they can be combined - in addition with `excludeUserId` (generally to exclude yourself) - to further fine-tune the search.
         * @summary Check User Exists
         * @param {string} [email] Filter by email.
         * @param {string} [displayName] Filter by displayName.
         * @param {string} [username] Filter by Username.
         * @param {string} [excludeUserId] Exclude by UserID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkUserExists(email?: string, displayName?: string, username?: string, excludeUserId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserExists>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkUserExists(email, displayName, username, excludeUserId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Confirms the email address for a user
         * @summary Confirm Email
         * @param {string} id Target user for which to verify email.
         * @param {string} verifyEmail Token to verify email.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmEmail(id: string, verifyEmail: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmEmail(id, verifyEmail, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the account with given ID. Normal users only have permission to delete their own account. Account deletion is 14 days from this request, and will be cancelled if you do an authenticated request with the account afterwards.  **VRC+ NOTE:** Despite the 14-days cooldown, any VRC+ subscription will be cancelled **immediately**.  **METHOD NOTE:** Despite this being a Delete action, the method type required is PUT.
         * @summary Delete User
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Disables 2FA for the currently logged in account
         * @summary Disable 2FA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disable2FA(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Disable2FAResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disable2FA(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Begins the sequence for enabling time-based 2FA.
         * @summary Enable time-based 2FA codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enable2FA(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pending2FAResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enable2FA(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint does the following two operations:   1) Checks if you are already logged in by looking for a valid `auth` cookie. If you are have a valid auth cookie then no additional auth-related actions are taken. If you are **not** logged in then it will log you in with the `Authorization` header and set the `auth` cookie. The `auth` cookie will only be sent once.   2) If logged in, this function will also return the CurrentUser object containing detailed information about the currently logged in user.  The auth string after `Authorization: Basic {string}` is a base64-encoded string of the username and password, both individually url-encoded, and then joined with a colon.    > base64(urlencode(username):urlencode(password))  **WARNING: Session Limit:** Each authentication with login credentials counts as a separate session, out of which you have a limited amount. Make sure to save and reuse the `auth` cookie if you are often restarting the program. The provided API libraries automatically save cookies during runtime, but does not persist during restart. While it can be fine to use username/password during development, expect in production to very fast run into the rate-limit and be temporarily blocked from making new sessions until older ones expire. The exact number of simultaneous sessions is unknown/undisclosed.
         * @summary Login and/or Get Current User Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the OTP (One Time Password) recovery codes for accounts with 2FA-protection enabled.
         * @summary Get 2FA Recovery codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecoveryCodes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TwoFactorRecoveryCodes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecoveryCodes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Invalidates the login session.
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ~~Register a new user account.~~  **DEPRECATED:** Automated creation of accounts has no legitimate public third-party use case, and would be in violation of ToS 13.2: *By using the Platform, you agree not to: i. [...] use the Platform in a manner inconsistent with individual human usage* This endpoint is documented in the interest of completeness
         * @summary Register User Account
         * @param {RegisterUserAccountRequest} registerUserAccountRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async registerUserAccount(registerUserAccountRequest: RegisterUserAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUserAccount(registerUserAccountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Requests a resend of pending email address confirmation email
         * @summary Resend Email Confirmation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendEmailConfirmation(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendEmailConfirmation(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Finishes the login sequence with a normal 2FA-generated code for accounts with 2FA-protection enabled.
         * @summary Verify 2FA code
         * @param {TwoFactorAuthCode} twoFactorAuthCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verify2FA(twoFactorAuthCode: TwoFactorAuthCode, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Verify2FAResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verify2FA(twoFactorAuthCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Finishes the login sequence with an 2FA email code.
         * @summary Verify 2FA email code
         * @param {TwoFactorEmailCode} twoFactorEmailCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verify2FAEmailCode(twoFactorEmailCode: TwoFactorEmailCode, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Verify2FAEmailCodeResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verify2FAEmailCode(twoFactorEmailCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Verify whether the currently provided Auth Token is valid.
         * @summary Verify Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyAuthToken(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerifyAuthTokenResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyAuthToken(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Verifies a login attempt for a user
         * @summary Verify Login Place
         * @param {string} token Token to verify login attempt.
         * @param {string} [userId] Filter by UserID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyLoginPlace(token: string, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyLoginPlace(token, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Finishes sequence for enabling time-based 2FA.
         * @summary Verify Pending 2FA code
         * @param {TwoFactorAuthCode} twoFactorAuthCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyPending2FA(twoFactorAuthCode: TwoFactorAuthCode, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Verify2FAResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyPending2FA(twoFactorAuthCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Finishes the login sequence with an OTP (One Time Password) recovery code for accounts with 2FA-protection enabled.
         * @summary Verify 2FA code with Recovery code
         * @param {TwoFactorAuthCode} twoFactorAuthCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyRecoveryCode(twoFactorAuthCode: TwoFactorAuthCode, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Verify2FAResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyRecoveryCode(twoFactorAuthCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * Cancels the sequence for enabling time-based 2FA.
         * @summary Cancel pending enabling of time-based 2FA codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPending2FA(options?: any): AxiosPromise<Disable2FAResult> {
            return localVarFp.cancelPending2FA(options).then((request) => request(axios, basePath));
        },
        /**
         * Checks if a user by a given `username`, `displayName` or `email` exist. This is used during registration to check if a username has already been taken, during change of displayName to check if a displayName is available, and during change of email to check if the email is already used. In the later two cases the `excludeUserId` is used to exclude oneself, otherwise the result would always be true.  It is **REQUIRED** to include **AT LEAST** `username`, `displayName` **or** `email` query parameter. Although they can be combined - in addition with `excludeUserId` (generally to exclude yourself) - to further fine-tune the search.
         * @summary Check User Exists
         * @param {string} [email] Filter by email.
         * @param {string} [displayName] Filter by displayName.
         * @param {string} [username] Filter by Username.
         * @param {string} [excludeUserId] Exclude by UserID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUserExists(email?: string, displayName?: string, username?: string, excludeUserId?: string, options?: any): AxiosPromise<UserExists> {
            return localVarFp.checkUserExists(email, displayName, username, excludeUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Confirms the email address for a user
         * @summary Confirm Email
         * @param {string} id Target user for which to verify email.
         * @param {string} verifyEmail Token to verify email.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmEmail(id: string, verifyEmail: string, options?: any): AxiosPromise<void> {
            return localVarFp.confirmEmail(id, verifyEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the account with given ID. Normal users only have permission to delete their own account. Account deletion is 14 days from this request, and will be cancelled if you do an authenticated request with the account afterwards.  **VRC+ NOTE:** Despite the 14-days cooldown, any VRC+ subscription will be cancelled **immediately**.  **METHOD NOTE:** Despite this being a Delete action, the method type required is PUT.
         * @summary Delete User
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: string, options?: any): AxiosPromise<CurrentUser> {
            return localVarFp.deleteUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Disables 2FA for the currently logged in account
         * @summary Disable 2FA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disable2FA(options?: any): AxiosPromise<Disable2FAResult> {
            return localVarFp.disable2FA(options).then((request) => request(axios, basePath));
        },
        /**
         * Begins the sequence for enabling time-based 2FA.
         * @summary Enable time-based 2FA codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enable2FA(options?: any): AxiosPromise<Pending2FAResult> {
            return localVarFp.enable2FA(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint does the following two operations:   1) Checks if you are already logged in by looking for a valid `auth` cookie. If you are have a valid auth cookie then no additional auth-related actions are taken. If you are **not** logged in then it will log you in with the `Authorization` header and set the `auth` cookie. The `auth` cookie will only be sent once.   2) If logged in, this function will also return the CurrentUser object containing detailed information about the currently logged in user.  The auth string after `Authorization: Basic {string}` is a base64-encoded string of the username and password, both individually url-encoded, and then joined with a colon.    > base64(urlencode(username):urlencode(password))  **WARNING: Session Limit:** Each authentication with login credentials counts as a separate session, out of which you have a limited amount. Make sure to save and reuse the `auth` cookie if you are often restarting the program. The provided API libraries automatically save cookies during runtime, but does not persist during restart. While it can be fine to use username/password during development, expect in production to very fast run into the rate-limit and be temporarily blocked from making new sessions until older ones expire. The exact number of simultaneous sessions is unknown/undisclosed.
         * @summary Login and/or Get Current User Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: any): AxiosPromise<CurrentUser> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the OTP (One Time Password) recovery codes for accounts with 2FA-protection enabled.
         * @summary Get 2FA Recovery codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecoveryCodes(options?: any): AxiosPromise<TwoFactorRecoveryCodes> {
            return localVarFp.getRecoveryCodes(options).then((request) => request(axios, basePath));
        },
        /**
         * Invalidates the login session.
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<Success> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * ~~Register a new user account.~~  **DEPRECATED:** Automated creation of accounts has no legitimate public third-party use case, and would be in violation of ToS 13.2: *By using the Platform, you agree not to: i. [...] use the Platform in a manner inconsistent with individual human usage* This endpoint is documented in the interest of completeness
         * @summary Register User Account
         * @param {RegisterUserAccountRequest} registerUserAccountRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        registerUserAccount(registerUserAccountRequest: RegisterUserAccountRequest, options?: any): AxiosPromise<CurrentUser> {
            return localVarFp.registerUserAccount(registerUserAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Requests a resend of pending email address confirmation email
         * @summary Resend Email Confirmation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEmailConfirmation(options?: any): AxiosPromise<Success> {
            return localVarFp.resendEmailConfirmation(options).then((request) => request(axios, basePath));
        },
        /**
         * Finishes the login sequence with a normal 2FA-generated code for accounts with 2FA-protection enabled.
         * @summary Verify 2FA code
         * @param {TwoFactorAuthCode} twoFactorAuthCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify2FA(twoFactorAuthCode: TwoFactorAuthCode, options?: any): AxiosPromise<Verify2FAResult> {
            return localVarFp.verify2FA(twoFactorAuthCode, options).then((request) => request(axios, basePath));
        },
        /**
         * Finishes the login sequence with an 2FA email code.
         * @summary Verify 2FA email code
         * @param {TwoFactorEmailCode} twoFactorEmailCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify2FAEmailCode(twoFactorEmailCode: TwoFactorEmailCode, options?: any): AxiosPromise<Verify2FAEmailCodeResult> {
            return localVarFp.verify2FAEmailCode(twoFactorEmailCode, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify whether the currently provided Auth Token is valid.
         * @summary Verify Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAuthToken(options?: any): AxiosPromise<VerifyAuthTokenResult> {
            return localVarFp.verifyAuthToken(options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies a login attempt for a user
         * @summary Verify Login Place
         * @param {string} token Token to verify login attempt.
         * @param {string} [userId] Filter by UserID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyLoginPlace(token: string, userId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.verifyLoginPlace(token, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Finishes sequence for enabling time-based 2FA.
         * @summary Verify Pending 2FA code
         * @param {TwoFactorAuthCode} twoFactorAuthCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyPending2FA(twoFactorAuthCode: TwoFactorAuthCode, options?: any): AxiosPromise<Verify2FAResult> {
            return localVarFp.verifyPending2FA(twoFactorAuthCode, options).then((request) => request(axios, basePath));
        },
        /**
         * Finishes the login sequence with an OTP (One Time Password) recovery code for accounts with 2FA-protection enabled.
         * @summary Verify 2FA code with Recovery code
         * @param {TwoFactorAuthCode} twoFactorAuthCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyRecoveryCode(twoFactorAuthCode: TwoFactorAuthCode, options?: any): AxiosPromise<Verify2FAResult> {
            return localVarFp.verifyRecoveryCode(twoFactorAuthCode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * Cancels the sequence for enabling time-based 2FA.
     * @summary Cancel pending enabling of time-based 2FA codes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public cancelPending2FA(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).cancelPending2FA(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks if a user by a given `username`, `displayName` or `email` exist. This is used during registration to check if a username has already been taken, during change of displayName to check if a displayName is available, and during change of email to check if the email is already used. In the later two cases the `excludeUserId` is used to exclude oneself, otherwise the result would always be true.  It is **REQUIRED** to include **AT LEAST** `username`, `displayName` **or** `email` query parameter. Although they can be combined - in addition with `excludeUserId` (generally to exclude yourself) - to further fine-tune the search.
     * @summary Check User Exists
     * @param {string} [email] Filter by email.
     * @param {string} [displayName] Filter by displayName.
     * @param {string} [username] Filter by Username.
     * @param {string} [excludeUserId] Exclude by UserID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public checkUserExists(email?: string, displayName?: string, username?: string, excludeUserId?: string, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).checkUserExists(email, displayName, username, excludeUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Confirms the email address for a user
     * @summary Confirm Email
     * @param {string} id Target user for which to verify email.
     * @param {string} verifyEmail Token to verify email.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public confirmEmail(id: string, verifyEmail: string, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).confirmEmail(id, verifyEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the account with given ID. Normal users only have permission to delete their own account. Account deletion is 14 days from this request, and will be cancelled if you do an authenticated request with the account afterwards.  **VRC+ NOTE:** Despite the 14-days cooldown, any VRC+ subscription will be cancelled **immediately**.  **METHOD NOTE:** Despite this being a Delete action, the method type required is PUT.
     * @summary Delete User
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public deleteUser(userId: string, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).deleteUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disables 2FA for the currently logged in account
     * @summary Disable 2FA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public disable2FA(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).disable2FA(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Begins the sequence for enabling time-based 2FA.
     * @summary Enable time-based 2FA codes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public enable2FA(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).enable2FA(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint does the following two operations:   1) Checks if you are already logged in by looking for a valid `auth` cookie. If you are have a valid auth cookie then no additional auth-related actions are taken. If you are **not** logged in then it will log you in with the `Authorization` header and set the `auth` cookie. The `auth` cookie will only be sent once.   2) If logged in, this function will also return the CurrentUser object containing detailed information about the currently logged in user.  The auth string after `Authorization: Basic {string}` is a base64-encoded string of the username and password, both individually url-encoded, and then joined with a colon.    > base64(urlencode(username):urlencode(password))  **WARNING: Session Limit:** Each authentication with login credentials counts as a separate session, out of which you have a limited amount. Make sure to save and reuse the `auth` cookie if you are often restarting the program. The provided API libraries automatically save cookies during runtime, but does not persist during restart. While it can be fine to use username/password during development, expect in production to very fast run into the rate-limit and be temporarily blocked from making new sessions until older ones expire. The exact number of simultaneous sessions is unknown/undisclosed.
     * @summary Login and/or Get Current User Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getCurrentUser(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the OTP (One Time Password) recovery codes for accounts with 2FA-protection enabled.
     * @summary Get 2FA Recovery codes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getRecoveryCodes(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).getRecoveryCodes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invalidates the login session.
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public logout(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ~~Register a new user account.~~  **DEPRECATED:** Automated creation of accounts has no legitimate public third-party use case, and would be in violation of ToS 13.2: *By using the Platform, you agree not to: i. [...] use the Platform in a manner inconsistent with individual human usage* This endpoint is documented in the interest of completeness
     * @summary Register User Account
     * @param {RegisterUserAccountRequest} registerUserAccountRequest 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public registerUserAccount(registerUserAccountRequest: RegisterUserAccountRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).registerUserAccount(registerUserAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requests a resend of pending email address confirmation email
     * @summary Resend Email Confirmation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public resendEmailConfirmation(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).resendEmailConfirmation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Finishes the login sequence with a normal 2FA-generated code for accounts with 2FA-protection enabled.
     * @summary Verify 2FA code
     * @param {TwoFactorAuthCode} twoFactorAuthCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public verify2FA(twoFactorAuthCode: TwoFactorAuthCode, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).verify2FA(twoFactorAuthCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Finishes the login sequence with an 2FA email code.
     * @summary Verify 2FA email code
     * @param {TwoFactorEmailCode} twoFactorEmailCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public verify2FAEmailCode(twoFactorEmailCode: TwoFactorEmailCode, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).verify2FAEmailCode(twoFactorEmailCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify whether the currently provided Auth Token is valid.
     * @summary Verify Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public verifyAuthToken(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).verifyAuthToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verifies a login attempt for a user
     * @summary Verify Login Place
     * @param {string} token Token to verify login attempt.
     * @param {string} [userId] Filter by UserID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public verifyLoginPlace(token: string, userId?: string, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).verifyLoginPlace(token, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Finishes sequence for enabling time-based 2FA.
     * @summary Verify Pending 2FA code
     * @param {TwoFactorAuthCode} twoFactorAuthCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public verifyPending2FA(twoFactorAuthCode: TwoFactorAuthCode, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).verifyPending2FA(twoFactorAuthCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Finishes the login sequence with an OTP (One Time Password) recovery code for accounts with 2FA-protection enabled.
     * @summary Verify 2FA code with Recovery code
     * @param {TwoFactorAuthCode} twoFactorAuthCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public verifyRecoveryCode(twoFactorAuthCode: TwoFactorAuthCode, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).verifyRecoveryCode(twoFactorAuthCode, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AvatarsApi - axios parameter creator
 * @export
 */
export const AvatarsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an avatar. It\'s possible to optionally specify a ID if you want a custom one. Attempting to create an Avatar with an already claimed ID will result in a DB error.
         * @summary Create Avatar
         * @param {CreateAvatarRequest} [createAvatarRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAvatar: async (createAvatarRequest?: CreateAvatarRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/avatars`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAvatarRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an avatar. Notice an avatar is never fully \"deleted\", only its ReleaseStatus is set to \"hidden\" and the linked Files are deleted. The AvatarID is permanently reserved.
         * @summary Delete Avatar
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAvatar: async (avatarId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'avatarId' is not null or undefined
            assertParamExists('deleteAvatar', 'avatarId', avatarId)
            const localVarPath = `/avatars/{avatarId}`
                .replace(`{${"avatarId"}}`, encodeURIComponent(String(avatarId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete generated Impostor for that avatar.
         * @summary Delete generated Impostor
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImpostor: async (avatarId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'avatarId' is not null or undefined
            assertParamExists('deleteImpostor', 'avatarId', avatarId)
            const localVarPath = `/avatars/{avatarId}/impostor`
                .replace(`{${"avatarId"}}`, encodeURIComponent(String(avatarId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enqueue Impostor generation for that avatar.
         * @summary Enqueue Impostor generation
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enqueueImpostor: async (avatarId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'avatarId' is not null or undefined
            assertParamExists('enqueueImpostor', 'avatarId', avatarId)
            const localVarPath = `/avatars/{avatarId}/impostor/enqueue`
                .replace(`{${"avatarId"}}`, encodeURIComponent(String(avatarId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a specific Avatar.
         * @summary Get Avatar
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvatar: async (avatarId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'avatarId' is not null or undefined
            assertParamExists('getAvatar', 'avatarId', avatarId)
            const localVarPath = `/avatars/{avatarId}`
                .replace(`{${"avatarId"}}`, encodeURIComponent(String(avatarId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search and list favorited avatars by query filters.
         * @summary List Favorited Avatars
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [search] Filters by world name.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {string} [userId] Target user to see information on, admin-only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoritedAvatars: async (featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, userId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/avatars/favorites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            if (featured !== undefined) {
                localVarQueryParameter['featured'] = featured;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (n !== undefined) {
                localVarQueryParameter['n'] = n;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (notag !== undefined) {
                localVarQueryParameter['notag'] = notag;
            }

            if (releaseStatus !== undefined) {
                localVarQueryParameter['releaseStatus'] = releaseStatus;
            }

            if (maxUnityVersion !== undefined) {
                localVarQueryParameter['maxUnityVersion'] = maxUnityVersion;
            }

            if (minUnityVersion !== undefined) {
                localVarQueryParameter['minUnityVersion'] = minUnityVersion;
            }

            if (platform !== undefined) {
                localVarQueryParameter['platform'] = platform;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets service stats for queued impostor.
         * @summary Get Impostor Queue Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImpostorQueueStats: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/avatars/impostor/queue/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List licensed avatars.
         * @summary List Licensed Avatars
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicensedAvatars: async (n?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/avatars/licensed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            if (n !== undefined) {
                localVarQueryParameter['n'] = n;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current avatar for the user. This will return an error for any other user than the one logged in.
         * @summary Get Own Avatar
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOwnAvatar: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getOwnAvatar', 'userId', userId)
            const localVarPath = `/users/{userId}/avatar`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search and list avatars by query filters. You can only search your own or featured avatars. It is not possible as a normal user to search other peoples avatars.
         * @summary Search Avatars
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {'me'} [user] Set to &#x60;me&#x60; for searching own avatars.
         * @param {string} [userId] Filter by UserID.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAvatars: async (featured?: boolean, sort?: SortOption, user?: 'me', userId?: string, n?: number, order?: OrderOption, offset?: number, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/avatars`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            if (featured !== undefined) {
                localVarQueryParameter['featured'] = featured;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (n !== undefined) {
                localVarQueryParameter['n'] = n;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (notag !== undefined) {
                localVarQueryParameter['notag'] = notag;
            }

            if (releaseStatus !== undefined) {
                localVarQueryParameter['releaseStatus'] = releaseStatus;
            }

            if (maxUnityVersion !== undefined) {
                localVarQueryParameter['maxUnityVersion'] = maxUnityVersion;
            }

            if (minUnityVersion !== undefined) {
                localVarQueryParameter['minUnityVersion'] = minUnityVersion;
            }

            if (platform !== undefined) {
                localVarQueryParameter['platform'] = platform;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Switches into that avatar.
         * @summary Select Avatar
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        selectAvatar: async (avatarId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'avatarId' is not null or undefined
            assertParamExists('selectAvatar', 'avatarId', avatarId)
            const localVarPath = `/avatars/{avatarId}/select`
                .replace(`{${"avatarId"}}`, encodeURIComponent(String(avatarId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Switches into that avatar as your fallback avatar.
         * @summary Select Fallback Avatar
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        selectFallbackAvatar: async (avatarId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'avatarId' is not null or undefined
            assertParamExists('selectFallbackAvatar', 'avatarId', avatarId)
            const localVarPath = `/avatars/{avatarId}/selectFallback`
                .replace(`{${"avatarId"}}`, encodeURIComponent(String(avatarId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update information about a specific avatar.
         * @summary Update Avatar
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {UpdateAvatarRequest} [updateAvatarRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAvatar: async (avatarId: string, updateAvatarRequest?: UpdateAvatarRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'avatarId' is not null or undefined
            assertParamExists('updateAvatar', 'avatarId', avatarId)
            const localVarPath = `/avatars/{avatarId}`
                .replace(`{${"avatarId"}}`, encodeURIComponent(String(avatarId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAvatarRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AvatarsApi - functional programming interface
 * @export
 */
export const AvatarsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AvatarsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an avatar. It\'s possible to optionally specify a ID if you want a custom one. Attempting to create an Avatar with an already claimed ID will result in a DB error.
         * @summary Create Avatar
         * @param {CreateAvatarRequest} [createAvatarRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAvatar(createAvatarRequest?: CreateAvatarRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Avatar>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAvatar(createAvatarRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an avatar. Notice an avatar is never fully \"deleted\", only its ReleaseStatus is set to \"hidden\" and the linked Files are deleted. The AvatarID is permanently reserved.
         * @summary Delete Avatar
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAvatar(avatarId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Avatar>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAvatar(avatarId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete generated Impostor for that avatar.
         * @summary Delete generated Impostor
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteImpostor(avatarId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteImpostor(avatarId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enqueue Impostor generation for that avatar.
         * @summary Enqueue Impostor generation
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enqueueImpostor(avatarId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enqueueImpostor(avatarId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information about a specific Avatar.
         * @summary Get Avatar
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvatar(avatarId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Avatar>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvatar(avatarId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search and list favorited avatars by query filters.
         * @summary List Favorited Avatars
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [search] Filters by world name.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {string} [userId] Target user to see information on, admin-only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFavoritedAvatars(featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Avatar>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFavoritedAvatars(featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets service stats for queued impostor.
         * @summary Get Impostor Queue Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImpostorQueueStats(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceQueueStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImpostorQueueStats(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List licensed avatars.
         * @summary List Licensed Avatars
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLicensedAvatars(n?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Avatar>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLicensedAvatars(n, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the current avatar for the user. This will return an error for any other user than the one logged in.
         * @summary Get Own Avatar
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOwnAvatar(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Avatar>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOwnAvatar(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search and list avatars by query filters. You can only search your own or featured avatars. It is not possible as a normal user to search other peoples avatars.
         * @summary Search Avatars
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {'me'} [user] Set to &#x60;me&#x60; for searching own avatars.
         * @param {string} [userId] Filter by UserID.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAvatars(featured?: boolean, sort?: SortOption, user?: 'me', userId?: string, n?: number, order?: OrderOption, offset?: number, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Avatar>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchAvatars(featured, sort, user, userId, n, order, offset, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Switches into that avatar.
         * @summary Select Avatar
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async selectAvatar(avatarId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.selectAvatar(avatarId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Switches into that avatar as your fallback avatar.
         * @summary Select Fallback Avatar
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async selectFallbackAvatar(avatarId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.selectFallbackAvatar(avatarId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update information about a specific avatar.
         * @summary Update Avatar
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {UpdateAvatarRequest} [updateAvatarRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAvatar(avatarId: string, updateAvatarRequest?: UpdateAvatarRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Avatar>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAvatar(avatarId, updateAvatarRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AvatarsApi - factory interface
 * @export
 */
export const AvatarsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AvatarsApiFp(configuration)
    return {
        /**
         * Create an avatar. It\'s possible to optionally specify a ID if you want a custom one. Attempting to create an Avatar with an already claimed ID will result in a DB error.
         * @summary Create Avatar
         * @param {CreateAvatarRequest} [createAvatarRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAvatar(createAvatarRequest?: CreateAvatarRequest, options?: any): AxiosPromise<Avatar> {
            return localVarFp.createAvatar(createAvatarRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an avatar. Notice an avatar is never fully \"deleted\", only its ReleaseStatus is set to \"hidden\" and the linked Files are deleted. The AvatarID is permanently reserved.
         * @summary Delete Avatar
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAvatar(avatarId: string, options?: any): AxiosPromise<Avatar> {
            return localVarFp.deleteAvatar(avatarId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete generated Impostor for that avatar.
         * @summary Delete generated Impostor
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImpostor(avatarId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteImpostor(avatarId, options).then((request) => request(axios, basePath));
        },
        /**
         * Enqueue Impostor generation for that avatar.
         * @summary Enqueue Impostor generation
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enqueueImpostor(avatarId: string, options?: any): AxiosPromise<ServiceStatus> {
            return localVarFp.enqueueImpostor(avatarId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about a specific Avatar.
         * @summary Get Avatar
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvatar(avatarId: string, options?: any): AxiosPromise<Avatar> {
            return localVarFp.getAvatar(avatarId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search and list favorited avatars by query filters.
         * @summary List Favorited Avatars
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [search] Filters by world name.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {string} [userId] Target user to see information on, admin-only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoritedAvatars(featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, userId?: string, options?: any): AxiosPromise<Array<Avatar>> {
            return localVarFp.getFavoritedAvatars(featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets service stats for queued impostor.
         * @summary Get Impostor Queue Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImpostorQueueStats(options?: any): AxiosPromise<ServiceQueueStats> {
            return localVarFp.getImpostorQueueStats(options).then((request) => request(axios, basePath));
        },
        /**
         * List licensed avatars.
         * @summary List Licensed Avatars
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicensedAvatars(n?: number, offset?: number, options?: any): AxiosPromise<Array<Avatar>> {
            return localVarFp.getLicensedAvatars(n, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current avatar for the user. This will return an error for any other user than the one logged in.
         * @summary Get Own Avatar
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOwnAvatar(userId: string, options?: any): AxiosPromise<Avatar> {
            return localVarFp.getOwnAvatar(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search and list avatars by query filters. You can only search your own or featured avatars. It is not possible as a normal user to search other peoples avatars.
         * @summary Search Avatars
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {'me'} [user] Set to &#x60;me&#x60; for searching own avatars.
         * @param {string} [userId] Filter by UserID.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAvatars(featured?: boolean, sort?: SortOption, user?: 'me', userId?: string, n?: number, order?: OrderOption, offset?: number, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, options?: any): AxiosPromise<Array<Avatar>> {
            return localVarFp.searchAvatars(featured, sort, user, userId, n, order, offset, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, options).then((request) => request(axios, basePath));
        },
        /**
         * Switches into that avatar.
         * @summary Select Avatar
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        selectAvatar(avatarId: string, options?: any): AxiosPromise<CurrentUser> {
            return localVarFp.selectAvatar(avatarId, options).then((request) => request(axios, basePath));
        },
        /**
         * Switches into that avatar as your fallback avatar.
         * @summary Select Fallback Avatar
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        selectFallbackAvatar(avatarId: string, options?: any): AxiosPromise<CurrentUser> {
            return localVarFp.selectFallbackAvatar(avatarId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update information about a specific avatar.
         * @summary Update Avatar
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {UpdateAvatarRequest} [updateAvatarRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAvatar(avatarId: string, updateAvatarRequest?: UpdateAvatarRequest, options?: any): AxiosPromise<Avatar> {
            return localVarFp.updateAvatar(avatarId, updateAvatarRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AvatarsApi - object-oriented interface
 * @export
 * @class AvatarsApi
 * @extends {BaseAPI}
 */
export class AvatarsApi extends BaseAPI {
    /**
     * Create an avatar. It\'s possible to optionally specify a ID if you want a custom one. Attempting to create an Avatar with an already claimed ID will result in a DB error.
     * @summary Create Avatar
     * @param {CreateAvatarRequest} [createAvatarRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    public createAvatar(createAvatarRequest?: CreateAvatarRequest, options?: AxiosRequestConfig) {
        return AvatarsApiFp(this.configuration).createAvatar(createAvatarRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an avatar. Notice an avatar is never fully \"deleted\", only its ReleaseStatus is set to \"hidden\" and the linked Files are deleted. The AvatarID is permanently reserved.
     * @summary Delete Avatar
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    public deleteAvatar(avatarId: string, options?: AxiosRequestConfig) {
        return AvatarsApiFp(this.configuration).deleteAvatar(avatarId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete generated Impostor for that avatar.
     * @summary Delete generated Impostor
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    public deleteImpostor(avatarId: string, options?: AxiosRequestConfig) {
        return AvatarsApiFp(this.configuration).deleteImpostor(avatarId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enqueue Impostor generation for that avatar.
     * @summary Enqueue Impostor generation
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    public enqueueImpostor(avatarId: string, options?: AxiosRequestConfig) {
        return AvatarsApiFp(this.configuration).enqueueImpostor(avatarId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about a specific Avatar.
     * @summary Get Avatar
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    public getAvatar(avatarId: string, options?: AxiosRequestConfig) {
        return AvatarsApiFp(this.configuration).getAvatar(avatarId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search and list favorited avatars by query filters.
     * @summary List Favorited Avatars
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [search] Filters by world name.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {string} [userId] Target user to see information on, admin-only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    public getFavoritedAvatars(featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, userId?: string, options?: AxiosRequestConfig) {
        return AvatarsApiFp(this.configuration).getFavoritedAvatars(featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets service stats for queued impostor.
     * @summary Get Impostor Queue Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    public getImpostorQueueStats(options?: AxiosRequestConfig) {
        return AvatarsApiFp(this.configuration).getImpostorQueueStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List licensed avatars.
     * @summary List Licensed Avatars
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    public getLicensedAvatars(n?: number, offset?: number, options?: AxiosRequestConfig) {
        return AvatarsApiFp(this.configuration).getLicensedAvatars(n, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current avatar for the user. This will return an error for any other user than the one logged in.
     * @summary Get Own Avatar
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    public getOwnAvatar(userId: string, options?: AxiosRequestConfig) {
        return AvatarsApiFp(this.configuration).getOwnAvatar(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search and list avatars by query filters. You can only search your own or featured avatars. It is not possible as a normal user to search other peoples avatars.
     * @summary Search Avatars
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {'me'} [user] Set to &#x60;me&#x60; for searching own avatars.
     * @param {string} [userId] Filter by UserID.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    public searchAvatars(featured?: boolean, sort?: SortOption, user?: 'me', userId?: string, n?: number, order?: OrderOption, offset?: number, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, options?: AxiosRequestConfig) {
        return AvatarsApiFp(this.configuration).searchAvatars(featured, sort, user, userId, n, order, offset, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Switches into that avatar.
     * @summary Select Avatar
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    public selectAvatar(avatarId: string, options?: AxiosRequestConfig) {
        return AvatarsApiFp(this.configuration).selectAvatar(avatarId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Switches into that avatar as your fallback avatar.
     * @summary Select Fallback Avatar
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    public selectFallbackAvatar(avatarId: string, options?: AxiosRequestConfig) {
        return AvatarsApiFp(this.configuration).selectFallbackAvatar(avatarId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update information about a specific avatar.
     * @summary Update Avatar
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {UpdateAvatarRequest} [updateAvatarRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    public updateAvatar(avatarId: string, updateAvatarRequest?: UpdateAvatarRequest, options?: AxiosRequestConfig) {
        return AvatarsApiFp(this.configuration).updateAvatar(avatarId, updateAvatarRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EconomyApi - axios parameter creator
 * @export
 */
export const EconomyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets the balance of a user
         * @summary Get Balance
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getBalance', 'userId', userId)
            const localVarPath = `/user/{userId}/balance`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all current user subscriptions.
         * @summary Get Current Subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentSubscriptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/user/subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single License Group by given ID.
         * @summary Get License Group
         * @param {string} licenseGroupId Must be a valid license group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenseGroup: async (licenseGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'licenseGroupId' is not null or undefined
            assertParamExists('getLicenseGroup', 'licenseGroupId', licenseGroupId)
            const localVarPath = `/licenseGroups/{licenseGroupId}`
                .replace(`{${"licenseGroupId"}}`, encodeURIComponent(String(licenseGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a product listing
         * @summary Get Product Listing
         * @param {string} productId Must be a valid product ID.
         * @param {boolean} [hydrate] Populates some fields and changes types of others for certain objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductListing: async (productId: string, hydrate?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProductListing', 'productId', productId)
            const localVarPath = `/listing/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            if (hydrate !== undefined) {
                localVarQueryParameter['hydrate'] = hydrate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the product listings of a given user
         * @summary Get User Product Listings
         * @param {string} userId Must be a valid user ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {boolean} [hydrate] Populates some fields and changes types of others for certain objects.
         * @param {string} [groupId] Must be a valid group ID.
         * @param {boolean} [active] Filter for users\&#39; listings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductListings: async (userId: string, n?: number, offset?: number, hydrate?: boolean, groupId?: string, active?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getProductListings', 'userId', userId)
            const localVarPath = `/user/{userId}/listings`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            if (n !== undefined) {
                localVarQueryParameter['n'] = n;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (hydrate !== undefined) {
                localVarQueryParameter['hydrate'] = hydrate;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['groupId'] = groupId;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single Steam transactions by ID. This returns the exact same information as `getSteamTransactions`, so no point in using this endpoint.
         * @summary Get Steam Transaction
         * @param {string} transactionId Must be a valid transaction ID.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getSteamTransaction: async (transactionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('getSteamTransaction', 'transactionId', transactionId)
            const localVarPath = `/Steam/transactions/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all own Steam transactions.
         * @summary List Steam Transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSteamTransactions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Steam/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all existing Subscriptions. For example, \"vrchatplus-monthly\" and \"vrchatplus-yearly\".
         * @summary List Subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the status of Tilia integration
         * @summary Get Tilia Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTiliaStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tilia/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the status of the agreement of a user to the Tilia TOS
         * @summary Get Tilia TOS Agreement Status
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTiliaTos: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getTiliaTos', 'userId', userId)
            const localVarPath = `/user/{userId}/tilia/tos`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the list of token bundles
         * @summary List Token Bundles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenBundles: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tokenBundles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EconomyApi - functional programming interface
 * @export
 */
export const EconomyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EconomyApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets the balance of a user
         * @summary Get Balance
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalance(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Balance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBalance(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all current user subscriptions.
         * @summary Get Current Subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentSubscriptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserSubscription>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentSubscriptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single License Group by given ID.
         * @summary Get License Group
         * @param {string} licenseGroupId Must be a valid license group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLicenseGroup(licenseGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LicenseGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLicenseGroup(licenseGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a product listing
         * @summary Get Product Listing
         * @param {string} productId Must be a valid product ID.
         * @param {boolean} [hydrate] Populates some fields and changes types of others for certain objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductListing(productId: string, hydrate?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductListing>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductListing(productId, hydrate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the product listings of a given user
         * @summary Get User Product Listings
         * @param {string} userId Must be a valid user ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {boolean} [hydrate] Populates some fields and changes types of others for certain objects.
         * @param {string} [groupId] Must be a valid group ID.
         * @param {boolean} [active] Filter for users\&#39; listings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductListings(userId: string, n?: number, offset?: number, hydrate?: boolean, groupId?: string, active?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductListing>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductListings(userId, n, offset, hydrate, groupId, active, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single Steam transactions by ID. This returns the exact same information as `getSteamTransactions`, so no point in using this endpoint.
         * @summary Get Steam Transaction
         * @param {string} transactionId Must be a valid transaction ID.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getSteamTransaction(transactionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSteamTransaction(transactionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all own Steam transactions.
         * @summary List Steam Transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSteamTransactions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Transaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSteamTransactions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all existing Subscriptions. For example, \"vrchatplus-monthly\" and \"vrchatplus-yearly\".
         * @summary List Subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Subscription>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the status of Tilia integration
         * @summary Get Tilia Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTiliaStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TiliaStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTiliaStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the status of the agreement of a user to the Tilia TOS
         * @summary Get Tilia TOS Agreement Status
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTiliaTos(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TiliaTOS>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTiliaTos(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the list of token bundles
         * @summary List Token Bundles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokenBundles(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TokenBundle>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokenBundles(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EconomyApi - factory interface
 * @export
 */
export const EconomyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EconomyApiFp(configuration)
    return {
        /**
         * Gets the balance of a user
         * @summary Get Balance
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance(userId: string, options?: any): AxiosPromise<Balance> {
            return localVarFp.getBalance(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all current user subscriptions.
         * @summary Get Current Subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentSubscriptions(options?: any): AxiosPromise<Array<UserSubscription>> {
            return localVarFp.getCurrentSubscriptions(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single License Group by given ID.
         * @summary Get License Group
         * @param {string} licenseGroupId Must be a valid license group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenseGroup(licenseGroupId: string, options?: any): AxiosPromise<LicenseGroup> {
            return localVarFp.getLicenseGroup(licenseGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a product listing
         * @summary Get Product Listing
         * @param {string} productId Must be a valid product ID.
         * @param {boolean} [hydrate] Populates some fields and changes types of others for certain objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductListing(productId: string, hydrate?: boolean, options?: any): AxiosPromise<ProductListing> {
            return localVarFp.getProductListing(productId, hydrate, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the product listings of a given user
         * @summary Get User Product Listings
         * @param {string} userId Must be a valid user ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {boolean} [hydrate] Populates some fields and changes types of others for certain objects.
         * @param {string} [groupId] Must be a valid group ID.
         * @param {boolean} [active] Filter for users\&#39; listings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductListings(userId: string, n?: number, offset?: number, hydrate?: boolean, groupId?: string, active?: boolean, options?: any): AxiosPromise<Array<ProductListing>> {
            return localVarFp.getProductListings(userId, n, offset, hydrate, groupId, active, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single Steam transactions by ID. This returns the exact same information as `getSteamTransactions`, so no point in using this endpoint.
         * @summary Get Steam Transaction
         * @param {string} transactionId Must be a valid transaction ID.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getSteamTransaction(transactionId: string, options?: any): AxiosPromise<Transaction> {
            return localVarFp.getSteamTransaction(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all own Steam transactions.
         * @summary List Steam Transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSteamTransactions(options?: any): AxiosPromise<Array<Transaction>> {
            return localVarFp.getSteamTransactions(options).then((request) => request(axios, basePath));
        },
        /**
         * List all existing Subscriptions. For example, \"vrchatplus-monthly\" and \"vrchatplus-yearly\".
         * @summary List Subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptions(options?: any): AxiosPromise<Array<Subscription>> {
            return localVarFp.getSubscriptions(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the status of Tilia integration
         * @summary Get Tilia Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTiliaStatus(options?: any): AxiosPromise<TiliaStatus> {
            return localVarFp.getTiliaStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the status of the agreement of a user to the Tilia TOS
         * @summary Get Tilia TOS Agreement Status
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTiliaTos(userId: string, options?: any): AxiosPromise<TiliaTOS> {
            return localVarFp.getTiliaTos(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the list of token bundles
         * @summary List Token Bundles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenBundles(options?: any): AxiosPromise<Array<TokenBundle>> {
            return localVarFp.getTokenBundles(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EconomyApi - object-oriented interface
 * @export
 * @class EconomyApi
 * @extends {BaseAPI}
 */
export class EconomyApi extends BaseAPI {
    /**
     * Gets the balance of a user
     * @summary Get Balance
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public getBalance(userId: string, options?: AxiosRequestConfig) {
        return EconomyApiFp(this.configuration).getBalance(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all current user subscriptions.
     * @summary Get Current Subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public getCurrentSubscriptions(options?: AxiosRequestConfig) {
        return EconomyApiFp(this.configuration).getCurrentSubscriptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single License Group by given ID.
     * @summary Get License Group
     * @param {string} licenseGroupId Must be a valid license group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public getLicenseGroup(licenseGroupId: string, options?: AxiosRequestConfig) {
        return EconomyApiFp(this.configuration).getLicenseGroup(licenseGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a product listing
     * @summary Get Product Listing
     * @param {string} productId Must be a valid product ID.
     * @param {boolean} [hydrate] Populates some fields and changes types of others for certain objects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public getProductListing(productId: string, hydrate?: boolean, options?: AxiosRequestConfig) {
        return EconomyApiFp(this.configuration).getProductListing(productId, hydrate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the product listings of a given user
     * @summary Get User Product Listings
     * @param {string} userId Must be a valid user ID.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {boolean} [hydrate] Populates some fields and changes types of others for certain objects.
     * @param {string} [groupId] Must be a valid group ID.
     * @param {boolean} [active] Filter for users\&#39; listings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public getProductListings(userId: string, n?: number, offset?: number, hydrate?: boolean, groupId?: string, active?: boolean, options?: AxiosRequestConfig) {
        return EconomyApiFp(this.configuration).getProductListings(userId, n, offset, hydrate, groupId, active, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single Steam transactions by ID. This returns the exact same information as `getSteamTransactions`, so no point in using this endpoint.
     * @summary Get Steam Transaction
     * @param {string} transactionId Must be a valid transaction ID.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public getSteamTransaction(transactionId: string, options?: AxiosRequestConfig) {
        return EconomyApiFp(this.configuration).getSteamTransaction(transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all own Steam transactions.
     * @summary List Steam Transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public getSteamTransactions(options?: AxiosRequestConfig) {
        return EconomyApiFp(this.configuration).getSteamTransactions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all existing Subscriptions. For example, \"vrchatplus-monthly\" and \"vrchatplus-yearly\".
     * @summary List Subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public getSubscriptions(options?: AxiosRequestConfig) {
        return EconomyApiFp(this.configuration).getSubscriptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the status of Tilia integration
     * @summary Get Tilia Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public getTiliaStatus(options?: AxiosRequestConfig) {
        return EconomyApiFp(this.configuration).getTiliaStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the status of the agreement of a user to the Tilia TOS
     * @summary Get Tilia TOS Agreement Status
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public getTiliaTos(userId: string, options?: AxiosRequestConfig) {
        return EconomyApiFp(this.configuration).getTiliaTos(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the list of token bundles
     * @summary List Token Bundles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    public getTokenBundles(options?: AxiosRequestConfig) {
        return EconomyApiFp(this.configuration).getTokenBundles(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FavoritesApi - axios parameter creator
 * @export
 */
export const FavoritesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a new favorite.  Friend groups are named `group_0` through `group_3`. Avatar and World groups are named `avatars1` to `avatars4` and `worlds1` to `worlds4`.  You cannot add people whom you are not friends with to your friends list. Destroying a friendship removes the person as favorite on both sides.
         * @summary Add Favorite
         * @param {AddFavoriteRequest} [addFavoriteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFavorite: async (addFavoriteRequest?: AddFavoriteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/favorites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addFavoriteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clear ALL contents of a specific favorite group.
         * @summary Clear Favorite Group
         * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
         * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearFavoriteGroup: async (favoriteGroupType: 'world' | 'friend' | 'avatar', favoriteGroupName: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'favoriteGroupType' is not null or undefined
            assertParamExists('clearFavoriteGroup', 'favoriteGroupType', favoriteGroupType)
            // verify required parameter 'favoriteGroupName' is not null or undefined
            assertParamExists('clearFavoriteGroup', 'favoriteGroupName', favoriteGroupName)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('clearFavoriteGroup', 'userId', userId)
            const localVarPath = `/favorite/group/{favoriteGroupType}/{favoriteGroupName}/{userId}`
                .replace(`{${"favoriteGroupType"}}`, encodeURIComponent(String(favoriteGroupType)))
                .replace(`{${"favoriteGroupName"}}`, encodeURIComponent(String(favoriteGroupName)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch information about a specific favorite group.
         * @summary Show Favorite Group
         * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
         * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoriteGroup: async (favoriteGroupType: 'world' | 'friend' | 'avatar', favoriteGroupName: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'favoriteGroupType' is not null or undefined
            assertParamExists('getFavoriteGroup', 'favoriteGroupType', favoriteGroupType)
            // verify required parameter 'favoriteGroupName' is not null or undefined
            assertParamExists('getFavoriteGroup', 'favoriteGroupName', favoriteGroupName)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getFavoriteGroup', 'userId', userId)
            const localVarPath = `/favorite/group/{favoriteGroupType}/{favoriteGroupName}/{userId}`
                .replace(`{${"favoriteGroupType"}}`, encodeURIComponent(String(favoriteGroupType)))
                .replace(`{${"favoriteGroupName"}}`, encodeURIComponent(String(favoriteGroupName)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of favorite groups owned by a user. Returns the same information as `getFavoriteGroups`.
         * @summary List Favorite Groups
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [userId] Target user to see information on, admin-only.
         * @param {string} [ownerId] The owner of whoms favorite groups to return. Must be a UserID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoriteGroups: async (n?: number, offset?: number, userId?: string, ownerId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/favorite/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            if (n !== undefined) {
                localVarQueryParameter['n'] = n;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return information about a specific Favorite.
         * @summary Get Favorite Limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoriteLimits: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/user/favoritelimits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of favorites.
         * @summary List Favorites
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [type] The type of favorites to return, FavoriteType.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavorites: async (n?: number, offset?: number, type?: string, tag?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/favorites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            if (n !== undefined) {
                localVarQueryParameter['n'] = n;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a favorite from your favorites list.
         * @summary Remove Favorite
         * @param {string} favoriteId Must be a valid favorite ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFavorite: async (favoriteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'favoriteId' is not null or undefined
            assertParamExists('removeFavorite', 'favoriteId', favoriteId)
            const localVarPath = `/favorites/{favoriteId}`
                .replace(`{${"favoriteId"}}`, encodeURIComponent(String(favoriteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update information about a specific favorite group.
         * @summary Update Favorite Group
         * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
         * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
         * @param {string} userId Must be a valid user ID.
         * @param {UpdateFavoriteGroupRequest} [updateFavoriteGroupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFavoriteGroup: async (favoriteGroupType: 'world' | 'friend' | 'avatar', favoriteGroupName: string, userId: string, updateFavoriteGroupRequest?: UpdateFavoriteGroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'favoriteGroupType' is not null or undefined
            assertParamExists('updateFavoriteGroup', 'favoriteGroupType', favoriteGroupType)
            // verify required parameter 'favoriteGroupName' is not null or undefined
            assertParamExists('updateFavoriteGroup', 'favoriteGroupName', favoriteGroupName)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateFavoriteGroup', 'userId', userId)
            const localVarPath = `/favorite/group/{favoriteGroupType}/{favoriteGroupName}/{userId}`
                .replace(`{${"favoriteGroupType"}}`, encodeURIComponent(String(favoriteGroupType)))
                .replace(`{${"favoriteGroupName"}}`, encodeURIComponent(String(favoriteGroupName)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFavoriteGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FavoritesApi - functional programming interface
 * @export
 */
export const FavoritesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FavoritesApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a new favorite.  Friend groups are named `group_0` through `group_3`. Avatar and World groups are named `avatars1` to `avatars4` and `worlds1` to `worlds4`.  You cannot add people whom you are not friends with to your friends list. Destroying a friendship removes the person as favorite on both sides.
         * @summary Add Favorite
         * @param {AddFavoriteRequest} [addFavoriteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addFavorite(addFavoriteRequest?: AddFavoriteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Favorite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addFavorite(addFavoriteRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Clear ALL contents of a specific favorite group.
         * @summary Clear Favorite Group
         * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
         * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clearFavoriteGroup(favoriteGroupType: 'world' | 'friend' | 'avatar', favoriteGroupName: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clearFavoriteGroup(favoriteGroupType, favoriteGroupName, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch information about a specific favorite group.
         * @summary Show Favorite Group
         * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
         * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFavoriteGroup(favoriteGroupType: 'world' | 'friend' | 'avatar', favoriteGroupName: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FavoriteGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFavoriteGroup(favoriteGroupType, favoriteGroupName, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return a list of favorite groups owned by a user. Returns the same information as `getFavoriteGroups`.
         * @summary List Favorite Groups
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [userId] Target user to see information on, admin-only.
         * @param {string} [ownerId] The owner of whoms favorite groups to return. Must be a UserID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFavoriteGroups(n?: number, offset?: number, userId?: string, ownerId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FavoriteGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFavoriteGroups(n, offset, userId, ownerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return information about a specific Favorite.
         * @summary Get Favorite Limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFavoriteLimits(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FavoriteLimits>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFavoriteLimits(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of favorites.
         * @summary List Favorites
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [type] The type of favorites to return, FavoriteType.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFavorites(n?: number, offset?: number, type?: string, tag?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Favorite>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFavorites(n, offset, type, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a favorite from your favorites list.
         * @summary Remove Favorite
         * @param {string} favoriteId Must be a valid favorite ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeFavorite(favoriteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeFavorite(favoriteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update information about a specific favorite group.
         * @summary Update Favorite Group
         * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
         * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
         * @param {string} userId Must be a valid user ID.
         * @param {UpdateFavoriteGroupRequest} [updateFavoriteGroupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFavoriteGroup(favoriteGroupType: 'world' | 'friend' | 'avatar', favoriteGroupName: string, userId: string, updateFavoriteGroupRequest?: UpdateFavoriteGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFavoriteGroup(favoriteGroupType, favoriteGroupName, userId, updateFavoriteGroupRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FavoritesApi - factory interface
 * @export
 */
export const FavoritesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FavoritesApiFp(configuration)
    return {
        /**
         * Add a new favorite.  Friend groups are named `group_0` through `group_3`. Avatar and World groups are named `avatars1` to `avatars4` and `worlds1` to `worlds4`.  You cannot add people whom you are not friends with to your friends list. Destroying a friendship removes the person as favorite on both sides.
         * @summary Add Favorite
         * @param {AddFavoriteRequest} [addFavoriteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFavorite(addFavoriteRequest?: AddFavoriteRequest, options?: any): AxiosPromise<Favorite> {
            return localVarFp.addFavorite(addFavoriteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Clear ALL contents of a specific favorite group.
         * @summary Clear Favorite Group
         * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
         * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearFavoriteGroup(favoriteGroupType: 'world' | 'friend' | 'avatar', favoriteGroupName: string, userId: string, options?: any): AxiosPromise<Success> {
            return localVarFp.clearFavoriteGroup(favoriteGroupType, favoriteGroupName, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch information about a specific favorite group.
         * @summary Show Favorite Group
         * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
         * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoriteGroup(favoriteGroupType: 'world' | 'friend' | 'avatar', favoriteGroupName: string, userId: string, options?: any): AxiosPromise<FavoriteGroup> {
            return localVarFp.getFavoriteGroup(favoriteGroupType, favoriteGroupName, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of favorite groups owned by a user. Returns the same information as `getFavoriteGroups`.
         * @summary List Favorite Groups
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [userId] Target user to see information on, admin-only.
         * @param {string} [ownerId] The owner of whoms favorite groups to return. Must be a UserID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoriteGroups(n?: number, offset?: number, userId?: string, ownerId?: string, options?: any): AxiosPromise<Array<FavoriteGroup>> {
            return localVarFp.getFavoriteGroups(n, offset, userId, ownerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Return information about a specific Favorite.
         * @summary Get Favorite Limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoriteLimits(options?: any): AxiosPromise<FavoriteLimits> {
            return localVarFp.getFavoriteLimits(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of favorites.
         * @summary List Favorites
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [type] The type of favorites to return, FavoriteType.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavorites(n?: number, offset?: number, type?: string, tag?: string, options?: any): AxiosPromise<Array<Favorite>> {
            return localVarFp.getFavorites(n, offset, type, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a favorite from your favorites list.
         * @summary Remove Favorite
         * @param {string} favoriteId Must be a valid favorite ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFavorite(favoriteId: string, options?: any): AxiosPromise<Success> {
            return localVarFp.removeFavorite(favoriteId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update information about a specific favorite group.
         * @summary Update Favorite Group
         * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
         * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
         * @param {string} userId Must be a valid user ID.
         * @param {UpdateFavoriteGroupRequest} [updateFavoriteGroupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFavoriteGroup(favoriteGroupType: 'world' | 'friend' | 'avatar', favoriteGroupName: string, userId: string, updateFavoriteGroupRequest?: UpdateFavoriteGroupRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateFavoriteGroup(favoriteGroupType, favoriteGroupName, userId, updateFavoriteGroupRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FavoritesApi - object-oriented interface
 * @export
 * @class FavoritesApi
 * @extends {BaseAPI}
 */
export class FavoritesApi extends BaseAPI {
    /**
     * Add a new favorite.  Friend groups are named `group_0` through `group_3`. Avatar and World groups are named `avatars1` to `avatars4` and `worlds1` to `worlds4`.  You cannot add people whom you are not friends with to your friends list. Destroying a friendship removes the person as favorite on both sides.
     * @summary Add Favorite
     * @param {AddFavoriteRequest} [addFavoriteRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public addFavorite(addFavoriteRequest?: AddFavoriteRequest, options?: AxiosRequestConfig) {
        return FavoritesApiFp(this.configuration).addFavorite(addFavoriteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clear ALL contents of a specific favorite group.
     * @summary Clear Favorite Group
     * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
     * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public clearFavoriteGroup(favoriteGroupType: 'world' | 'friend' | 'avatar', favoriteGroupName: string, userId: string, options?: AxiosRequestConfig) {
        return FavoritesApiFp(this.configuration).clearFavoriteGroup(favoriteGroupType, favoriteGroupName, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch information about a specific favorite group.
     * @summary Show Favorite Group
     * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
     * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public getFavoriteGroup(favoriteGroupType: 'world' | 'friend' | 'avatar', favoriteGroupName: string, userId: string, options?: AxiosRequestConfig) {
        return FavoritesApiFp(this.configuration).getFavoriteGroup(favoriteGroupType, favoriteGroupName, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of favorite groups owned by a user. Returns the same information as `getFavoriteGroups`.
     * @summary List Favorite Groups
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [userId] Target user to see information on, admin-only.
     * @param {string} [ownerId] The owner of whoms favorite groups to return. Must be a UserID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public getFavoriteGroups(n?: number, offset?: number, userId?: string, ownerId?: string, options?: AxiosRequestConfig) {
        return FavoritesApiFp(this.configuration).getFavoriteGroups(n, offset, userId, ownerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return information about a specific Favorite.
     * @summary Get Favorite Limits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public getFavoriteLimits(options?: AxiosRequestConfig) {
        return FavoritesApiFp(this.configuration).getFavoriteLimits(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of favorites.
     * @summary List Favorites
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [type] The type of favorites to return, FavoriteType.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public getFavorites(n?: number, offset?: number, type?: string, tag?: string, options?: AxiosRequestConfig) {
        return FavoritesApiFp(this.configuration).getFavorites(n, offset, type, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a favorite from your favorites list.
     * @summary Remove Favorite
     * @param {string} favoriteId Must be a valid favorite ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public removeFavorite(favoriteId: string, options?: AxiosRequestConfig) {
        return FavoritesApiFp(this.configuration).removeFavorite(favoriteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update information about a specific favorite group.
     * @summary Update Favorite Group
     * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
     * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
     * @param {string} userId Must be a valid user ID.
     * @param {UpdateFavoriteGroupRequest} [updateFavoriteGroupRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public updateFavoriteGroup(favoriteGroupType: 'world' | 'friend' | 'avatar', favoriteGroupName: string, userId: string, updateFavoriteGroupRequest?: UpdateFavoriteGroupRequest, options?: AxiosRequestConfig) {
        return FavoritesApiFp(this.configuration).updateFavoriteGroup(favoriteGroupType, favoriteGroupName, userId, updateFavoriteGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new File object
         * @summary Create File
         * @param {CreateFileRequest} [createFileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile: async (createFileRequest?: CreateFileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new FileVersion. Once a Version has been created, proceed to the `/file/{fileId}/{versionId}/file/start` endpoint to start a file upload.
         * @summary Create File Version
         * @param {string} fileId Must be a valid file ID.
         * @param {CreateFileVersionRequest} [createFileVersionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFileVersion: async (fileId: string, createFileVersionRequest?: CreateFileVersionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('createFileVersion', 'fileId', fileId)
            const localVarPath = `/file/{fileId}`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFileVersionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a File object.
         * @summary Delete File
         * @param {string} fileId Must be a valid file ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile: async (fileId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('deleteFile', 'fileId', fileId)
            const localVarPath = `/file/{fileId}`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific version of a file. You can only delete the latest version.
         * @summary Delete File Version
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileVersion: async (fileId: string, versionId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('deleteFileVersion', 'fileId', fileId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('deleteFileVersion', 'versionId', versionId)
            const localVarPath = `/file/{fileId}/{versionId}`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Downloads the file with the provided version number.  **Version Note:** Version 0 is always when the file was created. The real data is usually always located in version 1 and up.  **Extension Note:** Files are not guaranteed to have a file extensions. UnityPackage files tends to have it, images through this endpoint do not. You are responsible for appending file extension from the `extension` field when neccesary.
         * @summary Download File Version
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFileVersion: async (fileId: string, versionId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('downloadFileVersion', 'fileId', fileId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('downloadFileVersion', 'versionId', versionId)
            const localVarPath = `/file/{fileId}/{versionId}`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finish an upload of a FileData. This will mark it as \"complete\". After uploading the `file` for Avatars and Worlds you then have to upload a `signature` file.
         * @summary Finish FileData Upload
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {'file' | 'signature' | 'delta'} fileType Type of file.
         * @param {FinishFileDataUploadRequest} [finishFileDataUploadRequest] Please see documentation on ETag\&#39;s: [https://teppen.io/2018/06/23/aws_s3_etags/](https://teppen.io/2018/06/23/aws_s3_etags/)  ETag\&#39;s should NOT be present when uploading a &#x60;signature&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishFileDataUpload: async (fileId: string, versionId: number, fileType: 'file' | 'signature' | 'delta', finishFileDataUploadRequest?: FinishFileDataUploadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('finishFileDataUpload', 'fileId', fileId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('finishFileDataUpload', 'versionId', versionId)
            // verify required parameter 'fileType' is not null or undefined
            assertParamExists('finishFileDataUpload', 'fileType', fileType)
            const localVarPath = `/file/{fileId}/{versionId}/{fileType}/finish`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)))
                .replace(`{${"fileType"}}`, encodeURIComponent(String(fileType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(finishFileDataUploadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Shows general information about the \"File\" object. Each File can have several \"Version\"\'s, and each Version can have multiple real files or \"Data\" blobs.
         * @summary Show File
         * @param {string} fileId Must be a valid file ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile: async (fileId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getFile', 'fileId', fileId)
            const localVarPath = `/file/{fileId}`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the performance analysis for the uploaded assets of an avatar
         * @summary Get File Version Analysis
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileAnalysis: async (fileId: string, versionId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getFileAnalysis', 'fileId', fileId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('getFileAnalysis', 'versionId', versionId)
            const localVarPath = `/analysis/{fileId}/{versionId}`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the security performance analysis for the uploaded assets of an avatar
         * @summary Get File Version Analysis Security
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileAnalysisSecurity: async (fileId: string, versionId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getFileAnalysisSecurity', 'fileId', fileId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('getFileAnalysisSecurity', 'versionId', versionId)
            const localVarPath = `/analysis/{fileId}/{versionId}/security`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the standard performance analysis for the uploaded assets of an avatar
         * @summary Get File Version Analysis Standard
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileAnalysisStandard: async (fileId: string, versionId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getFileAnalysisStandard', 'fileId', fileId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('getFileAnalysisStandard', 'versionId', versionId)
            const localVarPath = `/analysis/{fileId}/{versionId}/standard`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the upload status for file upload. Can currently only be accessed when `status` is `waiting`. Trying to access it on a file version already uploaded currently times out.
         * @summary Check FileData Upload Status
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {'file' | 'signature' | 'delta'} fileType Type of file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileDataUploadStatus: async (fileId: string, versionId: number, fileType: 'file' | 'signature' | 'delta', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getFileDataUploadStatus', 'fileId', fileId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('getFileDataUploadStatus', 'versionId', versionId)
            // verify required parameter 'fileType' is not null or undefined
            assertParamExists('getFileDataUploadStatus', 'fileType', fileType)
            const localVarPath = `/file/{fileId}/{versionId}/{fileType}/status`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)))
                .replace(`{${"fileType"}}`, encodeURIComponent(String(fileType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of files
         * @summary List Files
         * @param {string} [tag] Tag, for example \&quot;icon\&quot; or \&quot;gallery\&quot;, not included by default.
         * @param {string} [userId] UserID, will always generate a 500 permission error.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFiles: async (tag?: string, userId?: string, n?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (n !== undefined) {
                localVarQueryParameter['n'] = n;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts an upload of a specific FilePart. This endpoint will return an AWS URL which you can PUT data to. You need to call this and receive a new AWS API URL for each `partNumber`. Please see AWS\'s REST documentation on \"PUT Object to S3\" on how to upload. Once all parts has been uploaded, proceed to `/finish` endpoint.  **Note:** `nextPartNumber` seems like it is always ignored. Despite it returning 0, first partNumber is always 1.
         * @summary Start FileData Upload
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {'file' | 'signature' | 'delta'} fileType Type of file.
         * @param {number} [partNumber] The part number to start uploading. If not provided, the first part will be started.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startFileDataUpload: async (fileId: string, versionId: number, fileType: 'file' | 'signature' | 'delta', partNumber?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('startFileDataUpload', 'fileId', fileId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('startFileDataUpload', 'versionId', versionId)
            // verify required parameter 'fileType' is not null or undefined
            assertParamExists('startFileDataUpload', 'fileType', fileType)
            const localVarPath = `/file/{fileId}/{versionId}/{fileType}/start`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)))
                .replace(`{${"fileType"}}`, encodeURIComponent(String(fileType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            if (partNumber !== undefined) {
                localVarQueryParameter['partNumber'] = partNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a gallery image
         * @summary Upload gallery image
         * @param {File} file The binary blob of the png file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadGalleryImage: async (file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadGalleryImage', 'file', file)
            const localVarPath = `/gallery`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication authCookie required


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload an icon
         * @summary Upload icon
         * @param {File} file The binary blob of the png file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadIcon: async (file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadIcon', 'file', file)
            const localVarPath = `/icon`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication authCookie required


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload an image, which can be an icon, gallery image, sticker or emoji
         * @summary Upload gallery image, icon, emoji or sticker
         * @param {File} file The binary blob of the png file.
         * @param {string} tag Needs to be either icon, gallery, sticker, emoji, or emojianimated
         * @param {number} [frames] Required for emojianimated. Total number of frames to be animated (2-64)
         * @param {number} [framesOverTime] Required for emojianimated. Animation frames per second (1-64)
         * @param {string} [animationStyle] Animation style for sticker, required for emoji.
         * @param {string} [maskTag] Mask of the sticker, optional for emoji.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadImage: async (file: File, tag: string, frames?: number, framesOverTime?: number, animationStyle?: string, maskTag?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadImage', 'file', file)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('uploadImage', 'tag', tag)
            const localVarPath = `/file/image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication authCookie required


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (tag !== undefined) { 
                localVarFormParams.append('tag', tag as any);
            }
    
            if (frames !== undefined) { 
                localVarFormParams.append('frames', frames as any);
            }
    
            if (framesOverTime !== undefined) { 
                localVarFormParams.append('framesOverTime', framesOverTime as any);
            }
    
            if (animationStyle !== undefined) { 
                localVarFormParams.append('animationStyle', animationStyle as any);
            }
    
            if (maskTag !== undefined) { 
                localVarFormParams.append('maskTag', maskTag as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new File object
         * @summary Create File
         * @param {CreateFileRequest} [createFileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFile(createFileRequest?: CreateFileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFile(createFileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new FileVersion. Once a Version has been created, proceed to the `/file/{fileId}/{versionId}/file/start` endpoint to start a file upload.
         * @summary Create File Version
         * @param {string} fileId Must be a valid file ID.
         * @param {CreateFileVersionRequest} [createFileVersionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFileVersion(fileId: string, createFileVersionRequest?: CreateFileVersionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFileVersion(fileId, createFileVersionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a File object.
         * @summary Delete File
         * @param {string} fileId Must be a valid file ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFile(fileId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(fileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a specific version of a file. You can only delete the latest version.
         * @summary Delete File Version
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFileVersion(fileId: string, versionId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFileVersion(fileId, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Downloads the file with the provided version number.  **Version Note:** Version 0 is always when the file was created. The real data is usually always located in version 1 and up.  **Extension Note:** Files are not guaranteed to have a file extensions. UnityPackage files tends to have it, images through this endpoint do not. You are responsible for appending file extension from the `extension` field when neccesary.
         * @summary Download File Version
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadFileVersion(fileId: string, versionId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFileVersion(fileId, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Finish an upload of a FileData. This will mark it as \"complete\". After uploading the `file` for Avatars and Worlds you then have to upload a `signature` file.
         * @summary Finish FileData Upload
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {'file' | 'signature' | 'delta'} fileType Type of file.
         * @param {FinishFileDataUploadRequest} [finishFileDataUploadRequest] Please see documentation on ETag\&#39;s: [https://teppen.io/2018/06/23/aws_s3_etags/](https://teppen.io/2018/06/23/aws_s3_etags/)  ETag\&#39;s should NOT be present when uploading a &#x60;signature&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async finishFileDataUpload(fileId: string, versionId: number, fileType: 'file' | 'signature' | 'delta', finishFileDataUploadRequest?: FinishFileDataUploadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.finishFileDataUpload(fileId, versionId, fileType, finishFileDataUploadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Shows general information about the \"File\" object. Each File can have several \"Version\"\'s, and each Version can have multiple real files or \"Data\" blobs.
         * @summary Show File
         * @param {string} fileId Must be a valid file ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFile(fileId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFile(fileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the performance analysis for the uploaded assets of an avatar
         * @summary Get File Version Analysis
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileAnalysis(fileId: string, versionId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileAnalysis>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileAnalysis(fileId, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the security performance analysis for the uploaded assets of an avatar
         * @summary Get File Version Analysis Security
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileAnalysisSecurity(fileId: string, versionId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileAnalysis>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileAnalysisSecurity(fileId, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the standard performance analysis for the uploaded assets of an avatar
         * @summary Get File Version Analysis Standard
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileAnalysisStandard(fileId: string, versionId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileAnalysis>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileAnalysisStandard(fileId, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the upload status for file upload. Can currently only be accessed when `status` is `waiting`. Trying to access it on a file version already uploaded currently times out.
         * @summary Check FileData Upload Status
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {'file' | 'signature' | 'delta'} fileType Type of file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileDataUploadStatus(fileId: string, versionId: number, fileType: 'file' | 'signature' | 'delta', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileVersionUploadStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileDataUploadStatus(fileId, versionId, fileType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of files
         * @summary List Files
         * @param {string} [tag] Tag, for example \&quot;icon\&quot; or \&quot;gallery\&quot;, not included by default.
         * @param {string} [userId] UserID, will always generate a 500 permission error.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFiles(tag?: string, userId?: string, n?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<any>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFiles(tag, userId, n, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Starts an upload of a specific FilePart. This endpoint will return an AWS URL which you can PUT data to. You need to call this and receive a new AWS API URL for each `partNumber`. Please see AWS\'s REST documentation on \"PUT Object to S3\" on how to upload. Once all parts has been uploaded, proceed to `/finish` endpoint.  **Note:** `nextPartNumber` seems like it is always ignored. Despite it returning 0, first partNumber is always 1.
         * @summary Start FileData Upload
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {'file' | 'signature' | 'delta'} fileType Type of file.
         * @param {number} [partNumber] The part number to start uploading. If not provided, the first part will be started.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startFileDataUpload(fileId: string, versionId: number, fileType: 'file' | 'signature' | 'delta', partNumber?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUploadURL>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startFileDataUpload(fileId, versionId, fileType, partNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload a gallery image
         * @summary Upload gallery image
         * @param {File} file The binary blob of the png file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadGalleryImage(file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadGalleryImage(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload an icon
         * @summary Upload icon
         * @param {File} file The binary blob of the png file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadIcon(file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadIcon(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload an image, which can be an icon, gallery image, sticker or emoji
         * @summary Upload gallery image, icon, emoji or sticker
         * @param {File} file The binary blob of the png file.
         * @param {string} tag Needs to be either icon, gallery, sticker, emoji, or emojianimated
         * @param {number} [frames] Required for emojianimated. Total number of frames to be animated (2-64)
         * @param {number} [framesOverTime] Required for emojianimated. Animation frames per second (1-64)
         * @param {string} [animationStyle] Animation style for sticker, required for emoji.
         * @param {string} [maskTag] Mask of the sticker, optional for emoji.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadImage(file: File, tag: string, frames?: number, framesOverTime?: number, animationStyle?: string, maskTag?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadImage(file, tag, frames, framesOverTime, animationStyle, maskTag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * Creates a new File object
         * @summary Create File
         * @param {CreateFileRequest} [createFileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile(createFileRequest?: CreateFileRequest, options?: any): AxiosPromise<any> {
            return localVarFp.createFile(createFileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new FileVersion. Once a Version has been created, proceed to the `/file/{fileId}/{versionId}/file/start` endpoint to start a file upload.
         * @summary Create File Version
         * @param {string} fileId Must be a valid file ID.
         * @param {CreateFileVersionRequest} [createFileVersionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFileVersion(fileId: string, createFileVersionRequest?: CreateFileVersionRequest, options?: any): AxiosPromise<any> {
            return localVarFp.createFileVersion(fileId, createFileVersionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a File object.
         * @summary Delete File
         * @param {string} fileId Must be a valid file ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(fileId: string, options?: any): AxiosPromise<any> {
            return localVarFp.deleteFile(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific version of a file. You can only delete the latest version.
         * @summary Delete File Version
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileVersion(fileId: string, versionId: number, options?: any): AxiosPromise<any> {
            return localVarFp.deleteFileVersion(fileId, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Downloads the file with the provided version number.  **Version Note:** Version 0 is always when the file was created. The real data is usually always located in version 1 and up.  **Extension Note:** Files are not guaranteed to have a file extensions. UnityPackage files tends to have it, images through this endpoint do not. You are responsible for appending file extension from the `extension` field when neccesary.
         * @summary Download File Version
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFileVersion(fileId: string, versionId: number, options?: any): AxiosPromise<File> {
            return localVarFp.downloadFileVersion(fileId, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Finish an upload of a FileData. This will mark it as \"complete\". After uploading the `file` for Avatars and Worlds you then have to upload a `signature` file.
         * @summary Finish FileData Upload
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {'file' | 'signature' | 'delta'} fileType Type of file.
         * @param {FinishFileDataUploadRequest} [finishFileDataUploadRequest] Please see documentation on ETag\&#39;s: [https://teppen.io/2018/06/23/aws_s3_etags/](https://teppen.io/2018/06/23/aws_s3_etags/)  ETag\&#39;s should NOT be present when uploading a &#x60;signature&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishFileDataUpload(fileId: string, versionId: number, fileType: 'file' | 'signature' | 'delta', finishFileDataUploadRequest?: FinishFileDataUploadRequest, options?: any): AxiosPromise<any> {
            return localVarFp.finishFileDataUpload(fileId, versionId, fileType, finishFileDataUploadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Shows general information about the \"File\" object. Each File can have several \"Version\"\'s, and each Version can have multiple real files or \"Data\" blobs.
         * @summary Show File
         * @param {string} fileId Must be a valid file ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(fileId: string, options?: any): AxiosPromise<any> {
            return localVarFp.getFile(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the performance analysis for the uploaded assets of an avatar
         * @summary Get File Version Analysis
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileAnalysis(fileId: string, versionId: number, options?: any): AxiosPromise<FileAnalysis> {
            return localVarFp.getFileAnalysis(fileId, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the security performance analysis for the uploaded assets of an avatar
         * @summary Get File Version Analysis Security
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileAnalysisSecurity(fileId: string, versionId: number, options?: any): AxiosPromise<FileAnalysis> {
            return localVarFp.getFileAnalysisSecurity(fileId, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the standard performance analysis for the uploaded assets of an avatar
         * @summary Get File Version Analysis Standard
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileAnalysisStandard(fileId: string, versionId: number, options?: any): AxiosPromise<FileAnalysis> {
            return localVarFp.getFileAnalysisStandard(fileId, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the upload status for file upload. Can currently only be accessed when `status` is `waiting`. Trying to access it on a file version already uploaded currently times out.
         * @summary Check FileData Upload Status
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {'file' | 'signature' | 'delta'} fileType Type of file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileDataUploadStatus(fileId: string, versionId: number, fileType: 'file' | 'signature' | 'delta', options?: any): AxiosPromise<FileVersionUploadStatus> {
            return localVarFp.getFileDataUploadStatus(fileId, versionId, fileType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of files
         * @summary List Files
         * @param {string} [tag] Tag, for example \&quot;icon\&quot; or \&quot;gallery\&quot;, not included by default.
         * @param {string} [userId] UserID, will always generate a 500 permission error.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFiles(tag?: string, userId?: string, n?: number, offset?: number, options?: any): AxiosPromise<Array<any>> {
            return localVarFp.getFiles(tag, userId, n, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts an upload of a specific FilePart. This endpoint will return an AWS URL which you can PUT data to. You need to call this and receive a new AWS API URL for each `partNumber`. Please see AWS\'s REST documentation on \"PUT Object to S3\" on how to upload. Once all parts has been uploaded, proceed to `/finish` endpoint.  **Note:** `nextPartNumber` seems like it is always ignored. Despite it returning 0, first partNumber is always 1.
         * @summary Start FileData Upload
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {'file' | 'signature' | 'delta'} fileType Type of file.
         * @param {number} [partNumber] The part number to start uploading. If not provided, the first part will be started.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startFileDataUpload(fileId: string, versionId: number, fileType: 'file' | 'signature' | 'delta', partNumber?: number, options?: any): AxiosPromise<FileUploadURL> {
            return localVarFp.startFileDataUpload(fileId, versionId, fileType, partNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a gallery image
         * @summary Upload gallery image
         * @param {File} file The binary blob of the png file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadGalleryImage(file: File, options?: any): AxiosPromise<any> {
            return localVarFp.uploadGalleryImage(file, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload an icon
         * @summary Upload icon
         * @param {File} file The binary blob of the png file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadIcon(file: File, options?: any): AxiosPromise<any> {
            return localVarFp.uploadIcon(file, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload an image, which can be an icon, gallery image, sticker or emoji
         * @summary Upload gallery image, icon, emoji or sticker
         * @param {File} file The binary blob of the png file.
         * @param {string} tag Needs to be either icon, gallery, sticker, emoji, or emojianimated
         * @param {number} [frames] Required for emojianimated. Total number of frames to be animated (2-64)
         * @param {number} [framesOverTime] Required for emojianimated. Animation frames per second (1-64)
         * @param {string} [animationStyle] Animation style for sticker, required for emoji.
         * @param {string} [maskTag] Mask of the sticker, optional for emoji.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadImage(file: File, tag: string, frames?: number, framesOverTime?: number, animationStyle?: string, maskTag?: string, options?: any): AxiosPromise<any> {
            return localVarFp.uploadImage(file, tag, frames, framesOverTime, animationStyle, maskTag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * Creates a new File object
     * @summary Create File
     * @param {CreateFileRequest} [createFileRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public createFile(createFileRequest?: CreateFileRequest, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).createFile(createFileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new FileVersion. Once a Version has been created, proceed to the `/file/{fileId}/{versionId}/file/start` endpoint to start a file upload.
     * @summary Create File Version
     * @param {string} fileId Must be a valid file ID.
     * @param {CreateFileVersionRequest} [createFileVersionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public createFileVersion(fileId: string, createFileVersionRequest?: CreateFileVersionRequest, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).createFileVersion(fileId, createFileVersionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a File object.
     * @summary Delete File
     * @param {string} fileId Must be a valid file ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public deleteFile(fileId: string, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).deleteFile(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific version of a file. You can only delete the latest version.
     * @summary Delete File Version
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public deleteFileVersion(fileId: string, versionId: number, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).deleteFileVersion(fileId, versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Downloads the file with the provided version number.  **Version Note:** Version 0 is always when the file was created. The real data is usually always located in version 1 and up.  **Extension Note:** Files are not guaranteed to have a file extensions. UnityPackage files tends to have it, images through this endpoint do not. You are responsible for appending file extension from the `extension` field when neccesary.
     * @summary Download File Version
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public downloadFileVersion(fileId: string, versionId: number, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).downloadFileVersion(fileId, versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Finish an upload of a FileData. This will mark it as \"complete\". After uploading the `file` for Avatars and Worlds you then have to upload a `signature` file.
     * @summary Finish FileData Upload
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {'file' | 'signature' | 'delta'} fileType Type of file.
     * @param {FinishFileDataUploadRequest} [finishFileDataUploadRequest] Please see documentation on ETag\&#39;s: [https://teppen.io/2018/06/23/aws_s3_etags/](https://teppen.io/2018/06/23/aws_s3_etags/)  ETag\&#39;s should NOT be present when uploading a &#x60;signature&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public finishFileDataUpload(fileId: string, versionId: number, fileType: 'file' | 'signature' | 'delta', finishFileDataUploadRequest?: FinishFileDataUploadRequest, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).finishFileDataUpload(fileId, versionId, fileType, finishFileDataUploadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Shows general information about the \"File\" object. Each File can have several \"Version\"\'s, and each Version can have multiple real files or \"Data\" blobs.
     * @summary Show File
     * @param {string} fileId Must be a valid file ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getFile(fileId: string, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).getFile(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the performance analysis for the uploaded assets of an avatar
     * @summary Get File Version Analysis
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getFileAnalysis(fileId: string, versionId: number, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).getFileAnalysis(fileId, versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the security performance analysis for the uploaded assets of an avatar
     * @summary Get File Version Analysis Security
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getFileAnalysisSecurity(fileId: string, versionId: number, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).getFileAnalysisSecurity(fileId, versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the standard performance analysis for the uploaded assets of an avatar
     * @summary Get File Version Analysis Standard
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getFileAnalysisStandard(fileId: string, versionId: number, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).getFileAnalysisStandard(fileId, versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the upload status for file upload. Can currently only be accessed when `status` is `waiting`. Trying to access it on a file version already uploaded currently times out.
     * @summary Check FileData Upload Status
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {'file' | 'signature' | 'delta'} fileType Type of file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getFileDataUploadStatus(fileId: string, versionId: number, fileType: 'file' | 'signature' | 'delta', options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).getFileDataUploadStatus(fileId, versionId, fileType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of files
     * @summary List Files
     * @param {string} [tag] Tag, for example \&quot;icon\&quot; or \&quot;gallery\&quot;, not included by default.
     * @param {string} [userId] UserID, will always generate a 500 permission error.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getFiles(tag?: string, userId?: string, n?: number, offset?: number, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).getFiles(tag, userId, n, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts an upload of a specific FilePart. This endpoint will return an AWS URL which you can PUT data to. You need to call this and receive a new AWS API URL for each `partNumber`. Please see AWS\'s REST documentation on \"PUT Object to S3\" on how to upload. Once all parts has been uploaded, proceed to `/finish` endpoint.  **Note:** `nextPartNumber` seems like it is always ignored. Despite it returning 0, first partNumber is always 1.
     * @summary Start FileData Upload
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {'file' | 'signature' | 'delta'} fileType Type of file.
     * @param {number} [partNumber] The part number to start uploading. If not provided, the first part will be started.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public startFileDataUpload(fileId: string, versionId: number, fileType: 'file' | 'signature' | 'delta', partNumber?: number, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).startFileDataUpload(fileId, versionId, fileType, partNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a gallery image
     * @summary Upload gallery image
     * @param {File} file The binary blob of the png file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public uploadGalleryImage(file: File, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).uploadGalleryImage(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload an icon
     * @summary Upload icon
     * @param {File} file The binary blob of the png file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public uploadIcon(file: File, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).uploadIcon(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload an image, which can be an icon, gallery image, sticker or emoji
     * @summary Upload gallery image, icon, emoji or sticker
     * @param {File} file The binary blob of the png file.
     * @param {string} tag Needs to be either icon, gallery, sticker, emoji, or emojianimated
     * @param {number} [frames] Required for emojianimated. Total number of frames to be animated (2-64)
     * @param {number} [framesOverTime] Required for emojianimated. Animation frames per second (1-64)
     * @param {string} [animationStyle] Animation style for sticker, required for emoji.
     * @param {string} [maskTag] Mask of the sticker, optional for emoji.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public uploadImage(file: File, tag: string, frames?: number, framesOverTime?: number, animationStyle?: string, maskTag?: string, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).uploadImage(file, tag, frames, framesOverTime, animationStyle, maskTag, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FriendsApi - axios parameter creator
 * @export
 */
export const FriendsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes an outgoing pending friend request to another user. To delete an incoming friend request, use the `deleteNotification` endpoint instead.
         * @summary Delete Friend Request
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFriendRequest: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteFriendRequest', 'userId', userId)
            const localVarPath = `/user/{userId}/friendRequest`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a friend request to another user.
         * @summary Send Friend Request
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        friend: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('friend', 'userId', userId)
            const localVarPath = `/user/{userId}/friendRequest`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve if the user is currently a friend with a given user, if they have an outgoing friend request, and if they have an incoming friend request. The proper way to receive and accept friend request is by checking if the user has an incoming `Notification` of type `friendRequest`, and then accepting that notification.
         * @summary Check Friend Status
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFriendStatus: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getFriendStatus', 'userId', userId)
            const localVarPath = `/user/{userId}/friendStatus`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List information about friends.
         * @summary List Friends
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {number} [n] The number of objects to return.
         * @param {boolean} [offline] Returns *only* offline users if true, returns only online and active users if false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFriends: async (offset?: number, n?: number, offline?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/user/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (n !== undefined) {
                localVarQueryParameter['n'] = n;
            }

            if (offline !== undefined) {
                localVarQueryParameter['offline'] = offline;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unfriend a user by ID.
         * @summary Unfriend
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfriend: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('unfriend', 'userId', userId)
            const localVarPath = `/auth/user/friends/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FriendsApi - functional programming interface
 * @export
 */
export const FriendsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FriendsApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes an outgoing pending friend request to another user. To delete an incoming friend request, use the `deleteNotification` endpoint instead.
         * @summary Delete Friend Request
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFriendRequest(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFriendRequest(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send a friend request to another user.
         * @summary Send Friend Request
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async friend(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.friend(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve if the user is currently a friend with a given user, if they have an outgoing friend request, and if they have an incoming friend request. The proper way to receive and accept friend request is by checking if the user has an incoming `Notification` of type `friendRequest`, and then accepting that notification.
         * @summary Check Friend Status
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFriendStatus(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FriendStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFriendStatus(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List information about friends.
         * @summary List Friends
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {number} [n] The number of objects to return.
         * @param {boolean} [offline] Returns *only* offline users if true, returns only online and active users if false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFriends(offset?: number, n?: number, offline?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LimitedUserFriend>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFriends(offset, n, offline, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unfriend a user by ID.
         * @summary Unfriend
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unfriend(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unfriend(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FriendsApi - factory interface
 * @export
 */
export const FriendsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FriendsApiFp(configuration)
    return {
        /**
         * Deletes an outgoing pending friend request to another user. To delete an incoming friend request, use the `deleteNotification` endpoint instead.
         * @summary Delete Friend Request
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFriendRequest(userId: string, options?: any): AxiosPromise<Success> {
            return localVarFp.deleteFriendRequest(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a friend request to another user.
         * @summary Send Friend Request
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        friend(userId: string, options?: any): AxiosPromise<Notification> {
            return localVarFp.friend(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve if the user is currently a friend with a given user, if they have an outgoing friend request, and if they have an incoming friend request. The proper way to receive and accept friend request is by checking if the user has an incoming `Notification` of type `friendRequest`, and then accepting that notification.
         * @summary Check Friend Status
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFriendStatus(userId: string, options?: any): AxiosPromise<FriendStatus> {
            return localVarFp.getFriendStatus(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List information about friends.
         * @summary List Friends
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {number} [n] The number of objects to return.
         * @param {boolean} [offline] Returns *only* offline users if true, returns only online and active users if false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFriends(offset?: number, n?: number, offline?: boolean, options?: any): AxiosPromise<Array<LimitedUserFriend>> {
            return localVarFp.getFriends(offset, n, offline, options).then((request) => request(axios, basePath));
        },
        /**
         * Unfriend a user by ID.
         * @summary Unfriend
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfriend(userId: string, options?: any): AxiosPromise<Success> {
            return localVarFp.unfriend(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FriendsApi - object-oriented interface
 * @export
 * @class FriendsApi
 * @extends {BaseAPI}
 */
export class FriendsApi extends BaseAPI {
    /**
     * Deletes an outgoing pending friend request to another user. To delete an incoming friend request, use the `deleteNotification` endpoint instead.
     * @summary Delete Friend Request
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendsApi
     */
    public deleteFriendRequest(userId: string, options?: AxiosRequestConfig) {
        return FriendsApiFp(this.configuration).deleteFriendRequest(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a friend request to another user.
     * @summary Send Friend Request
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendsApi
     */
    public friend(userId: string, options?: AxiosRequestConfig) {
        return FriendsApiFp(this.configuration).friend(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve if the user is currently a friend with a given user, if they have an outgoing friend request, and if they have an incoming friend request. The proper way to receive and accept friend request is by checking if the user has an incoming `Notification` of type `friendRequest`, and then accepting that notification.
     * @summary Check Friend Status
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendsApi
     */
    public getFriendStatus(userId: string, options?: AxiosRequestConfig) {
        return FriendsApiFp(this.configuration).getFriendStatus(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List information about friends.
     * @summary List Friends
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {number} [n] The number of objects to return.
     * @param {boolean} [offline] Returns *only* offline users if true, returns only online and active users if false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendsApi
     */
    public getFriends(offset?: number, n?: number, offline?: boolean, options?: AxiosRequestConfig) {
        return FriendsApiFp(this.configuration).getFriends(offset, n, offline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unfriend a user by ID.
     * @summary Unfriend
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendsApi
     */
    public unfriend(userId: string, options?: AxiosRequestConfig) {
        return FriendsApiFp(this.configuration).unfriend(userId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds an image to a Group gallery.
         * @summary Add Group Gallery Image
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupGalleryId Must be a valid group gallery ID.
         * @param {AddGroupGalleryImageRequest} addGroupGalleryImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroupGalleryImage: async (groupId: string, groupGalleryId: string, addGroupGalleryImageRequest: AddGroupGalleryImageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('addGroupGalleryImage', 'groupId', groupId)
            // verify required parameter 'groupGalleryId' is not null or undefined
            assertParamExists('addGroupGalleryImage', 'groupGalleryId', groupGalleryId)
            // verify required parameter 'addGroupGalleryImageRequest' is not null or undefined
            assertParamExists('addGroupGalleryImage', 'addGroupGalleryImageRequest', addGroupGalleryImageRequest)
            const localVarPath = `/groups/{groupId}/galleries/{groupGalleryId}/images`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"groupGalleryId"}}`, encodeURIComponent(String(groupGalleryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addGroupGalleryImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a Role to a Group Member
         * @summary Add Role to GroupMember
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {string} groupRoleId Must be a valid group role ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroupMemberRole: async (groupId: string, userId: string, groupRoleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('addGroupMemberRole', 'groupId', groupId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('addGroupMemberRole', 'userId', userId)
            // verify required parameter 'groupRoleId' is not null or undefined
            assertParamExists('addGroupMemberRole', 'groupRoleId', groupRoleId)
            const localVarPath = `/groups/{groupId}/members/{userId}/roles/{groupRoleId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"groupRoleId"}}`, encodeURIComponent(String(groupRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a post in a Group.
         * @summary Create a post in a Group
         * @param {string} groupId Must be a valid group ID.
         * @param {CreateGroupPostRequest} createGroupPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroupPost: async (groupId: string, createGroupPostRequest: CreateGroupPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('addGroupPost', 'groupId', groupId)
            // verify required parameter 'createGroupPostRequest' is not null or undefined
            assertParamExists('addGroupPost', 'createGroupPostRequest', createGroupPostRequest)
            const localVarPath = `/groups/{groupId}/posts`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGroupPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bans a user from a Group.
         * @summary Ban Group Member
         * @param {string} groupId Must be a valid group ID.
         * @param {BanGroupMemberRequest} banGroupMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banGroupMember: async (groupId: string, banGroupMemberRequest: BanGroupMemberRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('banGroupMember', 'groupId', groupId)
            // verify required parameter 'banGroupMemberRequest' is not null or undefined
            assertParamExists('banGroupMember', 'banGroupMemberRequest', banGroupMemberRequest)
            const localVarPath = `/groups/{groupId}/bans`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(banGroupMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancels a request sent to join the group.
         * @summary Cancel Group Join Request
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelGroupRequest: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('cancelGroupRequest', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/requests`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Group and returns a Group object. **Requires VRC+ Subscription.**
         * @summary Create Group
         * @param {CreateGroupRequest} createGroupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: async (createGroupRequest: CreateGroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createGroupRequest' is not null or undefined
            assertParamExists('createGroup', 'createGroupRequest', createGroupRequest)
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an Announcement for a Group. Warning: This will also remove all announcements. To make proper announcements, use the posts endpoint instead
         * @summary Create Group Announcement
         * @param {string} groupId Must be a valid group ID.
         * @param {CreateGroupAnnouncementRequest} createGroupAnnouncementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupAnnouncement: async (groupId: string, createGroupAnnouncementRequest: CreateGroupAnnouncementRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('createGroupAnnouncement', 'groupId', groupId)
            // verify required parameter 'createGroupAnnouncementRequest' is not null or undefined
            assertParamExists('createGroupAnnouncement', 'createGroupAnnouncementRequest', createGroupAnnouncementRequest)
            const localVarPath = `/groups/{groupId}/announcement`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGroupAnnouncementRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a gallery for a Group.
         * @summary Create Group Gallery
         * @param {string} groupId Must be a valid group ID.
         * @param {CreateGroupGalleryRequest} createGroupGalleryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupGallery: async (groupId: string, createGroupGalleryRequest: CreateGroupGalleryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('createGroupGallery', 'groupId', groupId)
            // verify required parameter 'createGroupGalleryRequest' is not null or undefined
            assertParamExists('createGroupGallery', 'createGroupGalleryRequest', createGroupGalleryRequest)
            const localVarPath = `/groups/{groupId}/galleries`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGroupGalleryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends an invite to a user to join the group.
         * @summary Invite User to Group
         * @param {string} groupId Must be a valid group ID.
         * @param {CreateGroupInviteRequest} createGroupInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupInvite: async (groupId: string, createGroupInviteRequest: CreateGroupInviteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('createGroupInvite', 'groupId', groupId)
            // verify required parameter 'createGroupInviteRequest' is not null or undefined
            assertParamExists('createGroupInvite', 'createGroupInviteRequest', createGroupInviteRequest)
            const localVarPath = `/groups/{groupId}/invites`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGroupInviteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Group role.
         * @summary Create GroupRole
         * @param {string} groupId Must be a valid group ID.
         * @param {CreateGroupRoleRequest} createGroupRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupRole: async (groupId: string, createGroupRoleRequest: CreateGroupRoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('createGroupRole', 'groupId', groupId)
            // verify required parameter 'createGroupRoleRequest' is not null or undefined
            assertParamExists('createGroupRole', 'createGroupRoleRequest', createGroupRoleRequest)
            const localVarPath = `/groups/{groupId}/roles`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGroupRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Group.
         * @summary Delete Group
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteGroup', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the announcement for a Group.
         * @summary Delete Group Announcement
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupAnnouncement: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteGroupAnnouncement', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/announcement`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a gallery for a Group.
         * @summary Delete Group Gallery
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupGalleryId Must be a valid group gallery ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupGallery: async (groupId: string, groupGalleryId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteGroupGallery', 'groupId', groupId)
            // verify required parameter 'groupGalleryId' is not null or undefined
            assertParamExists('deleteGroupGallery', 'groupGalleryId', groupGalleryId)
            const localVarPath = `/groups/{groupId}/galleries/{groupGalleryId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"groupGalleryId"}}`, encodeURIComponent(String(groupGalleryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an image from a Group gallery.
         * @summary Delete Group Gallery Image
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupGalleryId Must be a valid group gallery ID.
         * @param {string} groupGalleryImageId Must be a valid group gallery image ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupGalleryImage: async (groupId: string, groupGalleryId: string, groupGalleryImageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteGroupGalleryImage', 'groupId', groupId)
            // verify required parameter 'groupGalleryId' is not null or undefined
            assertParamExists('deleteGroupGalleryImage', 'groupGalleryId', groupGalleryId)
            // verify required parameter 'groupGalleryImageId' is not null or undefined
            assertParamExists('deleteGroupGalleryImage', 'groupGalleryImageId', groupGalleryImageId)
            const localVarPath = `/groups/{groupId}/galleries/{groupGalleryId}/images/{groupGalleryImageId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"groupGalleryId"}}`, encodeURIComponent(String(groupGalleryId)))
                .replace(`{${"groupGalleryImageId"}}`, encodeURIComponent(String(groupGalleryImageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an Group invite sent to a User
         * @summary Delete User Invite
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupInvite: async (groupId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteGroupInvite', 'groupId', groupId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteGroupInvite', 'userId', userId)
            const localVarPath = `/groups/{groupId}/invites/{userId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Group post
         * @summary Delete a Group post
         * @param {string} groupId Must be a valid group ID.
         * @param {string} notificationId Must be a valid notification ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupPost: async (groupId: string, notificationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteGroupPost', 'groupId', groupId)
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('deleteGroupPost', 'notificationId', notificationId)
            const localVarPath = `/groups/{groupId}/posts/{notificationId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Group Role by ID and returns the remaining roles.
         * @summary Delete Group Role
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupRoleId Must be a valid group role ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupRole: async (groupId: string, groupRoleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteGroupRole', 'groupId', groupId)
            // verify required parameter 'groupRoleId' is not null or undefined
            assertParamExists('deleteGroupRole', 'groupRoleId', groupRoleId)
            const localVarPath = `/groups/{groupId}/roles/{groupRoleId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"groupRoleId"}}`, encodeURIComponent(String(groupRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single Group by ID.
         * @summary Get Group by ID
         * @param {string} groupId Must be a valid group ID.
         * @param {boolean} [includeRoles] Include roles for the Group object. Defaults to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: async (groupId: string, includeRoles?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroup', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            if (includeRoles !== undefined) {
                localVarQueryParameter['includeRoles'] = includeRoles;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the announcement for a Group. If no announcement has been made, then it returns **empty object**.  If an announcement exists, then it will always return all fields except `imageId` and `imageUrl` which may be null.
         * @summary Get Group Announcement
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupAnnouncements: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroupAnnouncements', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/announcement`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of audit logs for a Group.
         * @summary Get Group Audit Logs
         * @param {string} groupId Must be a valid group ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [startDate] The start date of the search range.
         * @param {string} [endDate] The end date of the search range.
         * @param {string} [actorIds] The comma-separated actor ids to search for.
         * @param {string} [eventTypes] The comma-separated event types to search for.
         * @param {string} [targetIds] The comma-separated target ids to search for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupAuditLogs: async (groupId: string, n?: number, offset?: number, startDate?: string, endDate?: string, actorIds?: string, eventTypes?: string, targetIds?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroupAuditLogs', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/auditLogs`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            if (n !== undefined) {
                localVarQueryParameter['n'] = n;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (actorIds !== undefined) {
                localVarQueryParameter['actorIds'] = actorIds;
            }

            if (eventTypes !== undefined) {
                localVarQueryParameter['eventTypes'] = eventTypes;
            }

            if (targetIds !== undefined) {
                localVarQueryParameter['targetIds'] = targetIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of banned users for a Group.
         * @summary Get Group Bans
         * @param {string} groupId Must be a valid group ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupBans: async (groupId: string, n?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroupBans', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/bans`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            if (n !== undefined) {
                localVarQueryParameter['n'] = n;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of images for a Group gallery.
         * @summary Get Group Gallery Images
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupGalleryId Must be a valid group gallery ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {boolean} [approved] If specified, only returns images that have been approved or not approved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupGalleryImages: async (groupId: string, groupGalleryId: string, n?: number, offset?: number, approved?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroupGalleryImages', 'groupId', groupId)
            // verify required parameter 'groupGalleryId' is not null or undefined
            assertParamExists('getGroupGalleryImages', 'groupGalleryId', groupGalleryId)
            const localVarPath = `/groups/{groupId}/galleries/{groupGalleryId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"groupGalleryId"}}`, encodeURIComponent(String(groupGalleryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            if (n !== undefined) {
                localVarQueryParameter['n'] = n;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (approved !== undefined) {
                localVarQueryParameter['approved'] = approved;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of group instances
         * @summary Get Group Instances
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupInstances: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroupInstances', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/instances`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of members that have been invited to the Group.
         * @summary Get Group Invites Sent
         * @param {string} groupId Must be a valid group ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupInvites: async (groupId: string, n?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroupInvites', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/invites`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            if (n !== undefined) {
                localVarQueryParameter['n'] = n;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a LimitedGroup Member.
         * @summary Get Group Member
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMember: async (groupId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroupMember', 'groupId', groupId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getGroupMember', 'userId', userId)
            const localVarPath = `/groups/{groupId}/members/{userId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a List of all **other** Group Members. This endpoint will never return the user calling the endpoint. Information about the user calling the endpoint must be found in the `myMember` field of the Group object.
         * @summary List Group Members
         * @param {string} groupId Must be a valid group ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {GroupSearchSort} [sort] The sort order of Group Member results
         * @param {string} [roleId] Only returns members with a specific groupRoleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMembers: async (groupId: string, n?: number, offset?: number, sort?: GroupSearchSort, roleId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroupMembers', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/members`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            if (n !== undefined) {
                localVarQueryParameter['n'] = n;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (roleId !== undefined) {
                localVarQueryParameter['roleId'] = roleId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a List of all possible/available permissions for a Group.
         * @summary List Group Permissions
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPermissions: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroupPermissions', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/permissions`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get posts from a Group
         * @summary Get posts from a Group
         * @param {string} groupId Must be a valid group ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {boolean} [publicOnly] See public posts only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPosts: async (groupId: string, n?: number, offset?: number, publicOnly?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroupPosts', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/posts`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            if (n !== undefined) {
                localVarQueryParameter['n'] = n;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (publicOnly !== undefined) {
                localVarQueryParameter['publicOnly'] = publicOnly;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of members that have requested to join the Group.
         * @summary Get Group Join Requests
         * @param {string} groupId Must be a valid group ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {boolean} [blocked] See blocked join requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupRequests: async (groupId: string, n?: number, offset?: number, blocked?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroupRequests', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/requests`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            if (n !== undefined) {
                localVarQueryParameter['n'] = n;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (blocked !== undefined) {
                localVarQueryParameter['blocked'] = blocked;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtain predefined templates for group roles
         * @summary Get Group Role Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupRoleTemplates: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups/roleTemplates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Group Role by ID.
         * @summary Get Group Roles
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupRoles: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroupRoles', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/roles`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Join a Group by ID and returns the member object.
         * @summary Join Group
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinGroup: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('joinGroup', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/join`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kicks a Group Member from the Group. The current user must have the \"Remove Group Members\" permission.
         * @summary Kick Group Member
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kickGroupMember: async (groupId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('kickGroupMember', 'groupId', groupId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('kickGroupMember', 'userId', userId)
            const localVarPath = `/groups/{groupId}/members/{userId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Leave a group by ID.
         * @summary Leave Group
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveGroup: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('leaveGroup', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/leave`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a Role from a Group Member
         * @summary Remove Role from GroupMember
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {string} groupRoleId Must be a valid group role ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeGroupMemberRole: async (groupId: string, userId: string, groupRoleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('removeGroupMemberRole', 'groupId', groupId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removeGroupMemberRole', 'userId', userId)
            // verify required parameter 'groupRoleId' is not null or undefined
            assertParamExists('removeGroupMemberRole', 'groupRoleId', groupRoleId)
            const localVarPath = `/groups/{groupId}/members/{userId}/roles/{groupRoleId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"groupRoleId"}}`, encodeURIComponent(String(groupRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Responds to a Group Join Request with Accept/Deny
         * @summary Respond Group Join request
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {RespondGroupJoinRequest} respondGroupJoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        respondGroupJoinRequest: async (groupId: string, userId: string, respondGroupJoinRequest: RespondGroupJoinRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('respondGroupJoinRequest', 'groupId', groupId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('respondGroupJoinRequest', 'userId', userId)
            // verify required parameter 'respondGroupJoinRequest' is not null or undefined
            assertParamExists('respondGroupJoinRequest', 'respondGroupJoinRequest', respondGroupJoinRequest)
            const localVarPath = `/groups/{groupId}/requests/{userId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(respondGroupJoinRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches Groups by name or shortCode
         * @summary Search Group
         * @param {string} [query] Query to search for, can be either Group Name or Group shortCode
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {number} [n] The number of objects to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGroups: async (query?: string, offset?: number, n?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (n !== undefined) {
                localVarQueryParameter['n'] = n;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unbans a user from a Group.
         * @summary Unban Group Member
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbanGroupMember: async (groupId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('unbanGroupMember', 'groupId', groupId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('unbanGroupMember', 'userId', userId)
            const localVarPath = `/groups/{groupId}/bans/{userId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Group and returns it.
         * @summary Update Group
         * @param {string} groupId Must be a valid group ID.
         * @param {UpdateGroupRequest} [updateGroupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup: async (groupId: string, updateGroupRequest?: UpdateGroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateGroup', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a gallery for a Group.
         * @summary Update Group Gallery
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupGalleryId Must be a valid group gallery ID.
         * @param {UpdateGroupGalleryRequest} [updateGroupGalleryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupGallery: async (groupId: string, groupGalleryId: string, updateGroupGalleryRequest?: UpdateGroupGalleryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateGroupGallery', 'groupId', groupId)
            // verify required parameter 'groupGalleryId' is not null or undefined
            assertParamExists('updateGroupGallery', 'groupGalleryId', groupGalleryId)
            const localVarPath = `/groups/{groupId}/galleries/{groupGalleryId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"groupGalleryId"}}`, encodeURIComponent(String(groupGalleryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGroupGalleryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Group Member
         * @summary Update Group Member
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {UpdateGroupMemberRequest} [updateGroupMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupMember: async (groupId: string, userId: string, updateGroupMemberRequest?: UpdateGroupMemberRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateGroupMember', 'groupId', groupId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateGroupMember', 'userId', userId)
            const localVarPath = `/groups/{groupId}/members/{userId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGroupMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edits a Group post
         * @summary Edits a Group post
         * @param {string} groupId Must be a valid group ID.
         * @param {string} notificationId Must be a valid notification ID.
         * @param {CreateGroupPostRequest} createGroupPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupPost: async (groupId: string, notificationId: string, createGroupPostRequest: CreateGroupPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateGroupPost', 'groupId', groupId)
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('updateGroupPost', 'notificationId', notificationId)
            // verify required parameter 'createGroupPostRequest' is not null or undefined
            assertParamExists('updateGroupPost', 'createGroupPostRequest', createGroupPostRequest)
            const localVarPath = `/groups/{groupId}/posts/{notificationId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGroupPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates whether the user is representing the group.  When `isRepresenting` is set to `true`, this flag will be set to `false` for all other groups
         * @summary Update Group Representation
         * @param {string} groupId Must be a valid group ID.
         * @param {UpdateGroupRepresentationRequest} updateGroupRepresentationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupRepresentation: async (groupId: string, updateGroupRepresentationRequest: UpdateGroupRepresentationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateGroupRepresentation', 'groupId', groupId)
            // verify required parameter 'updateGroupRepresentationRequest' is not null or undefined
            assertParamExists('updateGroupRepresentation', 'updateGroupRepresentationRequest', updateGroupRepresentationRequest)
            const localVarPath = `/groups/{groupId}/representation`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGroupRepresentationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a group role by ID.
         * @summary Update Group Role
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupRoleId Must be a valid group role ID.
         * @param {UpdateGroupRoleRequest} [updateGroupRoleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupRole: async (groupId: string, groupRoleId: string, updateGroupRoleRequest?: UpdateGroupRoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateGroupRole', 'groupId', groupId)
            // verify required parameter 'groupRoleId' is not null or undefined
            assertParamExists('updateGroupRole', 'groupRoleId', groupRoleId)
            const localVarPath = `/groups/{groupId}/roles/{groupRoleId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"groupRoleId"}}`, encodeURIComponent(String(groupRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGroupRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds an image to a Group gallery.
         * @summary Add Group Gallery Image
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupGalleryId Must be a valid group gallery ID.
         * @param {AddGroupGalleryImageRequest} addGroupGalleryImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addGroupGalleryImage(groupId: string, groupGalleryId: string, addGroupGalleryImageRequest: AddGroupGalleryImageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupGalleryImage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addGroupGalleryImage(groupId, groupGalleryId, addGroupGalleryImageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a Role to a Group Member
         * @summary Add Role to GroupMember
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {string} groupRoleId Must be a valid group role ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addGroupMemberRole(groupId: string, userId: string, groupRoleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addGroupMemberRole(groupId, userId, groupRoleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a post in a Group.
         * @summary Create a post in a Group
         * @param {string} groupId Must be a valid group ID.
         * @param {CreateGroupPostRequest} createGroupPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addGroupPost(groupId: string, createGroupPostRequest: CreateGroupPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupPost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addGroupPost(groupId, createGroupPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Bans a user from a Group.
         * @summary Ban Group Member
         * @param {string} groupId Must be a valid group ID.
         * @param {BanGroupMemberRequest} banGroupMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async banGroupMember(groupId: string, banGroupMemberRequest: BanGroupMemberRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.banGroupMember(groupId, banGroupMemberRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancels a request sent to join the group.
         * @summary Cancel Group Join Request
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelGroupRequest(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelGroupRequest(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Group and returns a Group object. **Requires VRC+ Subscription.**
         * @summary Create Group
         * @param {CreateGroupRequest} createGroupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroup(createGroupRequest: CreateGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroup(createGroupRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates an Announcement for a Group. Warning: This will also remove all announcements. To make proper announcements, use the posts endpoint instead
         * @summary Create Group Announcement
         * @param {string} groupId Must be a valid group ID.
         * @param {CreateGroupAnnouncementRequest} createGroupAnnouncementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroupAnnouncement(groupId: string, createGroupAnnouncementRequest: CreateGroupAnnouncementRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupAnnouncement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroupAnnouncement(groupId, createGroupAnnouncementRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a gallery for a Group.
         * @summary Create Group Gallery
         * @param {string} groupId Must be a valid group ID.
         * @param {CreateGroupGalleryRequest} createGroupGalleryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroupGallery(groupId: string, createGroupGalleryRequest: CreateGroupGalleryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupGallery>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroupGallery(groupId, createGroupGalleryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sends an invite to a user to join the group.
         * @summary Invite User to Group
         * @param {string} groupId Must be a valid group ID.
         * @param {CreateGroupInviteRequest} createGroupInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroupInvite(groupId: string, createGroupInviteRequest: CreateGroupInviteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroupInvite(groupId, createGroupInviteRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a Group role.
         * @summary Create GroupRole
         * @param {string} groupId Must be a valid group ID.
         * @param {CreateGroupRoleRequest} createGroupRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroupRole(groupId: string, createGroupRoleRequest: CreateGroupRoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroupRole(groupId, createGroupRoleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a Group.
         * @summary Delete Group
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the announcement for a Group.
         * @summary Delete Group Announcement
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroupAnnouncement(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroupAnnouncement(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a gallery for a Group.
         * @summary Delete Group Gallery
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupGalleryId Must be a valid group gallery ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroupGallery(groupId: string, groupGalleryId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroupGallery(groupId, groupGalleryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes an image from a Group gallery.
         * @summary Delete Group Gallery Image
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupGalleryId Must be a valid group gallery ID.
         * @param {string} groupGalleryImageId Must be a valid group gallery image ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroupGalleryImage(groupId: string, groupGalleryId: string, groupGalleryImageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroupGalleryImage(groupId, groupGalleryId, groupGalleryImageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes an Group invite sent to a User
         * @summary Delete User Invite
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroupInvite(groupId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroupInvite(groupId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a Group post
         * @summary Delete a Group post
         * @param {string} groupId Must be a valid group ID.
         * @param {string} notificationId Must be a valid notification ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroupPost(groupId: string, notificationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroupPost(groupId, notificationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a Group Role by ID and returns the remaining roles.
         * @summary Delete Group Role
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupRoleId Must be a valid group role ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroupRole(groupId: string, groupRoleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupRole>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroupRole(groupId, groupRoleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single Group by ID.
         * @summary Get Group by ID
         * @param {string} groupId Must be a valid group ID.
         * @param {boolean} [includeRoles] Include roles for the Group object. Defaults to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroup(groupId: string, includeRoles?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroup(groupId, includeRoles, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the announcement for a Group. If no announcement has been made, then it returns **empty object**.  If an announcement exists, then it will always return all fields except `imageId` and `imageUrl` which may be null.
         * @summary Get Group Announcement
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupAnnouncements(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupAnnouncement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupAnnouncements(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of audit logs for a Group.
         * @summary Get Group Audit Logs
         * @param {string} groupId Must be a valid group ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [startDate] The start date of the search range.
         * @param {string} [endDate] The end date of the search range.
         * @param {string} [actorIds] The comma-separated actor ids to search for.
         * @param {string} [eventTypes] The comma-separated event types to search for.
         * @param {string} [targetIds] The comma-separated target ids to search for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupAuditLogs(groupId: string, n?: number, offset?: number, startDate?: string, endDate?: string, actorIds?: string, eventTypes?: string, targetIds?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedGroupAuditLogEntryList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupAuditLogs(groupId, n, offset, startDate, endDate, actorIds, eventTypes, targetIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of banned users for a Group.
         * @summary Get Group Bans
         * @param {string} groupId Must be a valid group ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupBans(groupId: string, n?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupBans(groupId, n, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of images for a Group gallery.
         * @summary Get Group Gallery Images
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupGalleryId Must be a valid group gallery ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {boolean} [approved] If specified, only returns images that have been approved or not approved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupGalleryImages(groupId: string, groupGalleryId: string, n?: number, offset?: number, approved?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupGalleryImage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupGalleryImages(groupId, groupGalleryId, n, offset, approved, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of group instances
         * @summary Get Group Instances
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupInstances(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupInstance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupInstances(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of members that have been invited to the Group.
         * @summary Get Group Invites Sent
         * @param {string} groupId Must be a valid group ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupInvites(groupId: string, n?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupInvites(groupId, n, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a LimitedGroup Member.
         * @summary Get Group Member
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupMember(groupId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupLimitedMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupMember(groupId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a List of all **other** Group Members. This endpoint will never return the user calling the endpoint. Information about the user calling the endpoint must be found in the `myMember` field of the Group object.
         * @summary List Group Members
         * @param {string} groupId Must be a valid group ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {GroupSearchSort} [sort] The sort order of Group Member results
         * @param {string} [roleId] Only returns members with a specific groupRoleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupMembers(groupId: string, n?: number, offset?: number, sort?: GroupSearchSort, roleId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupMembers(groupId, n, offset, sort, roleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a List of all possible/available permissions for a Group.
         * @summary List Group Permissions
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupPermissions(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupPermission>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupPermissions(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get posts from a Group
         * @summary Get posts from a Group
         * @param {string} groupId Must be a valid group ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {boolean} [publicOnly] See public posts only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupPosts(groupId: string, n?: number, offset?: number, publicOnly?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGroupPosts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupPosts(groupId, n, offset, publicOnly, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of members that have requested to join the Group.
         * @summary Get Group Join Requests
         * @param {string} groupId Must be a valid group ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {boolean} [blocked] See blocked join requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupRequests(groupId: string, n?: number, offset?: number, blocked?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupRequests(groupId, n, offset, blocked, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Obtain predefined templates for group roles
         * @summary Get Group Role Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupRoleTemplates(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: GroupRoleTemplateValues; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupRoleTemplates(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a Group Role by ID.
         * @summary Get Group Roles
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupRoles(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupRole>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupRoles(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Join a Group by ID and returns the member object.
         * @summary Join Group
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async joinGroup(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.joinGroup(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Kicks a Group Member from the Group. The current user must have the \"Remove Group Members\" permission.
         * @summary Kick Group Member
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kickGroupMember(groupId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.kickGroupMember(groupId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Leave a group by ID.
         * @summary Leave Group
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveGroup(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveGroup(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes a Role from a Group Member
         * @summary Remove Role from GroupMember
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {string} groupRoleId Must be a valid group role ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeGroupMemberRole(groupId: string, userId: string, groupRoleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeGroupMemberRole(groupId, userId, groupRoleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Responds to a Group Join Request with Accept/Deny
         * @summary Respond Group Join request
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {RespondGroupJoinRequest} respondGroupJoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async respondGroupJoinRequest(groupId: string, userId: string, respondGroupJoinRequest: RespondGroupJoinRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.respondGroupJoinRequest(groupId, userId, respondGroupJoinRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Searches Groups by name or shortCode
         * @summary Search Group
         * @param {string} [query] Query to search for, can be either Group Name or Group shortCode
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {number} [n] The number of objects to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchGroups(query?: string, offset?: number, n?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LimitedGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchGroups(query, offset, n, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unbans a user from a Group.
         * @summary Unban Group Member
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unbanGroupMember(groupId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unbanGroupMember(groupId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a Group and returns it.
         * @summary Update Group
         * @param {string} groupId Must be a valid group ID.
         * @param {UpdateGroupRequest} [updateGroupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroup(groupId: string, updateGroupRequest?: UpdateGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroup(groupId, updateGroupRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a gallery for a Group.
         * @summary Update Group Gallery
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupGalleryId Must be a valid group gallery ID.
         * @param {UpdateGroupGalleryRequest} [updateGroupGalleryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroupGallery(groupId: string, groupGalleryId: string, updateGroupGalleryRequest?: UpdateGroupGalleryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupGallery>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroupGallery(groupId, groupGalleryId, updateGroupGalleryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a Group Member
         * @summary Update Group Member
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {UpdateGroupMemberRequest} [updateGroupMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroupMember(groupId: string, userId: string, updateGroupMemberRequest?: UpdateGroupMemberRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupLimitedMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroupMember(groupId, userId, updateGroupMemberRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edits a Group post
         * @summary Edits a Group post
         * @param {string} groupId Must be a valid group ID.
         * @param {string} notificationId Must be a valid notification ID.
         * @param {CreateGroupPostRequest} createGroupPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroupPost(groupId: string, notificationId: string, createGroupPostRequest: CreateGroupPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupPost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroupPost(groupId, notificationId, createGroupPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates whether the user is representing the group.  When `isRepresenting` is set to `true`, this flag will be set to `false` for all other groups
         * @summary Update Group Representation
         * @param {string} groupId Must be a valid group ID.
         * @param {UpdateGroupRepresentationRequest} updateGroupRepresentationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroupRepresentation(groupId: string, updateGroupRepresentationRequest: UpdateGroupRepresentationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroupRepresentation(groupId, updateGroupRepresentationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a group role by ID.
         * @summary Update Group Role
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupRoleId Must be a valid group role ID.
         * @param {UpdateGroupRoleRequest} [updateGroupRoleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroupRole(groupId: string, groupRoleId: string, updateGroupRoleRequest?: UpdateGroupRoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupRole>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroupRole(groupId, groupRoleId, updateGroupRoleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * Adds an image to a Group gallery.
         * @summary Add Group Gallery Image
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupGalleryId Must be a valid group gallery ID.
         * @param {AddGroupGalleryImageRequest} addGroupGalleryImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroupGalleryImage(groupId: string, groupGalleryId: string, addGroupGalleryImageRequest: AddGroupGalleryImageRequest, options?: any): AxiosPromise<GroupGalleryImage> {
            return localVarFp.addGroupGalleryImage(groupId, groupGalleryId, addGroupGalleryImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a Role to a Group Member
         * @summary Add Role to GroupMember
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {string} groupRoleId Must be a valid group role ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroupMemberRole(groupId: string, userId: string, groupRoleId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.addGroupMemberRole(groupId, userId, groupRoleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a post in a Group.
         * @summary Create a post in a Group
         * @param {string} groupId Must be a valid group ID.
         * @param {CreateGroupPostRequest} createGroupPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroupPost(groupId: string, createGroupPostRequest: CreateGroupPostRequest, options?: any): AxiosPromise<GroupPost> {
            return localVarFp.addGroupPost(groupId, createGroupPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Bans a user from a Group.
         * @summary Ban Group Member
         * @param {string} groupId Must be a valid group ID.
         * @param {BanGroupMemberRequest} banGroupMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banGroupMember(groupId: string, banGroupMemberRequest: BanGroupMemberRequest, options?: any): AxiosPromise<GroupMember> {
            return localVarFp.banGroupMember(groupId, banGroupMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancels a request sent to join the group.
         * @summary Cancel Group Join Request
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelGroupRequest(groupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.cancelGroupRequest(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Group and returns a Group object. **Requires VRC+ Subscription.**
         * @summary Create Group
         * @param {CreateGroupRequest} createGroupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(createGroupRequest: CreateGroupRequest, options?: any): AxiosPromise<Group> {
            return localVarFp.createGroup(createGroupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates an Announcement for a Group. Warning: This will also remove all announcements. To make proper announcements, use the posts endpoint instead
         * @summary Create Group Announcement
         * @param {string} groupId Must be a valid group ID.
         * @param {CreateGroupAnnouncementRequest} createGroupAnnouncementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupAnnouncement(groupId: string, createGroupAnnouncementRequest: CreateGroupAnnouncementRequest, options?: any): AxiosPromise<GroupAnnouncement> {
            return localVarFp.createGroupAnnouncement(groupId, createGroupAnnouncementRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a gallery for a Group.
         * @summary Create Group Gallery
         * @param {string} groupId Must be a valid group ID.
         * @param {CreateGroupGalleryRequest} createGroupGalleryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupGallery(groupId: string, createGroupGalleryRequest: CreateGroupGalleryRequest, options?: any): AxiosPromise<GroupGallery> {
            return localVarFp.createGroupGallery(groupId, createGroupGalleryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends an invite to a user to join the group.
         * @summary Invite User to Group
         * @param {string} groupId Must be a valid group ID.
         * @param {CreateGroupInviteRequest} createGroupInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupInvite(groupId: string, createGroupInviteRequest: CreateGroupInviteRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createGroupInvite(groupId, createGroupInviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Group role.
         * @summary Create GroupRole
         * @param {string} groupId Must be a valid group ID.
         * @param {CreateGroupRoleRequest} createGroupRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupRole(groupId: string, createGroupRoleRequest: CreateGroupRoleRequest, options?: any): AxiosPromise<GroupRole> {
            return localVarFp.createGroupRole(groupId, createGroupRoleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a Group.
         * @summary Delete Group
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupId: string, options?: any): AxiosPromise<Success> {
            return localVarFp.deleteGroup(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the announcement for a Group.
         * @summary Delete Group Announcement
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupAnnouncement(groupId: string, options?: any): AxiosPromise<Success> {
            return localVarFp.deleteGroupAnnouncement(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a gallery for a Group.
         * @summary Delete Group Gallery
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupGalleryId Must be a valid group gallery ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupGallery(groupId: string, groupGalleryId: string, options?: any): AxiosPromise<Success> {
            return localVarFp.deleteGroupGallery(groupId, groupGalleryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an image from a Group gallery.
         * @summary Delete Group Gallery Image
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupGalleryId Must be a valid group gallery ID.
         * @param {string} groupGalleryImageId Must be a valid group gallery image ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupGalleryImage(groupId: string, groupGalleryId: string, groupGalleryImageId: string, options?: any): AxiosPromise<Success> {
            return localVarFp.deleteGroupGalleryImage(groupId, groupGalleryId, groupGalleryImageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an Group invite sent to a User
         * @summary Delete User Invite
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupInvite(groupId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGroupInvite(groupId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Group post
         * @summary Delete a Group post
         * @param {string} groupId Must be a valid group ID.
         * @param {string} notificationId Must be a valid notification ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupPost(groupId: string, notificationId: string, options?: any): AxiosPromise<Success> {
            return localVarFp.deleteGroupPost(groupId, notificationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a Group Role by ID and returns the remaining roles.
         * @summary Delete Group Role
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupRoleId Must be a valid group role ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupRole(groupId: string, groupRoleId: string, options?: any): AxiosPromise<Array<GroupRole>> {
            return localVarFp.deleteGroupRole(groupId, groupRoleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single Group by ID.
         * @summary Get Group by ID
         * @param {string} groupId Must be a valid group ID.
         * @param {boolean} [includeRoles] Include roles for the Group object. Defaults to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupId: string, includeRoles?: boolean, options?: any): AxiosPromise<Group> {
            return localVarFp.getGroup(groupId, includeRoles, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the announcement for a Group. If no announcement has been made, then it returns **empty object**.  If an announcement exists, then it will always return all fields except `imageId` and `imageUrl` which may be null.
         * @summary Get Group Announcement
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupAnnouncements(groupId: string, options?: any): AxiosPromise<GroupAnnouncement> {
            return localVarFp.getGroupAnnouncements(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of audit logs for a Group.
         * @summary Get Group Audit Logs
         * @param {string} groupId Must be a valid group ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [startDate] The start date of the search range.
         * @param {string} [endDate] The end date of the search range.
         * @param {string} [actorIds] The comma-separated actor ids to search for.
         * @param {string} [eventTypes] The comma-separated event types to search for.
         * @param {string} [targetIds] The comma-separated target ids to search for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupAuditLogs(groupId: string, n?: number, offset?: number, startDate?: string, endDate?: string, actorIds?: string, eventTypes?: string, targetIds?: string, options?: any): AxiosPromise<PaginatedGroupAuditLogEntryList> {
            return localVarFp.getGroupAuditLogs(groupId, n, offset, startDate, endDate, actorIds, eventTypes, targetIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of banned users for a Group.
         * @summary Get Group Bans
         * @param {string} groupId Must be a valid group ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupBans(groupId: string, n?: number, offset?: number, options?: any): AxiosPromise<Array<GroupMember>> {
            return localVarFp.getGroupBans(groupId, n, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of images for a Group gallery.
         * @summary Get Group Gallery Images
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupGalleryId Must be a valid group gallery ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {boolean} [approved] If specified, only returns images that have been approved or not approved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupGalleryImages(groupId: string, groupGalleryId: string, n?: number, offset?: number, approved?: boolean, options?: any): AxiosPromise<Array<GroupGalleryImage>> {
            return localVarFp.getGroupGalleryImages(groupId, groupGalleryId, n, offset, approved, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of group instances
         * @summary Get Group Instances
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupInstances(groupId: string, options?: any): AxiosPromise<Array<GroupInstance>> {
            return localVarFp.getGroupInstances(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of members that have been invited to the Group.
         * @summary Get Group Invites Sent
         * @param {string} groupId Must be a valid group ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupInvites(groupId: string, n?: number, offset?: number, options?: any): AxiosPromise<Array<GroupMember>> {
            return localVarFp.getGroupInvites(groupId, n, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a LimitedGroup Member.
         * @summary Get Group Member
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMember(groupId: string, userId: string, options?: any): AxiosPromise<GroupLimitedMember> {
            return localVarFp.getGroupMember(groupId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a List of all **other** Group Members. This endpoint will never return the user calling the endpoint. Information about the user calling the endpoint must be found in the `myMember` field of the Group object.
         * @summary List Group Members
         * @param {string} groupId Must be a valid group ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {GroupSearchSort} [sort] The sort order of Group Member results
         * @param {string} [roleId] Only returns members with a specific groupRoleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMembers(groupId: string, n?: number, offset?: number, sort?: GroupSearchSort, roleId?: string, options?: any): AxiosPromise<Array<GroupMember>> {
            return localVarFp.getGroupMembers(groupId, n, offset, sort, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a List of all possible/available permissions for a Group.
         * @summary List Group Permissions
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPermissions(groupId: string, options?: any): AxiosPromise<Array<GroupPermission>> {
            return localVarFp.getGroupPermissions(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get posts from a Group
         * @summary Get posts from a Group
         * @param {string} groupId Must be a valid group ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {boolean} [publicOnly] See public posts only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPosts(groupId: string, n?: number, offset?: number, publicOnly?: boolean, options?: any): AxiosPromise<GetGroupPosts200Response> {
            return localVarFp.getGroupPosts(groupId, n, offset, publicOnly, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of members that have requested to join the Group.
         * @summary Get Group Join Requests
         * @param {string} groupId Must be a valid group ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {boolean} [blocked] See blocked join requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupRequests(groupId: string, n?: number, offset?: number, blocked?: boolean, options?: any): AxiosPromise<Array<GroupMember>> {
            return localVarFp.getGroupRequests(groupId, n, offset, blocked, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtain predefined templates for group roles
         * @summary Get Group Role Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupRoleTemplates(options?: any): AxiosPromise<{ [key: string]: GroupRoleTemplateValues; }> {
            return localVarFp.getGroupRoleTemplates(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Group Role by ID.
         * @summary Get Group Roles
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupRoles(groupId: string, options?: any): AxiosPromise<Array<GroupRole>> {
            return localVarFp.getGroupRoles(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Join a Group by ID and returns the member object.
         * @summary Join Group
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinGroup(groupId: string, options?: any): AxiosPromise<GroupMember> {
            return localVarFp.joinGroup(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Kicks a Group Member from the Group. The current user must have the \"Remove Group Members\" permission.
         * @summary Kick Group Member
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kickGroupMember(groupId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.kickGroupMember(groupId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Leave a group by ID.
         * @summary Leave Group
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveGroup(groupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.leaveGroup(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a Role from a Group Member
         * @summary Remove Role from GroupMember
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {string} groupRoleId Must be a valid group role ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeGroupMemberRole(groupId: string, userId: string, groupRoleId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.removeGroupMemberRole(groupId, userId, groupRoleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Responds to a Group Join Request with Accept/Deny
         * @summary Respond Group Join request
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {RespondGroupJoinRequest} respondGroupJoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        respondGroupJoinRequest(groupId: string, userId: string, respondGroupJoinRequest: RespondGroupJoinRequest, options?: any): AxiosPromise<void> {
            return localVarFp.respondGroupJoinRequest(groupId, userId, respondGroupJoinRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Searches Groups by name or shortCode
         * @summary Search Group
         * @param {string} [query] Query to search for, can be either Group Name or Group shortCode
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {number} [n] The number of objects to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGroups(query?: string, offset?: number, n?: number, options?: any): AxiosPromise<Array<LimitedGroup>> {
            return localVarFp.searchGroups(query, offset, n, options).then((request) => request(axios, basePath));
        },
        /**
         * Unbans a user from a Group.
         * @summary Unban Group Member
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbanGroupMember(groupId: string, userId: string, options?: any): AxiosPromise<GroupMember> {
            return localVarFp.unbanGroupMember(groupId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a Group and returns it.
         * @summary Update Group
         * @param {string} groupId Must be a valid group ID.
         * @param {UpdateGroupRequest} [updateGroupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(groupId: string, updateGroupRequest?: UpdateGroupRequest, options?: any): AxiosPromise<Group> {
            return localVarFp.updateGroup(groupId, updateGroupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a gallery for a Group.
         * @summary Update Group Gallery
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupGalleryId Must be a valid group gallery ID.
         * @param {UpdateGroupGalleryRequest} [updateGroupGalleryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupGallery(groupId: string, groupGalleryId: string, updateGroupGalleryRequest?: UpdateGroupGalleryRequest, options?: any): AxiosPromise<GroupGallery> {
            return localVarFp.updateGroupGallery(groupId, groupGalleryId, updateGroupGalleryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a Group Member
         * @summary Update Group Member
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {UpdateGroupMemberRequest} [updateGroupMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupMember(groupId: string, userId: string, updateGroupMemberRequest?: UpdateGroupMemberRequest, options?: any): AxiosPromise<GroupLimitedMember> {
            return localVarFp.updateGroupMember(groupId, userId, updateGroupMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Edits a Group post
         * @summary Edits a Group post
         * @param {string} groupId Must be a valid group ID.
         * @param {string} notificationId Must be a valid notification ID.
         * @param {CreateGroupPostRequest} createGroupPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupPost(groupId: string, notificationId: string, createGroupPostRequest: CreateGroupPostRequest, options?: any): AxiosPromise<GroupPost> {
            return localVarFp.updateGroupPost(groupId, notificationId, createGroupPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates whether the user is representing the group.  When `isRepresenting` is set to `true`, this flag will be set to `false` for all other groups
         * @summary Update Group Representation
         * @param {string} groupId Must be a valid group ID.
         * @param {UpdateGroupRepresentationRequest} updateGroupRepresentationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupRepresentation(groupId: string, updateGroupRepresentationRequest: UpdateGroupRepresentationRequest, options?: any): AxiosPromise<Success> {
            return localVarFp.updateGroupRepresentation(groupId, updateGroupRepresentationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a group role by ID.
         * @summary Update Group Role
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupRoleId Must be a valid group role ID.
         * @param {UpdateGroupRoleRequest} [updateGroupRoleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupRole(groupId: string, groupRoleId: string, updateGroupRoleRequest?: UpdateGroupRoleRequest, options?: any): AxiosPromise<Array<GroupRole>> {
            return localVarFp.updateGroupRole(groupId, groupRoleId, updateGroupRoleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * Adds an image to a Group gallery.
     * @summary Add Group Gallery Image
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupGalleryId Must be a valid group gallery ID.
     * @param {AddGroupGalleryImageRequest} addGroupGalleryImageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public addGroupGalleryImage(groupId: string, groupGalleryId: string, addGroupGalleryImageRequest: AddGroupGalleryImageRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).addGroupGalleryImage(groupId, groupGalleryId, addGroupGalleryImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a Role to a Group Member
     * @summary Add Role to GroupMember
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {string} groupRoleId Must be a valid group role ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public addGroupMemberRole(groupId: string, userId: string, groupRoleId: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).addGroupMemberRole(groupId, userId, groupRoleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a post in a Group.
     * @summary Create a post in a Group
     * @param {string} groupId Must be a valid group ID.
     * @param {CreateGroupPostRequest} createGroupPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public addGroupPost(groupId: string, createGroupPostRequest: CreateGroupPostRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).addGroupPost(groupId, createGroupPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Bans a user from a Group.
     * @summary Ban Group Member
     * @param {string} groupId Must be a valid group ID.
     * @param {BanGroupMemberRequest} banGroupMemberRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public banGroupMember(groupId: string, banGroupMemberRequest: BanGroupMemberRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).banGroupMember(groupId, banGroupMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancels a request sent to join the group.
     * @summary Cancel Group Join Request
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public cancelGroupRequest(groupId: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).cancelGroupRequest(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Group and returns a Group object. **Requires VRC+ Subscription.**
     * @summary Create Group
     * @param {CreateGroupRequest} createGroupRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public createGroup(createGroupRequest: CreateGroupRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).createGroup(createGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates an Announcement for a Group. Warning: This will also remove all announcements. To make proper announcements, use the posts endpoint instead
     * @summary Create Group Announcement
     * @param {string} groupId Must be a valid group ID.
     * @param {CreateGroupAnnouncementRequest} createGroupAnnouncementRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public createGroupAnnouncement(groupId: string, createGroupAnnouncementRequest: CreateGroupAnnouncementRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).createGroupAnnouncement(groupId, createGroupAnnouncementRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a gallery for a Group.
     * @summary Create Group Gallery
     * @param {string} groupId Must be a valid group ID.
     * @param {CreateGroupGalleryRequest} createGroupGalleryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public createGroupGallery(groupId: string, createGroupGalleryRequest: CreateGroupGalleryRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).createGroupGallery(groupId, createGroupGalleryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends an invite to a user to join the group.
     * @summary Invite User to Group
     * @param {string} groupId Must be a valid group ID.
     * @param {CreateGroupInviteRequest} createGroupInviteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public createGroupInvite(groupId: string, createGroupInviteRequest: CreateGroupInviteRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).createGroupInvite(groupId, createGroupInviteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Group role.
     * @summary Create GroupRole
     * @param {string} groupId Must be a valid group ID.
     * @param {CreateGroupRoleRequest} createGroupRoleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public createGroupRole(groupId: string, createGroupRoleRequest: CreateGroupRoleRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).createGroupRole(groupId, createGroupRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a Group.
     * @summary Delete Group
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deleteGroup(groupId: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deleteGroup(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the announcement for a Group.
     * @summary Delete Group Announcement
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deleteGroupAnnouncement(groupId: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deleteGroupAnnouncement(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a gallery for a Group.
     * @summary Delete Group Gallery
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupGalleryId Must be a valid group gallery ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deleteGroupGallery(groupId: string, groupGalleryId: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deleteGroupGallery(groupId, groupGalleryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an image from a Group gallery.
     * @summary Delete Group Gallery Image
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupGalleryId Must be a valid group gallery ID.
     * @param {string} groupGalleryImageId Must be a valid group gallery image ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deleteGroupGalleryImage(groupId: string, groupGalleryId: string, groupGalleryImageId: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deleteGroupGalleryImage(groupId, groupGalleryId, groupGalleryImageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an Group invite sent to a User
     * @summary Delete User Invite
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deleteGroupInvite(groupId: string, userId: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deleteGroupInvite(groupId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Group post
     * @summary Delete a Group post
     * @param {string} groupId Must be a valid group ID.
     * @param {string} notificationId Must be a valid notification ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deleteGroupPost(groupId: string, notificationId: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deleteGroupPost(groupId, notificationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a Group Role by ID and returns the remaining roles.
     * @summary Delete Group Role
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupRoleId Must be a valid group role ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deleteGroupRole(groupId: string, groupRoleId: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deleteGroupRole(groupId, groupRoleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single Group by ID.
     * @summary Get Group by ID
     * @param {string} groupId Must be a valid group ID.
     * @param {boolean} [includeRoles] Include roles for the Group object. Defaults to false.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroup(groupId: string, includeRoles?: boolean, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroup(groupId, includeRoles, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the announcement for a Group. If no announcement has been made, then it returns **empty object**.  If an announcement exists, then it will always return all fields except `imageId` and `imageUrl` which may be null.
     * @summary Get Group Announcement
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupAnnouncements(groupId: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupAnnouncements(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of audit logs for a Group.
     * @summary Get Group Audit Logs
     * @param {string} groupId Must be a valid group ID.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [startDate] The start date of the search range.
     * @param {string} [endDate] The end date of the search range.
     * @param {string} [actorIds] The comma-separated actor ids to search for.
     * @param {string} [eventTypes] The comma-separated event types to search for.
     * @param {string} [targetIds] The comma-separated target ids to search for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupAuditLogs(groupId: string, n?: number, offset?: number, startDate?: string, endDate?: string, actorIds?: string, eventTypes?: string, targetIds?: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupAuditLogs(groupId, n, offset, startDate, endDate, actorIds, eventTypes, targetIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of banned users for a Group.
     * @summary Get Group Bans
     * @param {string} groupId Must be a valid group ID.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupBans(groupId: string, n?: number, offset?: number, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupBans(groupId, n, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of images for a Group gallery.
     * @summary Get Group Gallery Images
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupGalleryId Must be a valid group gallery ID.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {boolean} [approved] If specified, only returns images that have been approved or not approved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupGalleryImages(groupId: string, groupGalleryId: string, n?: number, offset?: number, approved?: boolean, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupGalleryImages(groupId, groupGalleryId, n, offset, approved, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of group instances
     * @summary Get Group Instances
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupInstances(groupId: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupInstances(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of members that have been invited to the Group.
     * @summary Get Group Invites Sent
     * @param {string} groupId Must be a valid group ID.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupInvites(groupId: string, n?: number, offset?: number, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupInvites(groupId, n, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a LimitedGroup Member.
     * @summary Get Group Member
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupMember(groupId: string, userId: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupMember(groupId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a List of all **other** Group Members. This endpoint will never return the user calling the endpoint. Information about the user calling the endpoint must be found in the `myMember` field of the Group object.
     * @summary List Group Members
     * @param {string} groupId Must be a valid group ID.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {GroupSearchSort} [sort] The sort order of Group Member results
     * @param {string} [roleId] Only returns members with a specific groupRoleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupMembers(groupId: string, n?: number, offset?: number, sort?: GroupSearchSort, roleId?: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupMembers(groupId, n, offset, sort, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a List of all possible/available permissions for a Group.
     * @summary List Group Permissions
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupPermissions(groupId: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupPermissions(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get posts from a Group
     * @summary Get posts from a Group
     * @param {string} groupId Must be a valid group ID.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {boolean} [publicOnly] See public posts only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupPosts(groupId: string, n?: number, offset?: number, publicOnly?: boolean, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupPosts(groupId, n, offset, publicOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of members that have requested to join the Group.
     * @summary Get Group Join Requests
     * @param {string} groupId Must be a valid group ID.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {boolean} [blocked] See blocked join requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupRequests(groupId: string, n?: number, offset?: number, blocked?: boolean, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupRequests(groupId, n, offset, blocked, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtain predefined templates for group roles
     * @summary Get Group Role Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupRoleTemplates(options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupRoleTemplates(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Group Role by ID.
     * @summary Get Group Roles
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupRoles(groupId: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupRoles(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Join a Group by ID and returns the member object.
     * @summary Join Group
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public joinGroup(groupId: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).joinGroup(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kicks a Group Member from the Group. The current user must have the \"Remove Group Members\" permission.
     * @summary Kick Group Member
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public kickGroupMember(groupId: string, userId: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).kickGroupMember(groupId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Leave a group by ID.
     * @summary Leave Group
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public leaveGroup(groupId: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).leaveGroup(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a Role from a Group Member
     * @summary Remove Role from GroupMember
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {string} groupRoleId Must be a valid group role ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public removeGroupMemberRole(groupId: string, userId: string, groupRoleId: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).removeGroupMemberRole(groupId, userId, groupRoleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Responds to a Group Join Request with Accept/Deny
     * @summary Respond Group Join request
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {RespondGroupJoinRequest} respondGroupJoinRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public respondGroupJoinRequest(groupId: string, userId: string, respondGroupJoinRequest: RespondGroupJoinRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).respondGroupJoinRequest(groupId, userId, respondGroupJoinRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searches Groups by name or shortCode
     * @summary Search Group
     * @param {string} [query] Query to search for, can be either Group Name or Group shortCode
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {number} [n] The number of objects to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public searchGroups(query?: string, offset?: number, n?: number, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).searchGroups(query, offset, n, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unbans a user from a Group.
     * @summary Unban Group Member
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public unbanGroupMember(groupId: string, userId: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).unbanGroupMember(groupId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a Group and returns it.
     * @summary Update Group
     * @param {string} groupId Must be a valid group ID.
     * @param {UpdateGroupRequest} [updateGroupRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public updateGroup(groupId: string, updateGroupRequest?: UpdateGroupRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).updateGroup(groupId, updateGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a gallery for a Group.
     * @summary Update Group Gallery
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupGalleryId Must be a valid group gallery ID.
     * @param {UpdateGroupGalleryRequest} [updateGroupGalleryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public updateGroupGallery(groupId: string, groupGalleryId: string, updateGroupGalleryRequest?: UpdateGroupGalleryRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).updateGroupGallery(groupId, groupGalleryId, updateGroupGalleryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a Group Member
     * @summary Update Group Member
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {UpdateGroupMemberRequest} [updateGroupMemberRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public updateGroupMember(groupId: string, userId: string, updateGroupMemberRequest?: UpdateGroupMemberRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).updateGroupMember(groupId, userId, updateGroupMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edits a Group post
     * @summary Edits a Group post
     * @param {string} groupId Must be a valid group ID.
     * @param {string} notificationId Must be a valid notification ID.
     * @param {CreateGroupPostRequest} createGroupPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public updateGroupPost(groupId: string, notificationId: string, createGroupPostRequest: CreateGroupPostRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).updateGroupPost(groupId, notificationId, createGroupPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates whether the user is representing the group.  When `isRepresenting` is set to `true`, this flag will be set to `false` for all other groups
     * @summary Update Group Representation
     * @param {string} groupId Must be a valid group ID.
     * @param {UpdateGroupRepresentationRequest} updateGroupRepresentationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public updateGroupRepresentation(groupId: string, updateGroupRepresentationRequest: UpdateGroupRepresentationRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).updateGroupRepresentation(groupId, updateGroupRepresentationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a group role by ID.
     * @summary Update Group Role
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupRoleId Must be a valid group role ID.
     * @param {UpdateGroupRoleRequest} [updateGroupRoleRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public updateGroupRole(groupId: string, groupRoleId: string, updateGroupRoleRequest?: UpdateGroupRoleRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).updateGroupRole(groupId, groupRoleId, updateGroupRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InstancesApi - axios parameter creator
 * @export
 */
export const InstancesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Close an instance or update the closedAt time when it will be closed.  You can only close an instance if the ownerId is yourself or if the instance owner is a group and you have the `group-instance-manage` permission.
         * @summary Close Instance
         * @param {string} worldId Must be a valid world ID.
         * @param {string} instanceId Must be a valid instance ID.
         * @param {boolean} [hardClose] Whether to hard close the instance. Defaults to false.
         * @param {string} [closedAt] The time after which users won\&#39;t be allowed to join the instances. If omitted, the instance will be closed immediately.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeInstance: async (worldId: string, instanceId: string, hardClose?: boolean, closedAt?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'worldId' is not null or undefined
            assertParamExists('closeInstance', 'worldId', worldId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('closeInstance', 'instanceId', instanceId)
            const localVarPath = `/instances/{worldId}:{instanceId}`
                .replace(`{${"worldId"}}`, encodeURIComponent(String(worldId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            if (hardClose !== undefined) {
                localVarQueryParameter['hardClose'] = hardClose;
            }

            if (closedAt !== undefined) {
                localVarQueryParameter['closedAt'] = (closedAt as any instanceof Date) ?
                    (closedAt as any).toISOString() :
                    closedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an instance
         * @summary Create Instance
         * @param {CreateInstanceRequest} createInstanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInstance: async (createInstanceRequest: CreateInstanceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createInstanceRequest' is not null or undefined
            assertParamExists('createInstance', 'createInstanceRequest', createInstanceRequest)
            const localVarPath = `/instances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createInstanceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.  If an invalid instanceId is provided, this endpoint will simply return \"null\"!
         * @summary Get Instance
         * @param {string} worldId Must be a valid world ID.
         * @param {string} instanceId Must be a valid instance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstance: async (worldId: string, instanceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'worldId' is not null or undefined
            assertParamExists('getInstance', 'worldId', worldId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('getInstance', 'instanceId', instanceId)
            const localVarPath = `/instances/{worldId}:{instanceId}`
                .replace(`{${"worldId"}}`, encodeURIComponent(String(worldId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.
         * @summary Get Instance By Short Name
         * @param {string} shortName Must be a valid instance short name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceByShortName: async (shortName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shortName' is not null or undefined
            assertParamExists('getInstanceByShortName', 'shortName', shortName)
            const localVarPath = `/instances/s/{shortName}`
                .replace(`{${"shortName"}}`, encodeURIComponent(String(shortName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an instance short name.
         * @summary Get Instance Short Name
         * @param {string} worldId Must be a valid world ID.
         * @param {string} instanceId Must be a valid instance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShortName: async (worldId: string, instanceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'worldId' is not null or undefined
            assertParamExists('getShortName', 'worldId', worldId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('getShortName', 'instanceId', instanceId)
            const localVarPath = `/instances/{worldId}:{instanceId}/shortName`
                .replace(`{${"worldId"}}`, encodeURIComponent(String(worldId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InstancesApi - functional programming interface
 * @export
 */
export const InstancesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InstancesApiAxiosParamCreator(configuration)
    return {
        /**
         * Close an instance or update the closedAt time when it will be closed.  You can only close an instance if the ownerId is yourself or if the instance owner is a group and you have the `group-instance-manage` permission.
         * @summary Close Instance
         * @param {string} worldId Must be a valid world ID.
         * @param {string} instanceId Must be a valid instance ID.
         * @param {boolean} [hardClose] Whether to hard close the instance. Defaults to false.
         * @param {string} [closedAt] The time after which users won\&#39;t be allowed to join the instances. If omitted, the instance will be closed immediately.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async closeInstance(worldId: string, instanceId: string, hardClose?: boolean, closedAt?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Instance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.closeInstance(worldId, instanceId, hardClose, closedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create an instance
         * @summary Create Instance
         * @param {CreateInstanceRequest} createInstanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInstance(createInstanceRequest: CreateInstanceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Instance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInstance(createInstanceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.  If an invalid instanceId is provided, this endpoint will simply return \"null\"!
         * @summary Get Instance
         * @param {string} worldId Must be a valid world ID.
         * @param {string} instanceId Must be a valid instance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstance(worldId: string, instanceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Instance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInstance(worldId, instanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.
         * @summary Get Instance By Short Name
         * @param {string} shortName Must be a valid instance short name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstanceByShortName(shortName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Instance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInstanceByShortName(shortName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an instance short name.
         * @summary Get Instance Short Name
         * @param {string} worldId Must be a valid world ID.
         * @param {string} instanceId Must be a valid instance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShortName(worldId: string, instanceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstanceShortNameResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShortName(worldId, instanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InstancesApi - factory interface
 * @export
 */
export const InstancesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InstancesApiFp(configuration)
    return {
        /**
         * Close an instance or update the closedAt time when it will be closed.  You can only close an instance if the ownerId is yourself or if the instance owner is a group and you have the `group-instance-manage` permission.
         * @summary Close Instance
         * @param {string} worldId Must be a valid world ID.
         * @param {string} instanceId Must be a valid instance ID.
         * @param {boolean} [hardClose] Whether to hard close the instance. Defaults to false.
         * @param {string} [closedAt] The time after which users won\&#39;t be allowed to join the instances. If omitted, the instance will be closed immediately.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeInstance(worldId: string, instanceId: string, hardClose?: boolean, closedAt?: string, options?: any): AxiosPromise<Instance> {
            return localVarFp.closeInstance(worldId, instanceId, hardClose, closedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an instance
         * @summary Create Instance
         * @param {CreateInstanceRequest} createInstanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInstance(createInstanceRequest: CreateInstanceRequest, options?: any): AxiosPromise<Instance> {
            return localVarFp.createInstance(createInstanceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.  If an invalid instanceId is provided, this endpoint will simply return \"null\"!
         * @summary Get Instance
         * @param {string} worldId Must be a valid world ID.
         * @param {string} instanceId Must be a valid instance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstance(worldId: string, instanceId: string, options?: any): AxiosPromise<Instance> {
            return localVarFp.getInstance(worldId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.
         * @summary Get Instance By Short Name
         * @param {string} shortName Must be a valid instance short name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceByShortName(shortName: string, options?: any): AxiosPromise<Instance> {
            return localVarFp.getInstanceByShortName(shortName, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an instance short name.
         * @summary Get Instance Short Name
         * @param {string} worldId Must be a valid world ID.
         * @param {string} instanceId Must be a valid instance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShortName(worldId: string, instanceId: string, options?: any): AxiosPromise<InstanceShortNameResponse> {
            return localVarFp.getShortName(worldId, instanceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InstancesApi - object-oriented interface
 * @export
 * @class InstancesApi
 * @extends {BaseAPI}
 */
export class InstancesApi extends BaseAPI {
    /**
     * Close an instance or update the closedAt time when it will be closed.  You can only close an instance if the ownerId is yourself or if the instance owner is a group and you have the `group-instance-manage` permission.
     * @summary Close Instance
     * @param {string} worldId Must be a valid world ID.
     * @param {string} instanceId Must be a valid instance ID.
     * @param {boolean} [hardClose] Whether to hard close the instance. Defaults to false.
     * @param {string} [closedAt] The time after which users won\&#39;t be allowed to join the instances. If omitted, the instance will be closed immediately.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public closeInstance(worldId: string, instanceId: string, hardClose?: boolean, closedAt?: string, options?: AxiosRequestConfig) {
        return InstancesApiFp(this.configuration).closeInstance(worldId, instanceId, hardClose, closedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an instance
     * @summary Create Instance
     * @param {CreateInstanceRequest} createInstanceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public createInstance(createInstanceRequest: CreateInstanceRequest, options?: AxiosRequestConfig) {
        return InstancesApiFp(this.configuration).createInstance(createInstanceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.  If an invalid instanceId is provided, this endpoint will simply return \"null\"!
     * @summary Get Instance
     * @param {string} worldId Must be a valid world ID.
     * @param {string} instanceId Must be a valid instance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public getInstance(worldId: string, instanceId: string, options?: AxiosRequestConfig) {
        return InstancesApiFp(this.configuration).getInstance(worldId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.
     * @summary Get Instance By Short Name
     * @param {string} shortName Must be a valid instance short name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public getInstanceByShortName(shortName: string, options?: AxiosRequestConfig) {
        return InstancesApiFp(this.configuration).getInstanceByShortName(shortName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an instance short name.
     * @summary Get Instance Short Name
     * @param {string} worldId Must be a valid world ID.
     * @param {string} instanceId Must be a valid instance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public getShortName(worldId: string, instanceId: string, options?: AxiosRequestConfig) {
        return InstancesApiFp(this.configuration).getShortName(worldId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InviteApi - axios parameter creator
 * @export
 */
export const InviteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a single Invite Message. This returns the exact same information but less than `getInviteMessages`. Admin Credentials are required to view messages of other users!  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
         * @summary Get Invite Message
         * @param {string} userId Must be a valid user ID.
         * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
         * @param {number} slot The message slot to fetch of a given message type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInviteMessage: async (userId: string, messageType: InviteMessageType, slot: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getInviteMessage', 'userId', userId)
            // verify required parameter 'messageType' is not null or undefined
            assertParamExists('getInviteMessage', 'messageType', messageType)
            // verify required parameter 'slot' is not null or undefined
            assertParamExists('getInviteMessage', 'slot', slot)
            const localVarPath = `/message/{userId}/{messageType}/{slot}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"messageType"}}`, encodeURIComponent(String(messageType)))
                .replace(`{${"slot"}}`, encodeURIComponent(String(slot)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all the users Invite Messages. Admin Credentials are required to view messages of other users!  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
         * @summary List Invite Messages
         * @param {string} userId Must be a valid user ID.
         * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInviteMessages: async (userId: string, messageType: InviteMessageType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getInviteMessages', 'userId', userId)
            // verify required parameter 'messageType' is not null or undefined
            assertParamExists('getInviteMessages', 'messageType', messageType)
            const localVarPath = `/message/{userId}/{messageType}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"messageType"}}`, encodeURIComponent(String(messageType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends self an invite to an instance
         * @summary Invite Myself To Instance
         * @param {string} worldId Must be a valid world ID.
         * @param {string} instanceId Must be a valid instance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteMyselfTo: async (worldId: string, instanceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'worldId' is not null or undefined
            assertParamExists('inviteMyselfTo', 'worldId', worldId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('inviteMyselfTo', 'instanceId', instanceId)
            const localVarPath = `/invite/myself/to/{worldId}:{instanceId}`
                .replace(`{${"worldId"}}`, encodeURIComponent(String(worldId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends an invite to a user. Returns the Notification of type `invite` that was sent.
         * @summary Invite User
         * @param {string} userId Must be a valid user ID.
         * @param {InviteRequest} inviteRequest Slot number of the Invite Message to use when inviting a user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUser: async (userId: string, inviteRequest: InviteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('inviteUser', 'userId', userId)
            // verify required parameter 'inviteRequest' is not null or undefined
            assertParamExists('inviteUser', 'inviteRequest', inviteRequest)
            const localVarPath = `/invite/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends an photo invite to a user. Returns the Notification of type `invite` that was sent.
         * @summary Invite User with photo
         * @param {string} userId Must be a valid user ID.
         * @param {File} image The binary blob of the png file.
         * @param {InviteRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUserWithPhoto: async (userId: string, image: File, data: InviteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('inviteUserWithPhoto', 'userId', userId)
            // verify required parameter 'image' is not null or undefined
            assertParamExists('inviteUserWithPhoto', 'image', image)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('inviteUserWithPhoto', 'data', data)
            const localVarPath = `/invite/{userId}/photo`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication authCookie required


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
            if (data !== undefined) { 
                localVarFormParams.append('data', new Blob([JSON.stringify(data)], { type: "application/json", }));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests an invite from a user. Returns the Notification of type `requestInvite` that was sent.
         * @summary Request Invite
         * @param {string} userId Must be a valid user ID.
         * @param {RequestInviteRequest} [requestInviteRequest] Slot number of the Request Message to use when request an invite.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestInvite: async (userId: string, requestInviteRequest?: RequestInviteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('requestInvite', 'userId', userId)
            const localVarPath = `/requestInvite/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestInviteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests with photo an invite from a user. Returns the Notification of type `requestInvite` that was sent.
         * @summary Request Invite with photo
         * @param {string} userId Must be a valid user ID.
         * @param {File} image The binary blob of the png file.
         * @param {RequestInviteRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestInviteWithPhoto: async (userId: string, image: File, data: RequestInviteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('requestInviteWithPhoto', 'userId', userId)
            // verify required parameter 'image' is not null or undefined
            assertParamExists('requestInviteWithPhoto', 'image', image)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('requestInviteWithPhoto', 'data', data)
            const localVarPath = `/requestInvite/{userId}/photo`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication authCookie required


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
            if (data !== undefined) { 
                localVarFormParams.append('data', new Blob([JSON.stringify(data)], { type: "application/json", }));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resets a single Invite Message back to its original message, and then returns a list of all of them. Admin Credentials are required to update messages of other users!  Resetting a message respects the rate-limit, so it is not possible to reset within the 60 minutes countdown. Resetting it does however not set the rate-limit to 60 like when editing it. It is possible to edit it right after resetting it. Trying to edit a message before the cooldown timer expires results in a 429 \"Too Fast Error\".  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite  The DELETE endpoint does not have/require any request body.
         * @summary Reset Invite Message
         * @param {string} userId Must be a valid user ID.
         * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
         * @param {number} slot The message slot to fetch of a given message type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetInviteMessage: async (userId: string, messageType: InviteMessageType, slot: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('resetInviteMessage', 'userId', userId)
            // verify required parameter 'messageType' is not null or undefined
            assertParamExists('resetInviteMessage', 'messageType', messageType)
            // verify required parameter 'slot' is not null or undefined
            assertParamExists('resetInviteMessage', 'slot', slot)
            const localVarPath = `/message/{userId}/{messageType}/{slot}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"messageType"}}`, encodeURIComponent(String(messageType)))
                .replace(`{${"slot"}}`, encodeURIComponent(String(slot)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Respond to an invite or invite request without accepting it. `:notificationId` is the ID of the requesting notification.  In case the notification being replied to is an invite, the `responseSlot` refers to a response message from the the `message` collection. In case the notification is an invite request, it will refer to one from the `requestResponse` collection instead.
         * @summary Respond Invite
         * @param {string} notificationId Must be a valid notification ID.
         * @param {InviteResponse} inviteResponse Slot number of the Response Message to use when responding to a user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        respondInvite: async (notificationId: string, inviteResponse: InviteResponse, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('respondInvite', 'notificationId', notificationId)
            // verify required parameter 'inviteResponse' is not null or undefined
            assertParamExists('respondInvite', 'inviteResponse', inviteResponse)
            const localVarPath = `/invite/{notificationId}/response`
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteResponse, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Respond with photo to an invite or invite request without accepting it. `:notificationId` is the ID of the requesting notification.  In case the notification being replied to is an invite, the `responseSlot` refers to a response message from the the `message` collection. In case the notification is an invite request, it will refer to one from the `requestResponse` collection instead.\'
         * @summary Respond Invite with photo
         * @param {string} notificationId Must be a valid notification ID.
         * @param {File} image The binary blob of the png file.
         * @param {InviteResponse} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        respondInviteWithPhoto: async (notificationId: string, image: File, data: InviteResponse, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('respondInviteWithPhoto', 'notificationId', notificationId)
            // verify required parameter 'image' is not null or undefined
            assertParamExists('respondInviteWithPhoto', 'image', image)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('respondInviteWithPhoto', 'data', data)
            const localVarPath = `/invite/{notificationId}/response/photo`
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication authCookie required


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
            if (data !== undefined) { 
                localVarFormParams.append('data', new Blob([JSON.stringify(data)], { type: "application/json", }));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a single Invite Message and then returns a list of all of them. Admin Credentials are required to update messages of other users!  Updating a message automatically sets the cooldown timer to 60 minutes. Trying to edit a message before the cooldown timer expires results in a 429 \"Too Fast Error\".  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
         * @summary Update Invite Message
         * @param {string} userId Must be a valid user ID.
         * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
         * @param {number} slot The message slot to fetch of a given message type.
         * @param {UpdateInviteMessageRequest} [updateInviteMessageRequest] Message of what to set the invite message to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInviteMessage: async (userId: string, messageType: InviteMessageType, slot: number, updateInviteMessageRequest?: UpdateInviteMessageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateInviteMessage', 'userId', userId)
            // verify required parameter 'messageType' is not null or undefined
            assertParamExists('updateInviteMessage', 'messageType', messageType)
            // verify required parameter 'slot' is not null or undefined
            assertParamExists('updateInviteMessage', 'slot', slot)
            const localVarPath = `/message/{userId}/{messageType}/{slot}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"messageType"}}`, encodeURIComponent(String(messageType)))
                .replace(`{${"slot"}}`, encodeURIComponent(String(slot)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateInviteMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InviteApi - functional programming interface
 * @export
 */
export const InviteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InviteApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a single Invite Message. This returns the exact same information but less than `getInviteMessages`. Admin Credentials are required to view messages of other users!  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
         * @summary Get Invite Message
         * @param {string} userId Must be a valid user ID.
         * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
         * @param {number} slot The message slot to fetch of a given message type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInviteMessage(userId: string, messageType: InviteMessageType, slot: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInviteMessage(userId, messageType, slot, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of all the users Invite Messages. Admin Credentials are required to view messages of other users!  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
         * @summary List Invite Messages
         * @param {string} userId Must be a valid user ID.
         * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInviteMessages(userId: string, messageType: InviteMessageType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InviteMessage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInviteMessages(userId, messageType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sends self an invite to an instance
         * @summary Invite Myself To Instance
         * @param {string} worldId Must be a valid world ID.
         * @param {string} instanceId Must be a valid instance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteMyselfTo(worldId: string, instanceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SentNotification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteMyselfTo(worldId, instanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sends an invite to a user. Returns the Notification of type `invite` that was sent.
         * @summary Invite User
         * @param {string} userId Must be a valid user ID.
         * @param {InviteRequest} inviteRequest Slot number of the Invite Message to use when inviting a user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteUser(userId: string, inviteRequest: InviteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SentNotification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteUser(userId, inviteRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sends an photo invite to a user. Returns the Notification of type `invite` that was sent.
         * @summary Invite User with photo
         * @param {string} userId Must be a valid user ID.
         * @param {File} image The binary blob of the png file.
         * @param {InviteRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteUserWithPhoto(userId: string, image: File, data: InviteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SentNotification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteUserWithPhoto(userId, image, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Requests an invite from a user. Returns the Notification of type `requestInvite` that was sent.
         * @summary Request Invite
         * @param {string} userId Must be a valid user ID.
         * @param {RequestInviteRequest} [requestInviteRequest] Slot number of the Request Message to use when request an invite.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestInvite(userId: string, requestInviteRequest?: RequestInviteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestInvite(userId, requestInviteRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Requests with photo an invite from a user. Returns the Notification of type `requestInvite` that was sent.
         * @summary Request Invite with photo
         * @param {string} userId Must be a valid user ID.
         * @param {File} image The binary blob of the png file.
         * @param {RequestInviteRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestInviteWithPhoto(userId: string, image: File, data: RequestInviteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestInviteWithPhoto(userId, image, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resets a single Invite Message back to its original message, and then returns a list of all of them. Admin Credentials are required to update messages of other users!  Resetting a message respects the rate-limit, so it is not possible to reset within the 60 minutes countdown. Resetting it does however not set the rate-limit to 60 like when editing it. It is possible to edit it right after resetting it. Trying to edit a message before the cooldown timer expires results in a 429 \"Too Fast Error\".  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite  The DELETE endpoint does not have/require any request body.
         * @summary Reset Invite Message
         * @param {string} userId Must be a valid user ID.
         * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
         * @param {number} slot The message slot to fetch of a given message type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetInviteMessage(userId: string, messageType: InviteMessageType, slot: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InviteMessage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetInviteMessage(userId, messageType, slot, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Respond to an invite or invite request without accepting it. `:notificationId` is the ID of the requesting notification.  In case the notification being replied to is an invite, the `responseSlot` refers to a response message from the the `message` collection. In case the notification is an invite request, it will refer to one from the `requestResponse` collection instead.
         * @summary Respond Invite
         * @param {string} notificationId Must be a valid notification ID.
         * @param {InviteResponse} inviteResponse Slot number of the Response Message to use when responding to a user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async respondInvite(notificationId: string, inviteResponse: InviteResponse, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.respondInvite(notificationId, inviteResponse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Respond with photo to an invite or invite request without accepting it. `:notificationId` is the ID of the requesting notification.  In case the notification being replied to is an invite, the `responseSlot` refers to a response message from the the `message` collection. In case the notification is an invite request, it will refer to one from the `requestResponse` collection instead.\'
         * @summary Respond Invite with photo
         * @param {string} notificationId Must be a valid notification ID.
         * @param {File} image The binary blob of the png file.
         * @param {InviteResponse} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async respondInviteWithPhoto(notificationId: string, image: File, data: InviteResponse, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.respondInviteWithPhoto(notificationId, image, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a single Invite Message and then returns a list of all of them. Admin Credentials are required to update messages of other users!  Updating a message automatically sets the cooldown timer to 60 minutes. Trying to edit a message before the cooldown timer expires results in a 429 \"Too Fast Error\".  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
         * @summary Update Invite Message
         * @param {string} userId Must be a valid user ID.
         * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
         * @param {number} slot The message slot to fetch of a given message type.
         * @param {UpdateInviteMessageRequest} [updateInviteMessageRequest] Message of what to set the invite message to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInviteMessage(userId: string, messageType: InviteMessageType, slot: number, updateInviteMessageRequest?: UpdateInviteMessageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InviteMessage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateInviteMessage(userId, messageType, slot, updateInviteMessageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InviteApi - factory interface
 * @export
 */
export const InviteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InviteApiFp(configuration)
    return {
        /**
         * Returns a single Invite Message. This returns the exact same information but less than `getInviteMessages`. Admin Credentials are required to view messages of other users!  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
         * @summary Get Invite Message
         * @param {string} userId Must be a valid user ID.
         * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
         * @param {number} slot The message slot to fetch of a given message type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInviteMessage(userId: string, messageType: InviteMessageType, slot: number, options?: any): AxiosPromise<InviteMessage> {
            return localVarFp.getInviteMessage(userId, messageType, slot, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all the users Invite Messages. Admin Credentials are required to view messages of other users!  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
         * @summary List Invite Messages
         * @param {string} userId Must be a valid user ID.
         * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInviteMessages(userId: string, messageType: InviteMessageType, options?: any): AxiosPromise<Array<InviteMessage>> {
            return localVarFp.getInviteMessages(userId, messageType, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends self an invite to an instance
         * @summary Invite Myself To Instance
         * @param {string} worldId Must be a valid world ID.
         * @param {string} instanceId Must be a valid instance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteMyselfTo(worldId: string, instanceId: string, options?: any): AxiosPromise<SentNotification> {
            return localVarFp.inviteMyselfTo(worldId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends an invite to a user. Returns the Notification of type `invite` that was sent.
         * @summary Invite User
         * @param {string} userId Must be a valid user ID.
         * @param {InviteRequest} inviteRequest Slot number of the Invite Message to use when inviting a user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUser(userId: string, inviteRequest: InviteRequest, options?: any): AxiosPromise<SentNotification> {
            return localVarFp.inviteUser(userId, inviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends an photo invite to a user. Returns the Notification of type `invite` that was sent.
         * @summary Invite User with photo
         * @param {string} userId Must be a valid user ID.
         * @param {File} image The binary blob of the png file.
         * @param {InviteRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUserWithPhoto(userId: string, image: File, data: InviteRequest, options?: any): AxiosPromise<SentNotification> {
            return localVarFp.inviteUserWithPhoto(userId, image, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Requests an invite from a user. Returns the Notification of type `requestInvite` that was sent.
         * @summary Request Invite
         * @param {string} userId Must be a valid user ID.
         * @param {RequestInviteRequest} [requestInviteRequest] Slot number of the Request Message to use when request an invite.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestInvite(userId: string, requestInviteRequest?: RequestInviteRequest, options?: any): AxiosPromise<Notification> {
            return localVarFp.requestInvite(userId, requestInviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Requests with photo an invite from a user. Returns the Notification of type `requestInvite` that was sent.
         * @summary Request Invite with photo
         * @param {string} userId Must be a valid user ID.
         * @param {File} image The binary blob of the png file.
         * @param {RequestInviteRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestInviteWithPhoto(userId: string, image: File, data: RequestInviteRequest, options?: any): AxiosPromise<Notification> {
            return localVarFp.requestInviteWithPhoto(userId, image, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Resets a single Invite Message back to its original message, and then returns a list of all of them. Admin Credentials are required to update messages of other users!  Resetting a message respects the rate-limit, so it is not possible to reset within the 60 minutes countdown. Resetting it does however not set the rate-limit to 60 like when editing it. It is possible to edit it right after resetting it. Trying to edit a message before the cooldown timer expires results in a 429 \"Too Fast Error\".  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite  The DELETE endpoint does not have/require any request body.
         * @summary Reset Invite Message
         * @param {string} userId Must be a valid user ID.
         * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
         * @param {number} slot The message slot to fetch of a given message type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetInviteMessage(userId: string, messageType: InviteMessageType, slot: number, options?: any): AxiosPromise<Array<InviteMessage>> {
            return localVarFp.resetInviteMessage(userId, messageType, slot, options).then((request) => request(axios, basePath));
        },
        /**
         * Respond to an invite or invite request without accepting it. `:notificationId` is the ID of the requesting notification.  In case the notification being replied to is an invite, the `responseSlot` refers to a response message from the the `message` collection. In case the notification is an invite request, it will refer to one from the `requestResponse` collection instead.
         * @summary Respond Invite
         * @param {string} notificationId Must be a valid notification ID.
         * @param {InviteResponse} inviteResponse Slot number of the Response Message to use when responding to a user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        respondInvite(notificationId: string, inviteResponse: InviteResponse, options?: any): AxiosPromise<Notification> {
            return localVarFp.respondInvite(notificationId, inviteResponse, options).then((request) => request(axios, basePath));
        },
        /**
         * Respond with photo to an invite or invite request without accepting it. `:notificationId` is the ID of the requesting notification.  In case the notification being replied to is an invite, the `responseSlot` refers to a response message from the the `message` collection. In case the notification is an invite request, it will refer to one from the `requestResponse` collection instead.\'
         * @summary Respond Invite with photo
         * @param {string} notificationId Must be a valid notification ID.
         * @param {File} image The binary blob of the png file.
         * @param {InviteResponse} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        respondInviteWithPhoto(notificationId: string, image: File, data: InviteResponse, options?: any): AxiosPromise<Notification> {
            return localVarFp.respondInviteWithPhoto(notificationId, image, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a single Invite Message and then returns a list of all of them. Admin Credentials are required to update messages of other users!  Updating a message automatically sets the cooldown timer to 60 minutes. Trying to edit a message before the cooldown timer expires results in a 429 \"Too Fast Error\".  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
         * @summary Update Invite Message
         * @param {string} userId Must be a valid user ID.
         * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
         * @param {number} slot The message slot to fetch of a given message type.
         * @param {UpdateInviteMessageRequest} [updateInviteMessageRequest] Message of what to set the invite message to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInviteMessage(userId: string, messageType: InviteMessageType, slot: number, updateInviteMessageRequest?: UpdateInviteMessageRequest, options?: any): AxiosPromise<Array<InviteMessage>> {
            return localVarFp.updateInviteMessage(userId, messageType, slot, updateInviteMessageRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InviteApi - object-oriented interface
 * @export
 * @class InviteApi
 * @extends {BaseAPI}
 */
export class InviteApi extends BaseAPI {
    /**
     * Returns a single Invite Message. This returns the exact same information but less than `getInviteMessages`. Admin Credentials are required to view messages of other users!  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
     * @summary Get Invite Message
     * @param {string} userId Must be a valid user ID.
     * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
     * @param {number} slot The message slot to fetch of a given message type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    public getInviteMessage(userId: string, messageType: InviteMessageType, slot: number, options?: AxiosRequestConfig) {
        return InviteApiFp(this.configuration).getInviteMessage(userId, messageType, slot, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all the users Invite Messages. Admin Credentials are required to view messages of other users!  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
     * @summary List Invite Messages
     * @param {string} userId Must be a valid user ID.
     * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    public getInviteMessages(userId: string, messageType: InviteMessageType, options?: AxiosRequestConfig) {
        return InviteApiFp(this.configuration).getInviteMessages(userId, messageType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends self an invite to an instance
     * @summary Invite Myself To Instance
     * @param {string} worldId Must be a valid world ID.
     * @param {string} instanceId Must be a valid instance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    public inviteMyselfTo(worldId: string, instanceId: string, options?: AxiosRequestConfig) {
        return InviteApiFp(this.configuration).inviteMyselfTo(worldId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends an invite to a user. Returns the Notification of type `invite` that was sent.
     * @summary Invite User
     * @param {string} userId Must be a valid user ID.
     * @param {InviteRequest} inviteRequest Slot number of the Invite Message to use when inviting a user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    public inviteUser(userId: string, inviteRequest: InviteRequest, options?: AxiosRequestConfig) {
        return InviteApiFp(this.configuration).inviteUser(userId, inviteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends an photo invite to a user. Returns the Notification of type `invite` that was sent.
     * @summary Invite User with photo
     * @param {string} userId Must be a valid user ID.
     * @param {File} image The binary blob of the png file.
     * @param {InviteRequest} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    public inviteUserWithPhoto(userId: string, image: File, data: InviteRequest, options?: AxiosRequestConfig) {
        return InviteApiFp(this.configuration).inviteUserWithPhoto(userId, image, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requests an invite from a user. Returns the Notification of type `requestInvite` that was sent.
     * @summary Request Invite
     * @param {string} userId Must be a valid user ID.
     * @param {RequestInviteRequest} [requestInviteRequest] Slot number of the Request Message to use when request an invite.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    public requestInvite(userId: string, requestInviteRequest?: RequestInviteRequest, options?: AxiosRequestConfig) {
        return InviteApiFp(this.configuration).requestInvite(userId, requestInviteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requests with photo an invite from a user. Returns the Notification of type `requestInvite` that was sent.
     * @summary Request Invite with photo
     * @param {string} userId Must be a valid user ID.
     * @param {File} image The binary blob of the png file.
     * @param {RequestInviteRequest} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    public requestInviteWithPhoto(userId: string, image: File, data: RequestInviteRequest, options?: AxiosRequestConfig) {
        return InviteApiFp(this.configuration).requestInviteWithPhoto(userId, image, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resets a single Invite Message back to its original message, and then returns a list of all of them. Admin Credentials are required to update messages of other users!  Resetting a message respects the rate-limit, so it is not possible to reset within the 60 minutes countdown. Resetting it does however not set the rate-limit to 60 like when editing it. It is possible to edit it right after resetting it. Trying to edit a message before the cooldown timer expires results in a 429 \"Too Fast Error\".  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite  The DELETE endpoint does not have/require any request body.
     * @summary Reset Invite Message
     * @param {string} userId Must be a valid user ID.
     * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
     * @param {number} slot The message slot to fetch of a given message type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    public resetInviteMessage(userId: string, messageType: InviteMessageType, slot: number, options?: AxiosRequestConfig) {
        return InviteApiFp(this.configuration).resetInviteMessage(userId, messageType, slot, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Respond to an invite or invite request without accepting it. `:notificationId` is the ID of the requesting notification.  In case the notification being replied to is an invite, the `responseSlot` refers to a response message from the the `message` collection. In case the notification is an invite request, it will refer to one from the `requestResponse` collection instead.
     * @summary Respond Invite
     * @param {string} notificationId Must be a valid notification ID.
     * @param {InviteResponse} inviteResponse Slot number of the Response Message to use when responding to a user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    public respondInvite(notificationId: string, inviteResponse: InviteResponse, options?: AxiosRequestConfig) {
        return InviteApiFp(this.configuration).respondInvite(notificationId, inviteResponse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Respond with photo to an invite or invite request without accepting it. `:notificationId` is the ID of the requesting notification.  In case the notification being replied to is an invite, the `responseSlot` refers to a response message from the the `message` collection. In case the notification is an invite request, it will refer to one from the `requestResponse` collection instead.\'
     * @summary Respond Invite with photo
     * @param {string} notificationId Must be a valid notification ID.
     * @param {File} image The binary blob of the png file.
     * @param {InviteResponse} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    public respondInviteWithPhoto(notificationId: string, image: File, data: InviteResponse, options?: AxiosRequestConfig) {
        return InviteApiFp(this.configuration).respondInviteWithPhoto(notificationId, image, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a single Invite Message and then returns a list of all of them. Admin Credentials are required to update messages of other users!  Updating a message automatically sets the cooldown timer to 60 minutes. Trying to edit a message before the cooldown timer expires results in a 429 \"Too Fast Error\".  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
     * @summary Update Invite Message
     * @param {string} userId Must be a valid user ID.
     * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
     * @param {number} slot The message slot to fetch of a given message type.
     * @param {UpdateInviteMessageRequest} [updateInviteMessageRequest] Message of what to set the invite message to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    public updateInviteMessage(userId: string, messageType: InviteMessageType, slot: number, updateInviteMessageRequest?: UpdateInviteMessageRequest, options?: AxiosRequestConfig) {
        return InviteApiFp(this.configuration).updateInviteMessage(userId, messageType, slot, updateInviteMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * JamsApi - axios parameter creator
 * @export
 */
export const JamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a jam.
         * @summary Show jam information
         * @param {string} jamId Must be a valid query ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJam: async (jamId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jamId' is not null or undefined
            assertParamExists('getJam', 'jamId', jamId)
            const localVarPath = `/jams/{jamId}`
                .replace(`{${"jamId"}}`, encodeURIComponent(String(jamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all submissions of a jam.
         * @summary Show jam submissions
         * @param {string} jamId Must be a valid query ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJamSubmissions: async (jamId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jamId' is not null or undefined
            assertParamExists('getJamSubmissions', 'jamId', jamId)
            const localVarPath = `/jams/{jamId}/submissions`
                .replace(`{${"jamId"}}`, encodeURIComponent(String(jamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists World Jams or Avatar Jams, both currently running and ones that have ended.  `isActive` is used to select only active or already ended jams.  `type` is used to select only world or avatar jams, and can only take `world` or `avatar`. ``
         * @summary Show jams list
         * @param {string} [type] Only show jams of this type (&#x60;avatar&#x60; or &#x60;world&#x60;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJams: async (type?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/jams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JamsApi - functional programming interface
 * @export
 */
export const JamsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JamsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a jam.
         * @summary Show jam information
         * @param {string} jamId Must be a valid query ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJam(jamId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Jam>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJam(jamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all submissions of a jam.
         * @summary Show jam submissions
         * @param {string} jamId Must be a valid query ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJamSubmissions(jamId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Submission>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJamSubmissions(jamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists World Jams or Avatar Jams, both currently running and ones that have ended.  `isActive` is used to select only active or already ended jams.  `type` is used to select only world or avatar jams, and can only take `world` or `avatar`. ``
         * @summary Show jams list
         * @param {string} [type] Only show jams of this type (&#x60;avatar&#x60; or &#x60;world&#x60;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJams(type?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Jam>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJams(type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JamsApi - factory interface
 * @export
 */
export const JamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JamsApiFp(configuration)
    return {
        /**
         * Returns a jam.
         * @summary Show jam information
         * @param {string} jamId Must be a valid query ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJam(jamId: string, options?: any): AxiosPromise<Jam> {
            return localVarFp.getJam(jamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all submissions of a jam.
         * @summary Show jam submissions
         * @param {string} jamId Must be a valid query ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJamSubmissions(jamId: string, options?: any): AxiosPromise<Array<Submission>> {
            return localVarFp.getJamSubmissions(jamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists World Jams or Avatar Jams, both currently running and ones that have ended.  `isActive` is used to select only active or already ended jams.  `type` is used to select only world or avatar jams, and can only take `world` or `avatar`. ``
         * @summary Show jams list
         * @param {string} [type] Only show jams of this type (&#x60;avatar&#x60; or &#x60;world&#x60;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJams(type?: string, options?: any): AxiosPromise<Array<Jam>> {
            return localVarFp.getJams(type, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JamsApi - object-oriented interface
 * @export
 * @class JamsApi
 * @extends {BaseAPI}
 */
export class JamsApi extends BaseAPI {
    /**
     * Returns a jam.
     * @summary Show jam information
     * @param {string} jamId Must be a valid query ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JamsApi
     */
    public getJam(jamId: string, options?: AxiosRequestConfig) {
        return JamsApiFp(this.configuration).getJam(jamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all submissions of a jam.
     * @summary Show jam submissions
     * @param {string} jamId Must be a valid query ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JamsApi
     */
    public getJamSubmissions(jamId: string, options?: AxiosRequestConfig) {
        return JamsApiFp(this.configuration).getJamSubmissions(jamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists World Jams or Avatar Jams, both currently running and ones that have ended.  `isActive` is used to select only active or already ended jams.  `type` is used to select only world or avatar jams, and can only take `world` or `avatar`. ``
     * @summary Show jams list
     * @param {string} [type] Only show jams of this type (&#x60;avatar&#x60; or &#x60;world&#x60;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JamsApi
     */
    public getJams(type?: string, options?: AxiosRequestConfig) {
        return JamsApiFp(this.configuration).getJams(type, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MiscellaneousApi - axios parameter creator
 * @export
 */
export const MiscellaneousApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of all permissions currently granted by the user. Permissions are assigned e.g. by subscribing to VRC+.
         * @summary Get Assigned Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedPermissions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the CSS code to the frontend React website.
         * @summary Download CSS
         * @param {'public' | 'internal'} [variant] Specifies which &#x60;variant&#x60; of the site. Public is the end-user site, while &#x60;internal&#x60; is the staff-only site with special pages for moderation and management.
         * @param {string} [branch] Specifies which git branch the site should load frontend source code from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCSS: async (variant?: 'public' | 'internal', branch?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/css/app.css`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (variant !== undefined) {
                localVarQueryParameter['variant'] = variant;
            }

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API config contains configuration that the clients needs to work properly.  Currently the most important value here is `clientApiKey` which is used for all other API endpoints.
         * @summary Fetch API Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the current number of online users.  **NOTE:** The response type is not a JSON object, but a simple JSON integer.
         * @summary Current Online Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentOnlineUsers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/visits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ~~Gets the overall health status, the server name, and the current build version tag of the API.~~  **DEPRECATED:** VRChat has suddenly restricted this endpoint for unknown reasons, and now always return 401 Unauthorized.
         * @summary Check API Health
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getHealth: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * IPS (Info Push System) is a system for VRChat to push out dynamic information to the client. This is primarily used by the Quick-Menu info banners, but can also be used to e.g. alert you to update your game to the latest version.  `include` is used to query what Information Pushes should be included in the response. If include is missing or empty, then no notices will normally be returned. This is an \"any of\" search.  `require` is used to limit what Information Pushes should be included in the response. This is usually used in combination with `include`, and is an \"all of\" search.
         * @summary Show Information Notices
         * @param {string} [require] Tags to include (comma-separated). All of the tags needs to be present.
         * @param {string} [include] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfoPush: async (require?: string, include?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/infoPush`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (require !== undefined) {
                localVarQueryParameter['require'] = require;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the JavaScript code to the frontend React website.
         * @summary Download JavaScript
         * @param {'public' | 'internal'} [variant] Specifies which &#x60;variant&#x60; of the site. Public is the end-user site, while &#x60;internal&#x60; is the staff-only site with special pages for moderation and management.
         * @param {string} [branch] Specifies which git branch the site should load frontend source code from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJavaScript: async (variant?: 'public' | 'internal', branch?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/js/app.js`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (variant !== undefined) {
                localVarQueryParameter['variant'] = variant;
            }

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single permission. This endpoint is pretty useless, as it returns the exact same information as `/auth/permissions`.
         * @summary Get Permission
         * @param {string} permissionId Must be a valid permission ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermission: async (permissionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'permissionId' is not null or undefined
            assertParamExists('getPermission', 'permissionId', permissionId)
            const localVarPath = `/permissions/{permissionId}`
                .replace(`{${"permissionId"}}`, encodeURIComponent(String(permissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the current time of the API server.  **NOTE:** The response type is not a JSON object, but a simple JSON string.
         * @summary Current System Time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemTime: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/time`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MiscellaneousApi - functional programming interface
 * @export
 */
export const MiscellaneousApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MiscellaneousApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of all permissions currently granted by the user. Permissions are assigned e.g. by subscribing to VRC+.
         * @summary Get Assigned Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssignedPermissions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Permission>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssignedPermissions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches the CSS code to the frontend React website.
         * @summary Download CSS
         * @param {'public' | 'internal'} [variant] Specifies which &#x60;variant&#x60; of the site. Public is the end-user site, while &#x60;internal&#x60; is the staff-only site with special pages for moderation and management.
         * @param {string} [branch] Specifies which git branch the site should load frontend source code from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCSS(variant?: 'public' | 'internal', branch?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCSS(variant, branch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API config contains configuration that the clients needs to work properly.  Currently the most important value here is `clientApiKey` which is used for all other API endpoints.
         * @summary Fetch API Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfig(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the current number of online users.  **NOTE:** The response type is not a JSON object, but a simple JSON integer.
         * @summary Current Online Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentOnlineUsers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentOnlineUsers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ~~Gets the overall health status, the server name, and the current build version tag of the API.~~  **DEPRECATED:** VRChat has suddenly restricted this endpoint for unknown reasons, and now always return 401 Unauthorized.
         * @summary Check API Health
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getHealth(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIHealth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHealth(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * IPS (Info Push System) is a system for VRChat to push out dynamic information to the client. This is primarily used by the Quick-Menu info banners, but can also be used to e.g. alert you to update your game to the latest version.  `include` is used to query what Information Pushes should be included in the response. If include is missing or empty, then no notices will normally be returned. This is an \"any of\" search.  `require` is used to limit what Information Pushes should be included in the response. This is usually used in combination with `include`, and is an \"all of\" search.
         * @summary Show Information Notices
         * @param {string} [require] Tags to include (comma-separated). All of the tags needs to be present.
         * @param {string} [include] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInfoPush(require?: string, include?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InfoPush>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInfoPush(require, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches the JavaScript code to the frontend React website.
         * @summary Download JavaScript
         * @param {'public' | 'internal'} [variant] Specifies which &#x60;variant&#x60; of the site. Public is the end-user site, while &#x60;internal&#x60; is the staff-only site with special pages for moderation and management.
         * @param {string} [branch] Specifies which git branch the site should load frontend source code from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJavaScript(variant?: 'public' | 'internal', branch?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJavaScript(variant, branch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single permission. This endpoint is pretty useless, as it returns the exact same information as `/auth/permissions`.
         * @summary Get Permission
         * @param {string} permissionId Must be a valid permission ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPermission(permissionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPermission(permissionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the current time of the API server.  **NOTE:** The response type is not a JSON object, but a simple JSON string.
         * @summary Current System Time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemTime(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemTime(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MiscellaneousApi - factory interface
 * @export
 */
export const MiscellaneousApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MiscellaneousApiFp(configuration)
    return {
        /**
         * Returns a list of all permissions currently granted by the user. Permissions are assigned e.g. by subscribing to VRC+.
         * @summary Get Assigned Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedPermissions(options?: any): AxiosPromise<Array<Permission>> {
            return localVarFp.getAssignedPermissions(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches the CSS code to the frontend React website.
         * @summary Download CSS
         * @param {'public' | 'internal'} [variant] Specifies which &#x60;variant&#x60; of the site. Public is the end-user site, while &#x60;internal&#x60; is the staff-only site with special pages for moderation and management.
         * @param {string} [branch] Specifies which git branch the site should load frontend source code from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCSS(variant?: 'public' | 'internal', branch?: string, options?: any): AxiosPromise<string> {
            return localVarFp.getCSS(variant, branch, options).then((request) => request(axios, basePath));
        },
        /**
         * API config contains configuration that the clients needs to work properly.  Currently the most important value here is `clientApiKey` which is used for all other API endpoints.
         * @summary Fetch API Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(options?: any): AxiosPromise<APIConfig> {
            return localVarFp.getConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the current number of online users.  **NOTE:** The response type is not a JSON object, but a simple JSON integer.
         * @summary Current Online Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentOnlineUsers(options?: any): AxiosPromise<number> {
            return localVarFp.getCurrentOnlineUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * ~~Gets the overall health status, the server name, and the current build version tag of the API.~~  **DEPRECATED:** VRChat has suddenly restricted this endpoint for unknown reasons, and now always return 401 Unauthorized.
         * @summary Check API Health
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getHealth(options?: any): AxiosPromise<APIHealth> {
            return localVarFp.getHealth(options).then((request) => request(axios, basePath));
        },
        /**
         * IPS (Info Push System) is a system for VRChat to push out dynamic information to the client. This is primarily used by the Quick-Menu info banners, but can also be used to e.g. alert you to update your game to the latest version.  `include` is used to query what Information Pushes should be included in the response. If include is missing or empty, then no notices will normally be returned. This is an \"any of\" search.  `require` is used to limit what Information Pushes should be included in the response. This is usually used in combination with `include`, and is an \"all of\" search.
         * @summary Show Information Notices
         * @param {string} [require] Tags to include (comma-separated). All of the tags needs to be present.
         * @param {string} [include] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfoPush(require?: string, include?: string, options?: any): AxiosPromise<Array<InfoPush>> {
            return localVarFp.getInfoPush(require, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches the JavaScript code to the frontend React website.
         * @summary Download JavaScript
         * @param {'public' | 'internal'} [variant] Specifies which &#x60;variant&#x60; of the site. Public is the end-user site, while &#x60;internal&#x60; is the staff-only site with special pages for moderation and management.
         * @param {string} [branch] Specifies which git branch the site should load frontend source code from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJavaScript(variant?: 'public' | 'internal', branch?: string, options?: any): AxiosPromise<string> {
            return localVarFp.getJavaScript(variant, branch, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single permission. This endpoint is pretty useless, as it returns the exact same information as `/auth/permissions`.
         * @summary Get Permission
         * @param {string} permissionId Must be a valid permission ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermission(permissionId: string, options?: any): AxiosPromise<Permission> {
            return localVarFp.getPermission(permissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the current time of the API server.  **NOTE:** The response type is not a JSON object, but a simple JSON string.
         * @summary Current System Time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemTime(options?: any): AxiosPromise<string> {
            return localVarFp.getSystemTime(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MiscellaneousApi - object-oriented interface
 * @export
 * @class MiscellaneousApi
 * @extends {BaseAPI}
 */
export class MiscellaneousApi extends BaseAPI {
    /**
     * Returns a list of all permissions currently granted by the user. Permissions are assigned e.g. by subscribing to VRC+.
     * @summary Get Assigned Permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public getAssignedPermissions(options?: AxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).getAssignedPermissions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches the CSS code to the frontend React website.
     * @summary Download CSS
     * @param {'public' | 'internal'} [variant] Specifies which &#x60;variant&#x60; of the site. Public is the end-user site, while &#x60;internal&#x60; is the staff-only site with special pages for moderation and management.
     * @param {string} [branch] Specifies which git branch the site should load frontend source code from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public getCSS(variant?: 'public' | 'internal', branch?: string, options?: AxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).getCSS(variant, branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API config contains configuration that the clients needs to work properly.  Currently the most important value here is `clientApiKey` which is used for all other API endpoints.
     * @summary Fetch API Config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public getConfig(options?: AxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).getConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the current number of online users.  **NOTE:** The response type is not a JSON object, but a simple JSON integer.
     * @summary Current Online Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public getCurrentOnlineUsers(options?: AxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).getCurrentOnlineUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ~~Gets the overall health status, the server name, and the current build version tag of the API.~~  **DEPRECATED:** VRChat has suddenly restricted this endpoint for unknown reasons, and now always return 401 Unauthorized.
     * @summary Check API Health
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public getHealth(options?: AxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).getHealth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * IPS (Info Push System) is a system for VRChat to push out dynamic information to the client. This is primarily used by the Quick-Menu info banners, but can also be used to e.g. alert you to update your game to the latest version.  `include` is used to query what Information Pushes should be included in the response. If include is missing or empty, then no notices will normally be returned. This is an \"any of\" search.  `require` is used to limit what Information Pushes should be included in the response. This is usually used in combination with `include`, and is an \"all of\" search.
     * @summary Show Information Notices
     * @param {string} [require] Tags to include (comma-separated). All of the tags needs to be present.
     * @param {string} [include] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public getInfoPush(require?: string, include?: string, options?: AxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).getInfoPush(require, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches the JavaScript code to the frontend React website.
     * @summary Download JavaScript
     * @param {'public' | 'internal'} [variant] Specifies which &#x60;variant&#x60; of the site. Public is the end-user site, while &#x60;internal&#x60; is the staff-only site with special pages for moderation and management.
     * @param {string} [branch] Specifies which git branch the site should load frontend source code from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public getJavaScript(variant?: 'public' | 'internal', branch?: string, options?: AxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).getJavaScript(variant, branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single permission. This endpoint is pretty useless, as it returns the exact same information as `/auth/permissions`.
     * @summary Get Permission
     * @param {string} permissionId Must be a valid permission ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public getPermission(permissionId: string, options?: AxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).getPermission(permissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the current time of the API server.  **NOTE:** The response type is not a JSON object, but a simple JSON string.
     * @summary Current System Time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public getSystemTime(options?: AxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).getSystemTime(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Accept a friend request by notification `frq_` ID. Friend requests can be found using the NotificationsAPI `getNotifications` by filtering of type `friendRequest`.
         * @summary Accept Friend Request
         * @param {string} notificationId Must be a valid notification ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptFriendRequest: async (notificationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('acceptFriendRequest', 'notificationId', notificationId)
            const localVarPath = `/auth/user/notifications/{notificationId}/accept`
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clear **all** notifications.
         * @summary Clear All Notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearNotifications: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/user/notifications/clear`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a notification.
         * @summary Delete Notification
         * @param {string} notificationId Must be a valid notification ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotification: async (notificationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('deleteNotification', 'notificationId', notificationId)
            const localVarPath = `/auth/user/notifications/{notificationId}/hide`
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a notification by notification `not_` ID.
         * @summary Show notification
         * @param {string} notificationId Must be a valid notification ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotification: async (notificationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('getNotification', 'notificationId', notificationId)
            const localVarPath = `/auth/user/notifications/{notificationId}`
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all of the current user\'s notifications.
         * @summary List Notifications
         * @param {string} [type] Only send notifications of this type (can use &#x60;all&#x60; for all). This parameter no longer does anything, and is deprecated.
         * @param {boolean} [sent] Return notifications sent by the user. Must be false or omitted.
         * @param {boolean} [hidden] Whether to return hidden or non-hidden notifications. True only allowed on type &#x60;friendRequest&#x60;.
         * @param {string} [after] Only return notifications sent after this Date. Ignored if type is &#x60;friendRequest&#x60;.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications: async (type?: string, sent?: boolean, hidden?: boolean, after?: string, n?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/user/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (sent !== undefined) {
                localVarQueryParameter['sent'] = sent;
            }

            if (hidden !== undefined) {
                localVarQueryParameter['hidden'] = hidden;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (n !== undefined) {
                localVarQueryParameter['n'] = n;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark a notification as seen.
         * @summary Mark Notification As Read
         * @param {string} notificationId Must be a valid notification ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markNotificationAsRead: async (notificationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('markNotificationAsRead', 'notificationId', notificationId)
            const localVarPath = `/auth/user/notifications/{notificationId}/see`
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Accept a friend request by notification `frq_` ID. Friend requests can be found using the NotificationsAPI `getNotifications` by filtering of type `friendRequest`.
         * @summary Accept Friend Request
         * @param {string} notificationId Must be a valid notification ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptFriendRequest(notificationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptFriendRequest(notificationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Clear **all** notifications.
         * @summary Clear All Notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clearNotifications(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clearNotifications(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a notification.
         * @summary Delete Notification
         * @param {string} notificationId Must be a valid notification ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNotification(notificationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNotification(notificationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a notification by notification `not_` ID.
         * @summary Show notification
         * @param {string} notificationId Must be a valid notification ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotification(notificationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotification(notificationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all of the current user\'s notifications.
         * @summary List Notifications
         * @param {string} [type] Only send notifications of this type (can use &#x60;all&#x60; for all). This parameter no longer does anything, and is deprecated.
         * @param {boolean} [sent] Return notifications sent by the user. Must be false or omitted.
         * @param {boolean} [hidden] Whether to return hidden or non-hidden notifications. True only allowed on type &#x60;friendRequest&#x60;.
         * @param {string} [after] Only return notifications sent after this Date. Ignored if type is &#x60;friendRequest&#x60;.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotifications(type?: string, sent?: boolean, hidden?: boolean, after?: string, n?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Notification>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotifications(type, sent, hidden, after, n, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mark a notification as seen.
         * @summary Mark Notification As Read
         * @param {string} notificationId Must be a valid notification ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markNotificationAsRead(notificationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markNotificationAsRead(notificationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationsApiFp(configuration)
    return {
        /**
         * Accept a friend request by notification `frq_` ID. Friend requests can be found using the NotificationsAPI `getNotifications` by filtering of type `friendRequest`.
         * @summary Accept Friend Request
         * @param {string} notificationId Must be a valid notification ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptFriendRequest(notificationId: string, options?: any): AxiosPromise<Success> {
            return localVarFp.acceptFriendRequest(notificationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Clear **all** notifications.
         * @summary Clear All Notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearNotifications(options?: any): AxiosPromise<Success> {
            return localVarFp.clearNotifications(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a notification.
         * @summary Delete Notification
         * @param {string} notificationId Must be a valid notification ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotification(notificationId: string, options?: any): AxiosPromise<Notification> {
            return localVarFp.deleteNotification(notificationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a notification by notification `not_` ID.
         * @summary Show notification
         * @param {string} notificationId Must be a valid notification ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotification(notificationId: string, options?: any): AxiosPromise<Notification> {
            return localVarFp.getNotification(notificationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all of the current user\'s notifications.
         * @summary List Notifications
         * @param {string} [type] Only send notifications of this type (can use &#x60;all&#x60; for all). This parameter no longer does anything, and is deprecated.
         * @param {boolean} [sent] Return notifications sent by the user. Must be false or omitted.
         * @param {boolean} [hidden] Whether to return hidden or non-hidden notifications. True only allowed on type &#x60;friendRequest&#x60;.
         * @param {string} [after] Only return notifications sent after this Date. Ignored if type is &#x60;friendRequest&#x60;.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(type?: string, sent?: boolean, hidden?: boolean, after?: string, n?: number, offset?: number, options?: any): AxiosPromise<Array<Notification>> {
            return localVarFp.getNotifications(type, sent, hidden, after, n, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Mark a notification as seen.
         * @summary Mark Notification As Read
         * @param {string} notificationId Must be a valid notification ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markNotificationAsRead(notificationId: string, options?: any): AxiosPromise<Notification> {
            return localVarFp.markNotificationAsRead(notificationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     * Accept a friend request by notification `frq_` ID. Friend requests can be found using the NotificationsAPI `getNotifications` by filtering of type `friendRequest`.
     * @summary Accept Friend Request
     * @param {string} notificationId Must be a valid notification ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public acceptFriendRequest(notificationId: string, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).acceptFriendRequest(notificationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clear **all** notifications.
     * @summary Clear All Notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public clearNotifications(options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).clearNotifications(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a notification.
     * @summary Delete Notification
     * @param {string} notificationId Must be a valid notification ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public deleteNotification(notificationId: string, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).deleteNotification(notificationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a notification by notification `not_` ID.
     * @summary Show notification
     * @param {string} notificationId Must be a valid notification ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public getNotification(notificationId: string, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).getNotification(notificationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all of the current user\'s notifications.
     * @summary List Notifications
     * @param {string} [type] Only send notifications of this type (can use &#x60;all&#x60; for all). This parameter no longer does anything, and is deprecated.
     * @param {boolean} [sent] Return notifications sent by the user. Must be false or omitted.
     * @param {boolean} [hidden] Whether to return hidden or non-hidden notifications. True only allowed on type &#x60;friendRequest&#x60;.
     * @param {string} [after] Only return notifications sent after this Date. Ignored if type is &#x60;friendRequest&#x60;.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public getNotifications(type?: string, sent?: boolean, hidden?: boolean, after?: string, n?: number, offset?: number, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).getNotifications(type, sent, hidden, after, n, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark a notification as seen.
     * @summary Mark Notification As Read
     * @param {string} notificationId Must be a valid notification ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public markNotificationAsRead(notificationId: string, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).markNotificationAsRead(notificationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlayermoderationApi - axios parameter creator
 * @export
 */
export const PlayermoderationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  **This will delete every single player moderation you\'ve ever made.**
         * @summary Clear All Player Moderations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearAllPlayerModerations: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/user/playermoderations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all player moderations made by **you**.  This endpoint does not have pagination, and will return *all* results. Use query parameters to limit your query if needed.
         * @summary Search Player Moderations
         * @param {string} [type] Must be one of PlayerModerationType, except unblock. Unblocking simply removes a block.
         * @param {string} [targetUserId] Must be valid UserID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerModerations: async (type?: string, targetUserId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/user/playermoderations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (targetUserId !== undefined) {
                localVarQueryParameter['targetUserId'] = targetUserId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Moderate a user, e.g. unmute them or show their avatar.  Please see the [Player Moderation docs](https://vrchatapi.github.io/docs/api/#tag--playermoderation) on what playerModerations are, and how they differ from staff moderations.
         * @summary Moderate User
         * @param {ModerateUserRequest} moderateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moderateUser: async (moderateUserRequest: ModerateUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'moderateUserRequest' is not null or undefined
            assertParamExists('moderateUser', 'moderateUserRequest', moderateUserRequest)
            const localVarPath = `/auth/user/playermoderations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moderateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a player moderation previously added through `moderateUser`. E.g if you previously have shown their avatar, but now want to reset it to default.
         * @summary Unmoderate User
         * @param {ModerateUserRequest} moderateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unmoderateUser: async (moderateUserRequest: ModerateUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'moderateUserRequest' is not null or undefined
            assertParamExists('unmoderateUser', 'moderateUserRequest', moderateUserRequest)
            const localVarPath = `/auth/user/unplayermoderate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moderateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlayermoderationApi - functional programming interface
 * @export
 */
export const PlayermoderationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlayermoderationApiAxiosParamCreator(configuration)
    return {
        /**
         *  **This will delete every single player moderation you\'ve ever made.**
         * @summary Clear All Player Moderations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clearAllPlayerModerations(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clearAllPlayerModerations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of all player moderations made by **you**.  This endpoint does not have pagination, and will return *all* results. Use query parameters to limit your query if needed.
         * @summary Search Player Moderations
         * @param {string} [type] Must be one of PlayerModerationType, except unblock. Unblocking simply removes a block.
         * @param {string} [targetUserId] Must be valid UserID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayerModerations(type?: string, targetUserId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlayerModeration>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayerModerations(type, targetUserId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Moderate a user, e.g. unmute them or show their avatar.  Please see the [Player Moderation docs](https://vrchatapi.github.io/docs/api/#tag--playermoderation) on what playerModerations are, and how they differ from staff moderations.
         * @summary Moderate User
         * @param {ModerateUserRequest} moderateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moderateUser(moderateUserRequest: ModerateUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerModeration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moderateUser(moderateUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes a player moderation previously added through `moderateUser`. E.g if you previously have shown their avatar, but now want to reset it to default.
         * @summary Unmoderate User
         * @param {ModerateUserRequest} moderateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unmoderateUser(moderateUserRequest: ModerateUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unmoderateUser(moderateUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlayermoderationApi - factory interface
 * @export
 */
export const PlayermoderationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlayermoderationApiFp(configuration)
    return {
        /**
         *  **This will delete every single player moderation you\'ve ever made.**
         * @summary Clear All Player Moderations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearAllPlayerModerations(options?: any): AxiosPromise<Success> {
            return localVarFp.clearAllPlayerModerations(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all player moderations made by **you**.  This endpoint does not have pagination, and will return *all* results. Use query parameters to limit your query if needed.
         * @summary Search Player Moderations
         * @param {string} [type] Must be one of PlayerModerationType, except unblock. Unblocking simply removes a block.
         * @param {string} [targetUserId] Must be valid UserID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerModerations(type?: string, targetUserId?: string, options?: any): AxiosPromise<Array<PlayerModeration>> {
            return localVarFp.getPlayerModerations(type, targetUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Moderate a user, e.g. unmute them or show their avatar.  Please see the [Player Moderation docs](https://vrchatapi.github.io/docs/api/#tag--playermoderation) on what playerModerations are, and how they differ from staff moderations.
         * @summary Moderate User
         * @param {ModerateUserRequest} moderateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moderateUser(moderateUserRequest: ModerateUserRequest, options?: any): AxiosPromise<PlayerModeration> {
            return localVarFp.moderateUser(moderateUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a player moderation previously added through `moderateUser`. E.g if you previously have shown their avatar, but now want to reset it to default.
         * @summary Unmoderate User
         * @param {ModerateUserRequest} moderateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unmoderateUser(moderateUserRequest: ModerateUserRequest, options?: any): AxiosPromise<Success> {
            return localVarFp.unmoderateUser(moderateUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlayermoderationApi - object-oriented interface
 * @export
 * @class PlayermoderationApi
 * @extends {BaseAPI}
 */
export class PlayermoderationApi extends BaseAPI {
    /**
     *  **This will delete every single player moderation you\'ve ever made.**
     * @summary Clear All Player Moderations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayermoderationApi
     */
    public clearAllPlayerModerations(options?: AxiosRequestConfig) {
        return PlayermoderationApiFp(this.configuration).clearAllPlayerModerations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all player moderations made by **you**.  This endpoint does not have pagination, and will return *all* results. Use query parameters to limit your query if needed.
     * @summary Search Player Moderations
     * @param {string} [type] Must be one of PlayerModerationType, except unblock. Unblocking simply removes a block.
     * @param {string} [targetUserId] Must be valid UserID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayermoderationApi
     */
    public getPlayerModerations(type?: string, targetUserId?: string, options?: AxiosRequestConfig) {
        return PlayermoderationApiFp(this.configuration).getPlayerModerations(type, targetUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Moderate a user, e.g. unmute them or show their avatar.  Please see the [Player Moderation docs](https://vrchatapi.github.io/docs/api/#tag--playermoderation) on what playerModerations are, and how they differ from staff moderations.
     * @summary Moderate User
     * @param {ModerateUserRequest} moderateUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayermoderationApi
     */
    public moderateUser(moderateUserRequest: ModerateUserRequest, options?: AxiosRequestConfig) {
        return PlayermoderationApiFp(this.configuration).moderateUser(moderateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a player moderation previously added through `moderateUser`. E.g if you previously have shown their avatar, but now want to reset it to default.
     * @summary Unmoderate User
     * @param {ModerateUserRequest} moderateUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayermoderationApi
     */
    public unmoderateUser(moderateUserRequest: ModerateUserRequest, options?: AxiosRequestConfig) {
        return PlayermoderationApiFp(this.configuration).unmoderateUser(moderateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PrintsApi - axios parameter creator
 * @export
 */
export const PrintsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a print.
         * @summary Delete Print
         * @param {string} printId Print ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrint: async (printId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'printId' is not null or undefined
            assertParamExists('deletePrint', 'printId', printId)
            const localVarPath = `/prints/{printId}`
                .replace(`{${"printId"}}`, encodeURIComponent(String(printId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edits a print.
         * @summary Edit Print
         * @param {string} printId Print ID.
         * @param {File} image The binary blob of the png file.
         * @param {string} [note] The caption for the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editPrint: async (printId: string, image: File, note?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'printId' is not null or undefined
            assertParamExists('editPrint', 'printId', printId)
            // verify required parameter 'image' is not null or undefined
            assertParamExists('editPrint', 'image', image)
            const localVarPath = `/prints/{printId}`
                .replace(`{${"printId"}}`, encodeURIComponent(String(printId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication authCookie required


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
            if (note !== undefined) { 
                localVarFormParams.append('note', note as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a print.
         * @summary Get Print
         * @param {string} printId Print ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrint: async (printId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'printId' is not null or undefined
            assertParamExists('getPrint', 'printId', printId)
            const localVarPath = `/prints/{printId}`
                .replace(`{${"printId"}}`, encodeURIComponent(String(printId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all prints of the user. User id has to be your own userId, as you can\'t request other user\'s prints.
         * @summary Get Own Prints
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPrints: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserPrints', 'userId', userId)
            const localVarPath = `/prints/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads and creates a print.
         * @summary Upload Print
         * @param {File} image The binary blob of the png file.
         * @param {string} timestamp The time the image was captured.
         * @param {string} [note] The caption for the image.
         * @param {string} [worldId] The id of the world in which the image was captured.
         * @param {string} [worldName] The name of the world in which the image was captured.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPrint: async (image: File, timestamp: string, note?: string, worldId?: string, worldName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'image' is not null or undefined
            assertParamExists('uploadPrint', 'image', image)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('uploadPrint', 'timestamp', timestamp)
            const localVarPath = `/prints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication authCookie required


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
            if (timestamp !== undefined) { 
                localVarFormParams.append('timestamp', timestamp as any);
            }
    
            if (note !== undefined) { 
                localVarFormParams.append('note', note as any);
            }
    
            if (worldId !== undefined) { 
                localVarFormParams.append('worldId', worldId as any);
            }
    
            if (worldName !== undefined) { 
                localVarFormParams.append('worldName', worldName as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PrintsApi - functional programming interface
 * @export
 */
export const PrintsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PrintsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a print.
         * @summary Delete Print
         * @param {string} printId Print ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePrint(printId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePrint(printId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edits a print.
         * @summary Edit Print
         * @param {string} printId Print ID.
         * @param {File} image The binary blob of the png file.
         * @param {string} [note] The caption for the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editPrint(printId: string, image: File, note?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Print>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editPrint(printId, image, note, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a print.
         * @summary Get Print
         * @param {string} printId Print ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPrint(printId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Print>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPrint(printId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of all prints of the user. User id has to be your own userId, as you can\'t request other user\'s prints.
         * @summary Get Own Prints
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserPrints(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Print>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserPrints(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Uploads and creates a print.
         * @summary Upload Print
         * @param {File} image The binary blob of the png file.
         * @param {string} timestamp The time the image was captured.
         * @param {string} [note] The caption for the image.
         * @param {string} [worldId] The id of the world in which the image was captured.
         * @param {string} [worldName] The name of the world in which the image was captured.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadPrint(image: File, timestamp: string, note?: string, worldId?: string, worldName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Print>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadPrint(image, timestamp, note, worldId, worldName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PrintsApi - factory interface
 * @export
 */
export const PrintsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PrintsApiFp(configuration)
    return {
        /**
         * Returns a print.
         * @summary Delete Print
         * @param {string} printId Print ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrint(printId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePrint(printId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edits a print.
         * @summary Edit Print
         * @param {string} printId Print ID.
         * @param {File} image The binary blob of the png file.
         * @param {string} [note] The caption for the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editPrint(printId: string, image: File, note?: string, options?: any): AxiosPromise<Print> {
            return localVarFp.editPrint(printId, image, note, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a print.
         * @summary Get Print
         * @param {string} printId Print ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrint(printId: string, options?: any): AxiosPromise<Print> {
            return localVarFp.getPrint(printId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all prints of the user. User id has to be your own userId, as you can\'t request other user\'s prints.
         * @summary Get Own Prints
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPrints(userId: string, options?: any): AxiosPromise<Array<Print>> {
            return localVarFp.getUserPrints(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads and creates a print.
         * @summary Upload Print
         * @param {File} image The binary blob of the png file.
         * @param {string} timestamp The time the image was captured.
         * @param {string} [note] The caption for the image.
         * @param {string} [worldId] The id of the world in which the image was captured.
         * @param {string} [worldName] The name of the world in which the image was captured.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPrint(image: File, timestamp: string, note?: string, worldId?: string, worldName?: string, options?: any): AxiosPromise<Print> {
            return localVarFp.uploadPrint(image, timestamp, note, worldId, worldName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PrintsApi - object-oriented interface
 * @export
 * @class PrintsApi
 * @extends {BaseAPI}
 */
export class PrintsApi extends BaseAPI {
    /**
     * Returns a print.
     * @summary Delete Print
     * @param {string} printId Print ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrintsApi
     */
    public deletePrint(printId: string, options?: AxiosRequestConfig) {
        return PrintsApiFp(this.configuration).deletePrint(printId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edits a print.
     * @summary Edit Print
     * @param {string} printId Print ID.
     * @param {File} image The binary blob of the png file.
     * @param {string} [note] The caption for the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrintsApi
     */
    public editPrint(printId: string, image: File, note?: string, options?: AxiosRequestConfig) {
        return PrintsApiFp(this.configuration).editPrint(printId, image, note, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a print.
     * @summary Get Print
     * @param {string} printId Print ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrintsApi
     */
    public getPrint(printId: string, options?: AxiosRequestConfig) {
        return PrintsApiFp(this.configuration).getPrint(printId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all prints of the user. User id has to be your own userId, as you can\'t request other user\'s prints.
     * @summary Get Own Prints
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrintsApi
     */
    public getUserPrints(userId: string, options?: AxiosRequestConfig) {
        return PrintsApiFp(this.configuration).getUserPrints(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads and creates a print.
     * @summary Upload Print
     * @param {File} image The binary blob of the png file.
     * @param {string} timestamp The time the image was captured.
     * @param {string} [note] The caption for the image.
     * @param {string} [worldId] The id of the world in which the image was captured.
     * @param {string} [worldName] The name of the world in which the image was captured.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrintsApi
     */
    public uploadPrint(image: File, timestamp: string, note?: string, worldId?: string, worldName?: string, options?: AxiosRequestConfig) {
        return PrintsApiFp(this.configuration).uploadPrint(image, timestamp, note, worldId, worldName, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds tags to the user\'s profile
         * @summary Add User Tags
         * @param {string} userId Must be a valid user ID.
         * @param {ChangeUserTagsRequest} changeUserTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTags: async (userId: string, changeUserTagsRequest: ChangeUserTagsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('addTags', 'userId', userId)
            // verify required parameter 'changeUserTagsRequest' is not null or undefined
            assertParamExists('addTags', 'changeUserTagsRequest', changeUserTagsRequest)
            const localVarPath = `/users/{userId}/addTags`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeUserTagsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks whether the user has persistence data for a given world
         * @summary Check User Persistence Exists
         * @param {string} userId Must be a valid user ID.
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUserPersistenceExists: async (userId: string, worldId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('checkUserPersistenceExists', 'userId', userId)
            // verify required parameter 'worldId' is not null or undefined
            assertParamExists('checkUserPersistenceExists', 'worldId', worldId)
            const localVarPath = `/users/{userId}/{worldId}/persist/exists`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"worldId"}}`, encodeURIComponent(String(worldId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the user\'s persistence data for a given world
         * @summary Delete User Persistence
         * @param {string} userId Must be a valid user ID.
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserPersistence: async (userId: string, worldId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserPersistence', 'userId', userId)
            // verify required parameter 'worldId' is not null or undefined
            assertParamExists('deleteUserPersistence', 'worldId', worldId)
            const localVarPath = `/users/{userId}/{worldId}/persist`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"worldId"}}`, encodeURIComponent(String(worldId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get public user information about a specific user using their ID.
         * @summary Get User by ID
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ~~Get public user information about a specific user using their name.~~  **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429). This endpoint now require Admin Credentials.
         * @summary Get User by Username
         * @param {string} username Username of the user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserByName: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getUserByName', 'username', username)
            const localVarPath = `/users/{username}/name`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user\'s submitted feedback
         * @summary Get User Feedback
         * @param {string} userId Must be a valid user ID.
         * @param {boolean} [contentId] Filter for users\&#39; previously submitted feedback, e.g., a groupId, useeId, avatarId, etc.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserFeedback: async (userId: string, contentId?: boolean, n?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserFeedback', 'userId', userId)
            const localVarPath = `/users/{userId}/feedback`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            if (contentId !== undefined) {
                localVarQueryParameter['contentId'] = contentId;
            }

            if (n !== undefined) {
                localVarQueryParameter['n'] = n;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of group instances for a user
         * @summary Get User Group Instances
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroupInstances: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserGroupInstances', 'userId', userId)
            const localVarPath = `/users/{userId}/instances/groups`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Groups the user has requested to be invited into.
         * @summary Get User Group Requests
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroupRequests: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserGroupRequests', 'userId', userId)
            const localVarPath = `/users/{userId}/groups/requested`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user\'s public groups
         * @summary Get User Groups
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroups: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserGroups', 'userId', userId)
            const localVarPath = `/users/{userId}/groups`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a particular user note
         * @summary Get User Note
         * @param {string} userNoteId Must be a valid user note ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNote: async (userNoteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userNoteId' is not null or undefined
            assertParamExists('getUserNote', 'userNoteId', userNoteId)
            const localVarPath = `/userNotes/{userNoteId}`
                .replace(`{${"userNoteId"}}`, encodeURIComponent(String(userNoteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recently updated user notes
         * @summary Get User Notes
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotes: async (n?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/userNotes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            if (n !== undefined) {
                localVarQueryParameter['n'] = n;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the current group that the user is currently representing
         * @summary Get user\'s current represented group
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepresentedGroup: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserRepresentedGroup', 'userId', userId)
            const localVarPath = `/users/{userId}/groups/represented`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes tags from the user\'s profile
         * @summary Remove User Tags
         * @param {string} userId Must be a valid user ID.
         * @param {ChangeUserTagsRequest} changeUserTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTags: async (userId: string, changeUserTagsRequest: ChangeUserTagsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removeTags', 'userId', userId)
            // verify required parameter 'changeUserTagsRequest' is not null or undefined
            assertParamExists('removeTags', 'changeUserTagsRequest', changeUserTagsRequest)
            const localVarPath = `/users/{userId}/removeTags`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeUserTagsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search and list any users by text query
         * @summary Search All Users
         * @param {string} [search] Searches by &#x60;displayName&#x60;. Will return empty array if search query is empty or missing.
         * @param {string} [developerType] Active user by developer type, none for normal users and internal for moderators
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers: async (search?: string, developerType?: string, n?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (developerType !== undefined) {
                localVarQueryParameter['developerType'] = developerType;
            }

            if (n !== undefined) {
                localVarQueryParameter['n'] = n;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a user\'s badge
         * @summary Update User Badge
         * @param {string} userId Must be a valid user ID.
         * @param {string} badgeId Must be a valid badge ID.
         * @param {UpdateUserBadgeRequest} updateUserBadgeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBadge: async (userId: string, badgeId: string, updateUserBadgeRequest: UpdateUserBadgeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateBadge', 'userId', userId)
            // verify required parameter 'badgeId' is not null or undefined
            assertParamExists('updateBadge', 'badgeId', badgeId)
            // verify required parameter 'updateUserBadgeRequest' is not null or undefined
            assertParamExists('updateBadge', 'updateUserBadgeRequest', updateUserBadgeRequest)
            const localVarPath = `/users/{userId}/badges/{badgeId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"badgeId"}}`, encodeURIComponent(String(badgeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserBadgeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a users information such as the email and birthday.
         * @summary Update User Info
         * @param {string} userId Must be a valid user ID.
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (userId: string, updateUserRequest?: UpdateUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUser', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the currently authenticated user\'s note on a user
         * @summary Update User Note
         * @param {UpdateUserNoteRequest} updateUserNoteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserNote: async (updateUserNoteRequest: UpdateUserNoteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserNoteRequest' is not null or undefined
            assertParamExists('updateUserNote', 'updateUserNoteRequest', updateUserNoteRequest)
            const localVarPath = `/userNotes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserNoteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds tags to the user\'s profile
         * @summary Add User Tags
         * @param {string} userId Must be a valid user ID.
         * @param {ChangeUserTagsRequest} changeUserTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTags(userId: string, changeUserTagsRequest: ChangeUserTagsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTags(userId, changeUserTagsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Checks whether the user has persistence data for a given world
         * @summary Check User Persistence Exists
         * @param {string} userId Must be a valid user ID.
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkUserPersistenceExists(userId: string, worldId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkUserPersistenceExists(userId, worldId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the user\'s persistence data for a given world
         * @summary Delete User Persistence
         * @param {string} userId Must be a valid user ID.
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserPersistence(userId: string, worldId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserPersistence(userId, worldId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get public user information about a specific user using their ID.
         * @summary Get User by ID
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ~~Get public user information about a specific user using their name.~~  **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429). This endpoint now require Admin Credentials.
         * @summary Get User by Username
         * @param {string} username Username of the user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getUserByName(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByName(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get user\'s submitted feedback
         * @summary Get User Feedback
         * @param {string} userId Must be a valid user ID.
         * @param {boolean} [contentId] Filter for users\&#39; previously submitted feedback, e.g., a groupId, useeId, avatarId, etc.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getUserFeedback(userId: string, contentId?: boolean, n?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Feedback>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFeedback(userId, contentId, n, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of group instances for a user
         * @summary Get User Group Instances
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserGroupInstances(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserGroupInstances200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserGroupInstances(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Groups the user has requested to be invited into.
         * @summary Get User Group Requests
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserGroupRequests(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Group>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserGroupRequests(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get user\'s public groups
         * @summary Get User Groups
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserGroups(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LimitedUserGroups>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserGroups(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a particular user note
         * @summary Get User Note
         * @param {string} userNoteId Must be a valid user note ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserNote(userNoteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserNote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserNote(userNoteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get recently updated user notes
         * @summary Get User Notes
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserNotes(n?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserNote>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserNotes(n, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the current group that the user is currently representing
         * @summary Get user\'s current represented group
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRepresentedGroup(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepresentedGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRepresentedGroup(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes tags from the user\'s profile
         * @summary Remove User Tags
         * @param {string} userId Must be a valid user ID.
         * @param {ChangeUserTagsRequest} changeUserTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTags(userId: string, changeUserTagsRequest: ChangeUserTagsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTags(userId, changeUserTagsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search and list any users by text query
         * @summary Search All Users
         * @param {string} [search] Searches by &#x60;displayName&#x60;. Will return empty array if search query is empty or missing.
         * @param {string} [developerType] Active user by developer type, none for normal users and internal for moderators
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUsers(search?: string, developerType?: string, n?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LimitedUserSearch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUsers(search, developerType, n, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a user\'s badge
         * @summary Update User Badge
         * @param {string} userId Must be a valid user ID.
         * @param {string} badgeId Must be a valid badge ID.
         * @param {UpdateUserBadgeRequest} updateUserBadgeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBadge(userId: string, badgeId: string, updateUserBadgeRequest: UpdateUserBadgeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBadge(userId, badgeId, updateUserBadgeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a users information such as the email and birthday.
         * @summary Update User Info
         * @param {string} userId Must be a valid user ID.
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(userId: string, updateUserRequest?: UpdateUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(userId, updateUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the currently authenticated user\'s note on a user
         * @summary Update User Note
         * @param {UpdateUserNoteRequest} updateUserNoteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserNote(updateUserNoteRequest: UpdateUserNoteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserNote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserNote(updateUserNoteRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Adds tags to the user\'s profile
         * @summary Add User Tags
         * @param {string} userId Must be a valid user ID.
         * @param {ChangeUserTagsRequest} changeUserTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTags(userId: string, changeUserTagsRequest: ChangeUserTagsRequest, options?: any): AxiosPromise<CurrentUser> {
            return localVarFp.addTags(userId, changeUserTagsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks whether the user has persistence data for a given world
         * @summary Check User Persistence Exists
         * @param {string} userId Must be a valid user ID.
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUserPersistenceExists(userId: string, worldId: string, options?: any): AxiosPromise<void> {
            return localVarFp.checkUserPersistenceExists(userId, worldId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the user\'s persistence data for a given world
         * @summary Delete User Persistence
         * @param {string} userId Must be a valid user ID.
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserPersistence(userId: string, worldId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserPersistence(userId, worldId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get public user information about a specific user using their ID.
         * @summary Get User by ID
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: string, options?: any): AxiosPromise<User> {
            return localVarFp.getUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * ~~Get public user information about a specific user using their name.~~  **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429). This endpoint now require Admin Credentials.
         * @summary Get User by Username
         * @param {string} username Username of the user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserByName(username: string, options?: any): AxiosPromise<User> {
            return localVarFp.getUserByName(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user\'s submitted feedback
         * @summary Get User Feedback
         * @param {string} userId Must be a valid user ID.
         * @param {boolean} [contentId] Filter for users\&#39; previously submitted feedback, e.g., a groupId, useeId, avatarId, etc.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserFeedback(userId: string, contentId?: boolean, n?: number, offset?: number, options?: any): AxiosPromise<Array<Feedback>> {
            return localVarFp.getUserFeedback(userId, contentId, n, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of group instances for a user
         * @summary Get User Group Instances
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroupInstances(userId: string, options?: any): AxiosPromise<GetUserGroupInstances200Response> {
            return localVarFp.getUserGroupInstances(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Groups the user has requested to be invited into.
         * @summary Get User Group Requests
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroupRequests(userId: string, options?: any): AxiosPromise<Array<Group>> {
            return localVarFp.getUserGroupRequests(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user\'s public groups
         * @summary Get User Groups
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroups(userId: string, options?: any): AxiosPromise<Array<LimitedUserGroups>> {
            return localVarFp.getUserGroups(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a particular user note
         * @summary Get User Note
         * @param {string} userNoteId Must be a valid user note ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNote(userNoteId: string, options?: any): AxiosPromise<UserNote> {
            return localVarFp.getUserNote(userNoteId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get recently updated user notes
         * @summary Get User Notes
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotes(n?: number, offset?: number, options?: any): AxiosPromise<Array<UserNote>> {
            return localVarFp.getUserNotes(n, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the current group that the user is currently representing
         * @summary Get user\'s current represented group
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepresentedGroup(userId: string, options?: any): AxiosPromise<RepresentedGroup> {
            return localVarFp.getUserRepresentedGroup(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes tags from the user\'s profile
         * @summary Remove User Tags
         * @param {string} userId Must be a valid user ID.
         * @param {ChangeUserTagsRequest} changeUserTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTags(userId: string, changeUserTagsRequest: ChangeUserTagsRequest, options?: any): AxiosPromise<CurrentUser> {
            return localVarFp.removeTags(userId, changeUserTagsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Search and list any users by text query
         * @summary Search All Users
         * @param {string} [search] Searches by &#x60;displayName&#x60;. Will return empty array if search query is empty or missing.
         * @param {string} [developerType] Active user by developer type, none for normal users and internal for moderators
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers(search?: string, developerType?: string, n?: number, offset?: number, options?: any): AxiosPromise<Array<LimitedUserSearch>> {
            return localVarFp.searchUsers(search, developerType, n, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a user\'s badge
         * @summary Update User Badge
         * @param {string} userId Must be a valid user ID.
         * @param {string} badgeId Must be a valid badge ID.
         * @param {UpdateUserBadgeRequest} updateUserBadgeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBadge(userId: string, badgeId: string, updateUserBadgeRequest: UpdateUserBadgeRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateBadge(userId, badgeId, updateUserBadgeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a users information such as the email and birthday.
         * @summary Update User Info
         * @param {string} userId Must be a valid user ID.
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(userId: string, updateUserRequest?: UpdateUserRequest, options?: any): AxiosPromise<CurrentUser> {
            return localVarFp.updateUser(userId, updateUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the currently authenticated user\'s note on a user
         * @summary Update User Note
         * @param {UpdateUserNoteRequest} updateUserNoteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserNote(updateUserNoteRequest: UpdateUserNoteRequest, options?: any): AxiosPromise<UserNote> {
            return localVarFp.updateUserNote(updateUserNoteRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Adds tags to the user\'s profile
     * @summary Add User Tags
     * @param {string} userId Must be a valid user ID.
     * @param {ChangeUserTagsRequest} changeUserTagsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public addTags(userId: string, changeUserTagsRequest: ChangeUserTagsRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).addTags(userId, changeUserTagsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks whether the user has persistence data for a given world
     * @summary Check User Persistence Exists
     * @param {string} userId Must be a valid user ID.
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public checkUserPersistenceExists(userId: string, worldId: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).checkUserPersistenceExists(userId, worldId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the user\'s persistence data for a given world
     * @summary Delete User Persistence
     * @param {string} userId Must be a valid user ID.
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUserPersistence(userId: string, worldId: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUserPersistence(userId, worldId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get public user information about a specific user using their ID.
     * @summary Get User by ID
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(userId: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ~~Get public user information about a specific user using their name.~~  **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429). This endpoint now require Admin Credentials.
     * @summary Get User by Username
     * @param {string} username Username of the user
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserByName(username: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserByName(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user\'s submitted feedback
     * @summary Get User Feedback
     * @param {string} userId Must be a valid user ID.
     * @param {boolean} [contentId] Filter for users\&#39; previously submitted feedback, e.g., a groupId, useeId, avatarId, etc.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserFeedback(userId: string, contentId?: boolean, n?: number, offset?: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserFeedback(userId, contentId, n, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of group instances for a user
     * @summary Get User Group Instances
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserGroupInstances(userId: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserGroupInstances(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Groups the user has requested to be invited into.
     * @summary Get User Group Requests
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserGroupRequests(userId: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserGroupRequests(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user\'s public groups
     * @summary Get User Groups
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserGroups(userId: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserGroups(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a particular user note
     * @summary Get User Note
     * @param {string} userNoteId Must be a valid user note ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserNote(userNoteId: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserNote(userNoteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recently updated user notes
     * @summary Get User Notes
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserNotes(n?: number, offset?: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserNotes(n, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the current group that the user is currently representing
     * @summary Get user\'s current represented group
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserRepresentedGroup(userId: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserRepresentedGroup(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes tags from the user\'s profile
     * @summary Remove User Tags
     * @param {string} userId Must be a valid user ID.
     * @param {ChangeUserTagsRequest} changeUserTagsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public removeTags(userId: string, changeUserTagsRequest: ChangeUserTagsRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).removeTags(userId, changeUserTagsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search and list any users by text query
     * @summary Search All Users
     * @param {string} [search] Searches by &#x60;displayName&#x60;. Will return empty array if search query is empty or missing.
     * @param {string} [developerType] Active user by developer type, none for normal users and internal for moderators
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public searchUsers(search?: string, developerType?: string, n?: number, offset?: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).searchUsers(search, developerType, n, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a user\'s badge
     * @summary Update User Badge
     * @param {string} userId Must be a valid user ID.
     * @param {string} badgeId Must be a valid badge ID.
     * @param {UpdateUserBadgeRequest} updateUserBadgeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateBadge(userId: string, badgeId: string, updateUserBadgeRequest: UpdateUserBadgeRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateBadge(userId, badgeId, updateUserBadgeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a users information such as the email and birthday.
     * @summary Update User Info
     * @param {string} userId Must be a valid user ID.
     * @param {UpdateUserRequest} [updateUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(userId: string, updateUserRequest?: UpdateUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUser(userId, updateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the currently authenticated user\'s note on a user
     * @summary Update User Note
     * @param {UpdateUserNoteRequest} updateUserNoteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserNote(updateUserNoteRequest: UpdateUserNoteRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserNote(updateUserNoteRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorldsApi - axios parameter creator
 * @export
 */
export const WorldsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Checks whether the user has persistence data for a given world
         * @summary Check User Persistence Exists
         * @param {string} userId Must be a valid user ID.
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUserPersistenceExists: async (userId: string, worldId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('checkUserPersistenceExists', 'userId', userId)
            // verify required parameter 'worldId' is not null or undefined
            assertParamExists('checkUserPersistenceExists', 'worldId', worldId)
            const localVarPath = `/users/{userId}/{worldId}/persist/exists`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"worldId"}}`, encodeURIComponent(String(worldId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new world. This endpoint requires `assetUrl` to be a valid File object with `.vrcw` file extension, and `imageUrl` to be a valid File object with an image file extension.
         * @summary Create World
         * @param {CreateWorldRequest} [createWorldRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorld: async (createWorldRequest?: CreateWorldRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/worlds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWorldRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the user\'s persistence data for a given world
         * @summary Delete User Persistence
         * @param {string} userId Must be a valid user ID.
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserPersistence: async (userId: string, worldId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserPersistence', 'userId', userId)
            // verify required parameter 'worldId' is not null or undefined
            assertParamExists('deleteUserPersistence', 'worldId', worldId)
            const localVarPath = `/users/{userId}/{worldId}/persist`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"worldId"}}`, encodeURIComponent(String(worldId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a world. Notice a world is never fully \"deleted\", only its ReleaseStatus is set to \"hidden\" and the linked Files are deleted. The WorldID is permanently reserved.
         * @summary Delete World
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorld: async (worldId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'worldId' is not null or undefined
            assertParamExists('deleteWorld', 'worldId', worldId)
            const localVarPath = `/worlds/{worldId}`
                .replace(`{${"worldId"}}`, encodeURIComponent(String(worldId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search and list currently Active worlds by query filters.
         * @summary List Active Worlds
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [search] Filters by world name.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveWorlds: async (featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/worlds/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            if (featured !== undefined) {
                localVarQueryParameter['featured'] = featured;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (n !== undefined) {
                localVarQueryParameter['n'] = n;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (notag !== undefined) {
                localVarQueryParameter['notag'] = notag;
            }

            if (releaseStatus !== undefined) {
                localVarQueryParameter['releaseStatus'] = releaseStatus;
            }

            if (maxUnityVersion !== undefined) {
                localVarQueryParameter['maxUnityVersion'] = maxUnityVersion;
            }

            if (minUnityVersion !== undefined) {
                localVarQueryParameter['minUnityVersion'] = minUnityVersion;
            }

            if (platform !== undefined) {
                localVarQueryParameter['platform'] = platform;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search and list favorited worlds by query filters.
         * @summary List Favorited Worlds
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [search] Filters by world name.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {string} [userId] Target user to see information on, admin-only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoritedWorlds: async (featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, userId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/worlds/favorites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            if (featured !== undefined) {
                localVarQueryParameter['featured'] = featured;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (n !== undefined) {
                localVarQueryParameter['n'] = n;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (notag !== undefined) {
                localVarQueryParameter['notag'] = notag;
            }

            if (releaseStatus !== undefined) {
                localVarQueryParameter['releaseStatus'] = releaseStatus;
            }

            if (maxUnityVersion !== undefined) {
                localVarQueryParameter['maxUnityVersion'] = maxUnityVersion;
            }

            if (minUnityVersion !== undefined) {
                localVarQueryParameter['minUnityVersion'] = minUnityVersion;
            }

            if (platform !== undefined) {
                localVarQueryParameter['platform'] = platform;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search and list recently visited worlds by query filters.
         * @summary List Recent Worlds
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [search] Filters by world name.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {string} [userId] Target user to see information on, admin-only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentWorlds: async (featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, userId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/worlds/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            if (featured !== undefined) {
                localVarQueryParameter['featured'] = featured;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (n !== undefined) {
                localVarQueryParameter['n'] = n;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (notag !== undefined) {
                localVarQueryParameter['notag'] = notag;
            }

            if (releaseStatus !== undefined) {
                localVarQueryParameter['releaseStatus'] = releaseStatus;
            }

            if (maxUnityVersion !== undefined) {
                localVarQueryParameter['maxUnityVersion'] = maxUnityVersion;
            }

            if (minUnityVersion !== undefined) {
                localVarQueryParameter['minUnityVersion'] = minUnityVersion;
            }

            if (platform !== undefined) {
                localVarQueryParameter['platform'] = platform;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a specific World. Works unauthenticated but when so will always return `0` for certain fields.
         * @summary Get World by ID
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorld: async (worldId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'worldId' is not null or undefined
            assertParamExists('getWorld', 'worldId', worldId)
            const localVarPath = `/worlds/{worldId}`
                .replace(`{${"worldId"}}`, encodeURIComponent(String(worldId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a worlds instance.
         * @summary Get World Instance
         * @param {string} worldId Must be a valid world ID.
         * @param {string} instanceId Must be a valid instance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorldInstance: async (worldId: string, instanceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'worldId' is not null or undefined
            assertParamExists('getWorldInstance', 'worldId', worldId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('getWorldInstance', 'instanceId', instanceId)
            const localVarPath = `/worlds/{worldId}/{instanceId}`
                .replace(`{${"worldId"}}`, encodeURIComponent(String(worldId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a worlds custom metadata. This is currently believed to be unused. Metadata can be set with `updateWorld` and can be any arbitrary object.
         * @summary Get World Metadata
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getWorldMetadata: async (worldId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'worldId' is not null or undefined
            assertParamExists('getWorldMetadata', 'worldId', worldId)
            const localVarPath = `/worlds/{worldId}/metadata`
                .replace(`{${"worldId"}}`, encodeURIComponent(String(worldId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a worlds publish status.
         * @summary Get World Publish Status
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorldPublishStatus: async (worldId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'worldId' is not null or undefined
            assertParamExists('getWorldPublishStatus', 'worldId', worldId)
            const localVarPath = `/worlds/{worldId}/publish`
                .replace(`{${"worldId"}}`, encodeURIComponent(String(worldId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Publish a world. You can only publish one world per week.
         * @summary Publish World
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishWorld: async (worldId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'worldId' is not null or undefined
            assertParamExists('publishWorld', 'worldId', worldId)
            const localVarPath = `/worlds/{worldId}/publish`
                .replace(`{${"worldId"}}`, encodeURIComponent(String(worldId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search and list any worlds by query filters.
         * @summary Search All Worlds
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {'me'} [user] Set to &#x60;me&#x60; for searching own worlds.
         * @param {string} [userId] Filter by UserID.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [search] Filters by world name.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {boolean} [fuzzy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchWorlds: async (featured?: boolean, sort?: SortOption, user?: 'me', userId?: string, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, fuzzy?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/worlds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            if (featured !== undefined) {
                localVarQueryParameter['featured'] = featured;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (n !== undefined) {
                localVarQueryParameter['n'] = n;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (notag !== undefined) {
                localVarQueryParameter['notag'] = notag;
            }

            if (releaseStatus !== undefined) {
                localVarQueryParameter['releaseStatus'] = releaseStatus;
            }

            if (maxUnityVersion !== undefined) {
                localVarQueryParameter['maxUnityVersion'] = maxUnityVersion;
            }

            if (minUnityVersion !== undefined) {
                localVarQueryParameter['minUnityVersion'] = minUnityVersion;
            }

            if (platform !== undefined) {
                localVarQueryParameter['platform'] = platform;
            }

            if (fuzzy !== undefined) {
                localVarQueryParameter['fuzzy'] = fuzzy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unpublish a world.
         * @summary Unpublish World
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublishWorld: async (worldId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'worldId' is not null or undefined
            assertParamExists('unpublishWorld', 'worldId', worldId)
            const localVarPath = `/worlds/{worldId}/publish`
                .replace(`{${"worldId"}}`, encodeURIComponent(String(worldId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update information about a specific World.
         * @summary Update World
         * @param {string} worldId Must be a valid world ID.
         * @param {UpdateWorldRequest} [updateWorldRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorld: async (worldId: string, updateWorldRequest?: UpdateWorldRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'worldId' is not null or undefined
            assertParamExists('updateWorld', 'worldId', worldId)
            const localVarPath = `/worlds/{worldId}`
                .replace(`{${"worldId"}}`, encodeURIComponent(String(worldId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWorldRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorldsApi - functional programming interface
 * @export
 */
export const WorldsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorldsApiAxiosParamCreator(configuration)
    return {
        /**
         * Checks whether the user has persistence data for a given world
         * @summary Check User Persistence Exists
         * @param {string} userId Must be a valid user ID.
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkUserPersistenceExists(userId: string, worldId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkUserPersistenceExists(userId, worldId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new world. This endpoint requires `assetUrl` to be a valid File object with `.vrcw` file extension, and `imageUrl` to be a valid File object with an image file extension.
         * @summary Create World
         * @param {CreateWorldRequest} [createWorldRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorld(createWorldRequest?: CreateWorldRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<World>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorld(createWorldRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the user\'s persistence data for a given world
         * @summary Delete User Persistence
         * @param {string} userId Must be a valid user ID.
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserPersistence(userId: string, worldId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserPersistence(userId, worldId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a world. Notice a world is never fully \"deleted\", only its ReleaseStatus is set to \"hidden\" and the linked Files are deleted. The WorldID is permanently reserved.
         * @summary Delete World
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorld(worldId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorld(worldId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search and list currently Active worlds by query filters.
         * @summary List Active Worlds
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [search] Filters by world name.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveWorlds(featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LimitedWorld>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveWorlds(featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search and list favorited worlds by query filters.
         * @summary List Favorited Worlds
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [search] Filters by world name.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {string} [userId] Target user to see information on, admin-only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFavoritedWorlds(featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FavoritedWorld>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFavoritedWorlds(featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search and list recently visited worlds by query filters.
         * @summary List Recent Worlds
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [search] Filters by world name.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {string} [userId] Target user to see information on, admin-only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentWorlds(featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LimitedWorld>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentWorlds(featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information about a specific World. Works unauthenticated but when so will always return `0` for certain fields.
         * @summary Get World by ID
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorld(worldId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<World>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorld(worldId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a worlds instance.
         * @summary Get World Instance
         * @param {string} worldId Must be a valid world ID.
         * @param {string} instanceId Must be a valid instance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorldInstance(worldId: string, instanceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Instance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorldInstance(worldId, instanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return a worlds custom metadata. This is currently believed to be unused. Metadata can be set with `updateWorld` and can be any arbitrary object.
         * @summary Get World Metadata
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getWorldMetadata(worldId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorldMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorldMetadata(worldId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a worlds publish status.
         * @summary Get World Publish Status
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorldPublishStatus(worldId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorldPublishStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorldPublishStatus(worldId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Publish a world. You can only publish one world per week.
         * @summary Publish World
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishWorld(worldId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishWorld(worldId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search and list any worlds by query filters.
         * @summary Search All Worlds
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {'me'} [user] Set to &#x60;me&#x60; for searching own worlds.
         * @param {string} [userId] Filter by UserID.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [search] Filters by world name.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {boolean} [fuzzy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchWorlds(featured?: boolean, sort?: SortOption, user?: 'me', userId?: string, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, fuzzy?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LimitedWorld>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchWorlds(featured, sort, user, userId, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, fuzzy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unpublish a world.
         * @summary Unpublish World
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unpublishWorld(worldId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unpublishWorld(worldId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update information about a specific World.
         * @summary Update World
         * @param {string} worldId Must be a valid world ID.
         * @param {UpdateWorldRequest} [updateWorldRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorld(worldId: string, updateWorldRequest?: UpdateWorldRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<World>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorld(worldId, updateWorldRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorldsApi - factory interface
 * @export
 */
export const WorldsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorldsApiFp(configuration)
    return {
        /**
         * Checks whether the user has persistence data for a given world
         * @summary Check User Persistence Exists
         * @param {string} userId Must be a valid user ID.
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUserPersistenceExists(userId: string, worldId: string, options?: any): AxiosPromise<void> {
            return localVarFp.checkUserPersistenceExists(userId, worldId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new world. This endpoint requires `assetUrl` to be a valid File object with `.vrcw` file extension, and `imageUrl` to be a valid File object with an image file extension.
         * @summary Create World
         * @param {CreateWorldRequest} [createWorldRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorld(createWorldRequest?: CreateWorldRequest, options?: any): AxiosPromise<World> {
            return localVarFp.createWorld(createWorldRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the user\'s persistence data for a given world
         * @summary Delete User Persistence
         * @param {string} userId Must be a valid user ID.
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserPersistence(userId: string, worldId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserPersistence(userId, worldId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a world. Notice a world is never fully \"deleted\", only its ReleaseStatus is set to \"hidden\" and the linked Files are deleted. The WorldID is permanently reserved.
         * @summary Delete World
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorld(worldId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWorld(worldId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search and list currently Active worlds by query filters.
         * @summary List Active Worlds
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [search] Filters by world name.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveWorlds(featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, options?: any): AxiosPromise<Array<LimitedWorld>> {
            return localVarFp.getActiveWorlds(featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, options).then((request) => request(axios, basePath));
        },
        /**
         * Search and list favorited worlds by query filters.
         * @summary List Favorited Worlds
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [search] Filters by world name.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {string} [userId] Target user to see information on, admin-only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoritedWorlds(featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, userId?: string, options?: any): AxiosPromise<Array<FavoritedWorld>> {
            return localVarFp.getFavoritedWorlds(featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search and list recently visited worlds by query filters.
         * @summary List Recent Worlds
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [search] Filters by world name.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {string} [userId] Target user to see information on, admin-only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentWorlds(featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, userId?: string, options?: any): AxiosPromise<Array<LimitedWorld>> {
            return localVarFp.getRecentWorlds(featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about a specific World. Works unauthenticated but when so will always return `0` for certain fields.
         * @summary Get World by ID
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorld(worldId: string, options?: any): AxiosPromise<World> {
            return localVarFp.getWorld(worldId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a worlds instance.
         * @summary Get World Instance
         * @param {string} worldId Must be a valid world ID.
         * @param {string} instanceId Must be a valid instance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorldInstance(worldId: string, instanceId: string, options?: any): AxiosPromise<Instance> {
            return localVarFp.getWorldInstance(worldId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a worlds custom metadata. This is currently believed to be unused. Metadata can be set with `updateWorld` and can be any arbitrary object.
         * @summary Get World Metadata
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getWorldMetadata(worldId: string, options?: any): AxiosPromise<WorldMetadata> {
            return localVarFp.getWorldMetadata(worldId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a worlds publish status.
         * @summary Get World Publish Status
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorldPublishStatus(worldId: string, options?: any): AxiosPromise<WorldPublishStatus> {
            return localVarFp.getWorldPublishStatus(worldId, options).then((request) => request(axios, basePath));
        },
        /**
         * Publish a world. You can only publish one world per week.
         * @summary Publish World
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishWorld(worldId: string, options?: any): AxiosPromise<void> {
            return localVarFp.publishWorld(worldId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search and list any worlds by query filters.
         * @summary Search All Worlds
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {'me'} [user] Set to &#x60;me&#x60; for searching own worlds.
         * @param {string} [userId] Filter by UserID.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [search] Filters by world name.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {boolean} [fuzzy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchWorlds(featured?: boolean, sort?: SortOption, user?: 'me', userId?: string, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, fuzzy?: boolean, options?: any): AxiosPromise<Array<LimitedWorld>> {
            return localVarFp.searchWorlds(featured, sort, user, userId, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, fuzzy, options).then((request) => request(axios, basePath));
        },
        /**
         * Unpublish a world.
         * @summary Unpublish World
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublishWorld(worldId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unpublishWorld(worldId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update information about a specific World.
         * @summary Update World
         * @param {string} worldId Must be a valid world ID.
         * @param {UpdateWorldRequest} [updateWorldRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorld(worldId: string, updateWorldRequest?: UpdateWorldRequest, options?: any): AxiosPromise<World> {
            return localVarFp.updateWorld(worldId, updateWorldRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorldsApi - object-oriented interface
 * @export
 * @class WorldsApi
 * @extends {BaseAPI}
 */
export class WorldsApi extends BaseAPI {
    /**
     * Checks whether the user has persistence data for a given world
     * @summary Check User Persistence Exists
     * @param {string} userId Must be a valid user ID.
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    public checkUserPersistenceExists(userId: string, worldId: string, options?: AxiosRequestConfig) {
        return WorldsApiFp(this.configuration).checkUserPersistenceExists(userId, worldId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new world. This endpoint requires `assetUrl` to be a valid File object with `.vrcw` file extension, and `imageUrl` to be a valid File object with an image file extension.
     * @summary Create World
     * @param {CreateWorldRequest} [createWorldRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    public createWorld(createWorldRequest?: CreateWorldRequest, options?: AxiosRequestConfig) {
        return WorldsApiFp(this.configuration).createWorld(createWorldRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the user\'s persistence data for a given world
     * @summary Delete User Persistence
     * @param {string} userId Must be a valid user ID.
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    public deleteUserPersistence(userId: string, worldId: string, options?: AxiosRequestConfig) {
        return WorldsApiFp(this.configuration).deleteUserPersistence(userId, worldId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a world. Notice a world is never fully \"deleted\", only its ReleaseStatus is set to \"hidden\" and the linked Files are deleted. The WorldID is permanently reserved.
     * @summary Delete World
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    public deleteWorld(worldId: string, options?: AxiosRequestConfig) {
        return WorldsApiFp(this.configuration).deleteWorld(worldId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search and list currently Active worlds by query filters.
     * @summary List Active Worlds
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [search] Filters by world name.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    public getActiveWorlds(featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, options?: AxiosRequestConfig) {
        return WorldsApiFp(this.configuration).getActiveWorlds(featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search and list favorited worlds by query filters.
     * @summary List Favorited Worlds
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [search] Filters by world name.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {string} [userId] Target user to see information on, admin-only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    public getFavoritedWorlds(featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, userId?: string, options?: AxiosRequestConfig) {
        return WorldsApiFp(this.configuration).getFavoritedWorlds(featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search and list recently visited worlds by query filters.
     * @summary List Recent Worlds
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [search] Filters by world name.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {string} [userId] Target user to see information on, admin-only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    public getRecentWorlds(featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, userId?: string, options?: AxiosRequestConfig) {
        return WorldsApiFp(this.configuration).getRecentWorlds(featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about a specific World. Works unauthenticated but when so will always return `0` for certain fields.
     * @summary Get World by ID
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    public getWorld(worldId: string, options?: AxiosRequestConfig) {
        return WorldsApiFp(this.configuration).getWorld(worldId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a worlds instance.
     * @summary Get World Instance
     * @param {string} worldId Must be a valid world ID.
     * @param {string} instanceId Must be a valid instance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    public getWorldInstance(worldId: string, instanceId: string, options?: AxiosRequestConfig) {
        return WorldsApiFp(this.configuration).getWorldInstance(worldId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a worlds custom metadata. This is currently believed to be unused. Metadata can be set with `updateWorld` and can be any arbitrary object.
     * @summary Get World Metadata
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    public getWorldMetadata(worldId: string, options?: AxiosRequestConfig) {
        return WorldsApiFp(this.configuration).getWorldMetadata(worldId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a worlds publish status.
     * @summary Get World Publish Status
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    public getWorldPublishStatus(worldId: string, options?: AxiosRequestConfig) {
        return WorldsApiFp(this.configuration).getWorldPublishStatus(worldId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Publish a world. You can only publish one world per week.
     * @summary Publish World
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    public publishWorld(worldId: string, options?: AxiosRequestConfig) {
        return WorldsApiFp(this.configuration).publishWorld(worldId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search and list any worlds by query filters.
     * @summary Search All Worlds
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {'me'} [user] Set to &#x60;me&#x60; for searching own worlds.
     * @param {string} [userId] Filter by UserID.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [search] Filters by world name.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {boolean} [fuzzy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    public searchWorlds(featured?: boolean, sort?: SortOption, user?: 'me', userId?: string, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, fuzzy?: boolean, options?: AxiosRequestConfig) {
        return WorldsApiFp(this.configuration).searchWorlds(featured, sort, user, userId, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, fuzzy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unpublish a world.
     * @summary Unpublish World
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    public unpublishWorld(worldId: string, options?: AxiosRequestConfig) {
        return WorldsApiFp(this.configuration).unpublishWorld(worldId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update information about a specific World.
     * @summary Update World
     * @param {string} worldId Must be a valid world ID.
     * @param {UpdateWorldRequest} [updateWorldRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    public updateWorld(worldId: string, updateWorldRequest?: UpdateWorldRequest, options?: AxiosRequestConfig) {
        return WorldsApiFp(this.configuration).updateWorld(worldId, updateWorldRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


